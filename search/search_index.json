{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Framework for industrial data integration and automation</p> <p> </p> <p>aas-middleware has the goal to make information flow and orchestration in industrial environments easier and more automated. To do so, it is build upon three concepts: well defined data models and interfaces, connectors and workflows. The data models are used to define the structure of the data that is exchanged between different systems. The connectors are used to connect the data models to technologically different data sources and sinks. Workflows are used to define the orchestration of the data flow between different systems. </p> <p>Standard api technologies (Rest or GraphQL) of the middleware make it easy to access the integrated data models or exchange data with low-level sensors and actuators. The middleware can be used to integrate different systems in the industrial environment, such as MES, ERP, SCADA, PLC, sensors and actuators. By the modular and extensible design of aas-middleware, it can be used from small use cases, such as streaming sensor values, to large integrations and workflows for automated production planning and control. </p> <p>For more information to use the middleware, read the getting started below or refer to the  of the package.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command in the terminal: </p> <pre><code>pip install aas-middleware\n</code></pre> <p>To install the package with extras for industrial data integration (opc ua and mqtt), run the following command in the terminal:</p> <pre><code>pip install aas-middleware[industrial]\n</code></pre> <p>Alternatively, you can install the package with poetry for development:</p> <pre><code>poetry shell\npoetry install\n</code></pre> <p>Please note that the package is only compatible with Python 3.10 or higher.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>In the following, we will consider a minimal example to demonstrate the usage of the package. The example is also available in the examples and consists of defining a simple aas-based data model to describe a product, serializing this data model to asset administration shells, making the data model available with rest API and defining examplary connectors and workflows.</p> <p>For further examples, like connecting the data model to a data source, or creating workflows, refer to the tutorials in the documentation.</p>"},{"location":"#defining-a-simple-data-model-and-formatting","title":"Defining a simple data model and formatting","text":"<p>At first, we create a simple data model with the basic building blocks (AAS and Submodel) of aas2openapi:</p> <pre><code>import typing\nimport aas_middleware\n\nclass BillOfMaterialInfo(aas_middleware.SubmodelElementCollection):\n    manufacterer: str\n    product_type: str\n\nclass BillOfMaterial(aas_middleware.Submodel):\n    components: typing.List[str]\n    bill_of_material_info: BillOfMaterialInfo\n\n\nclass ProcessModel(aas_middleware.Submodel):\n    processes: typing.List[str]\n\n\nclass Product(aas_middleware.AAS):\n    bill_of_material: BillOfMaterial\n    process_model: typing.Optional[ProcessModel]\n</code></pre> <p>The data model consists of a product that has a process model and a bill of material. The process model and the bill of material are contain a list of processes and components, respectively. To be able to instantiate an data model, we create an instance of this data model:</p> <pre><code>example_product = Product(\n    id=\"example_product_id\",\n    id_short=\"example_product_id\",\n    description=\"Example Product\",\n    bill_of_material=BillOfMaterial(\n        id=\"example_bom_id\",\n        id_short=\"example_bom_id\",\n        description=\"Example Bill of Material\",\n        components=[\"component_1\", \"component_2\"],\n        bill_of_material_info=BillOfMaterialInfo(\n            id=\"example_bom_info_id\",\n            id_short=\"example_bom_info_id\",\n            description=\"Example Bill of Material Info\",\n            manufacterer=\"Example Manufacterer\",\n            product_type=\"Example Product Type\",\n        ),\n    ),\n    process_model=ProcessModel(\n        id=\"example_process_model_id\",\n        id_short=\"example_process_model_id\",\n        description=\"Example Process Model\",\n        processes=[\"process_1\", \"process_2\"],\n    ),\n)\n</code></pre> <p>With this instance of the product data model, we can create a DataModel.</p> <pre><code>data_model = aas_middleware.DataModel.from_model(example_product)\n</code></pre> <p>The data model is a container for instances and types of data models. It makes access to individual objects easy and allows for formatting. E.g. we can easily transform the data model to either basyx aas components:</p> <pre><code>basyx_object_store = aas_middleware.formatting.BasyxFormatter().serialize(data_model)\n</code></pre> <p>Or serialize it to a JSON-serialized asset administration shell according to DOT AAS 3.0:</p> <pre><code>json_aas = aas_middleware.formatting.AasJsonFormatter().serialize(data_model)\nprint(json_aas)\n</code></pre> <p>This formatting transformation can also be reversed, so JSON-serialized or Basyx aas can be used to create data models.</p>"},{"location":"#starting-the-middleware-with-aas-persistence","title":"Starting the middleware with aas persistence","text":"<p>Running the middleware with storage of the data model in a basyx aas server can be done by running the following command: </p> <pre><code>middleware = aas_middleware.AasMiddleware()\nmiddleware.load_aas_persistent_data_model(\n    \"example\", data_model, \"localhost\", 8081, \"localhost\", 8081, initial_loading=True\n)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(middleware.app)\n</code></pre> <p>Note, that on port 8081 a aas repository and submodel repository need to be running. The repository already comes with a docker-compose file that can be used to start the AAS and Submodel-server. To start the docker-compose file, run the following command in the terminal:</p> <pre><code>docker-compose -f docker-compose-dev.yaml up\n</code></pre> <p>However, you can also start middlewares with internal memory, just by using <code>aas_middleware.Middleware()</code>.</p> <p>The middleware starts now and registers the example product instance in the aas server. You can access now the documentation of the REST API with swagger at <code>http://localhost:8000/docs</code> and the graphql endpoint at  <code>http://localhost:8000/graphql</code>. We can get the data again in the format of the middleware by sending the following query:</p> <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8000/Product/' \\\n  -H 'accept: application/json'\n</code></pre> <p>We can also instantiate new product data models with post requests:</p> <pre><code>curl -X 'POST' \\\n  'http://127.0.0.1:8000/Product/' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"id_short\": \"product2\",\n  \"description\": \"\",\n  \"id\": \"product2\",\n  \"bill_of_material\": {\n    \"id_short\": \"product2_bom\",\n    \"description\": \"\",\n    \"id\": \"product2_bom\",\n    \"semantic_id\": \"\",\n    \"components\": [\n      \"bearing\", \"screw\"\n    ],\n    \"bill_of_material_info\": {\n      \"id_short\": \"product2_bom_info\",\n      \"description\": \"\",\n      \"semantic_id\": \"\",\n      \"manufacterer\": \"other manufacturer\",\n      \"product_type\": \"wheel\"\n    }\n  },\n  \"process_model\": {\n    \"id_short\": \"product2_process_model\",\n    \"description\": \"\",\n    \"id\": \"product2_process_model\",\n    \"semantic_id\": \"\",\n    \"processes\": [\n      \"assembly\"\n    ]\n  }\n}'\n</code></pre>"},{"location":"#creating-an-examplary-connector-and-workflow","title":"Creating an examplary connector and workflow","text":"<p>A connector in the aas middleware is a component that makes a connector to a data source (provider) or a data sink (consumer). The aas middleware comes with a lot of default connectors (opc ua, mqtt, http, websocket, webhook), but you can add custom ones. A connector only needs to specify a certain interface, that consists of a connect, disconnect, consume and provide function. We define an examplary connector like this and add it to the middleware:</p> <pre><code>class TrivialConnector:\n    def __init__(self):\n        pass\n\n    async def connect(self):\n        pass\n\n    async def disconnect(self):\n        pass\n\n    async def consume(self, body: str) -&gt; None:\n        print(body)\n        pass\n\n    async def provide(self) -&gt; typing.Any:\n        return \"trivial connector example value\"\n\nexample_connector = TrivialConnector()\nmiddleware.add_connector(\"test_connector\", example_connector, model_type=str)\n</code></pre> <p>We can execute this connector either for reading values with the folling get request:</p> <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8000/connectors/test_connector/value' \\\n  -H 'accept: application/json'\n</code></pre> <p>Or send data with the connector to the data sink:</p> <pre><code>curl -X 'POST' \\\n  'http://127.0.0.1:8000/connectors/test_connector/value?value=connector_example_input_value' \\\n  -H 'accept: application/json' \\\n  -d ''\n</code></pre> <p>Lastly, we can define workflows for more complex automation tasks. A workflow is a functino that can be executed in the middleware:</p> <pre><code>@middleware.workflow()\ndef example_workflow(a: str) -&gt; str:\n    print(a)\n    return a\n</code></pre> <p>To run the workflow, execute the followingrequest:</p> <pre><code>curl -X 'POST' \\\n  'http://127.0.0.1:8000/workflows/example_workflow/execute?arg=work_flow_input_value' \\\n  -H 'accept: application/json' \\\n  -d ''\n</code></pre> <p>We can also interrupt the workflow, when it is running:</p> <pre><code>curl -X 'GET' \\\n  'http://127.0.0.1:8000/workflows/example_workflow/interrupt' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p><code>aas-middleware</code> is a new project and has therefore much room for improvement. Therefore, it would be a pleasure to get feedback or support! If you want to contribute to the package, either create issues on aas_middlweware github page for discussing new features or contact me directly via github or email.</p>"},{"location":"#license","title":"License","text":"<p>The package is licensed under the MIT license.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We extend our sincere thanks to the German Federal Ministry for Economic Affairs and Climate Action (BMWK) for supporting this research project 13IK001ZF \u201cSoftware-Defined Manufacturing for the automotive and supplying industry https://www.sdm4fzi.de/.</p>"},{"location":"API_reference/API_reference_0_overview/","title":"API reference overview","text":"<p>This section contains the API reference of <code>aas_middleware</code>. The following modules are available:</p> <ul> <li>model</li> <li>middleware</li> <li>connect</li> </ul>"},{"location":"API_reference/API_reference_1_model/","title":"Model API","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.core","title":"<code>core</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.core.Identifiable","title":"<code> Identifiable            (BaseModel)         </code>","text":"<p>Base class for all identifiable classes that have an identifier, that allows to identify these objects.</p> <p>If no id is set, the id function of the python object is used. Otherwise, a uuid is generated.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Global id of the object.</p> required Source code in <code>aas_middleware\\model\\core.py</code> <pre><code>class Identifiable(BaseModel):\n    \"\"\"\n    Base class for all identifiable classes that have an identifier, that allows to identify these objects.\n\n    If no id is set, the id function of the python object is used. Otherwise, a uuid is generated.\n\n    Args:\n        id (str): Global id of the object.\n    \"\"\"\n\n    id: IdString\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_id_and_id_short(cls, data: Any) -&gt; Any:\n        potential_id = get_id(data)\n        assert potential_id, \"Either id or id_short must be set\"\n        return {\"id\": potential_id}\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model","title":"<code>data_model</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel","title":"<code> DataModel            (BaseModel)         </code>","text":"<p>The data model is a container that allows to store all models of a data model and provides methods to access them easily by their id or type.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Dict[str, Any]</code> <p>The data to load into the data model (used by pydantic).</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>_models_key_id</code> <code>Dict[str, Identifiable]</code> <p>The dictionary of models with their id as key.</p> <code>_top_level_models</code> <code>Dict[str, List[str]]</code> <p>The dictionary of top level models with their type as key.</p> <code>_models_key_type</code> <code>Dict[str, List[str]]</code> <p>The dictionary of models with their type as key.</p> <code>_reference_info_dict_for_referencing</code> <code>Dict[str, Dict[str, ReferenceInfo]]</code> <p>The dictionary of reference infos with keys from the referencing model to the referenced model.</p> <code>_reference_info_dict_for_referenced</code> <code>Dict[str, Dict[str, ReferenceInfo]]</code> <p>The dictionary of reference infos with keys from the referenced model to the referencing model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>class DataModel(BaseModel):\n    \"\"\"\n    The data model is a container that allows to store all models of a data model and provides methods to access them easily by their id or type.\n\n    Args:\n        **data (Dict[str, Any]): The data to load into the data model (used by pydantic).\n\n    Attributes:\n        _models_key_id (Dict[str, Identifiable]): The dictionary of models with their id as key.\n        _top_level_models (Dict[str, List[str]]): The dictionary of top level models with their type as key.\n        _models_key_type (Dict[str, List[str]]): The dictionary of models with their type as key.\n        _reference_info_dict_for_referencing (Dict[str, Dict[str, ReferenceInfo]]): The dictionary of reference infos with keys from the referencing model to the referenced model.\n        _reference_info_dict_for_referenced (Dict[str, Dict[str, ReferenceInfo]]): The dictionary of reference infos with keys from the referenced model to the referencing model.\n    \"\"\"\n\n    _key_ids_models: Dict[str, Identifiable] = {}\n    _top_level_models: Dict[str, List[str]] = {}\n    _models_key_type: Dict[str, List[str]] = {}\n    _reference_infos: Set[ReferenceInfo] = set()\n    _reference_info_dict_for_referencing: Dict[str, Dict[str, ReferenceInfo]] = {}\n    _reference_info_dict_for_referenced: Dict[str, Dict[str, ReferenceInfo]] = {}\n\n    _schemas: Dict[str, Type[Any]] = {}\n    _top_level_schemas: Set[str] = set()\n    _schema_reference_infos: Set[ReferenceInfo] = set()\n    _schema_reference_info_for_referencing: Dict[str, Dict[str, ReferenceInfo]] = {}\n    _schema_reference_info_for_referenced: Dict[str, Dict[str, ReferenceInfo]] = {}\n\n    def __init__(self, **data: Dict[str, Any]):\n        super().__init__(**data)\n        try:\n            Identifiable.model_validate(self)\n            self.add_model(self)\n        except ValidationError:\n            for attribute_value in get_value_attributes(self).values():\n                if is_identifiable_container(attribute_value):\n                    self.add(*attribute_value)\n                else:\n                    self.add(attribute_value)\n\n    @classmethod\n    def from_models(\n        cls, *models: Tuple[Identifiable], **data: Dict[str, Any]\n    ) -&gt; DataModel:\n        \"\"\"\n        Method to create a data model from a list of provided models.\n\n        Args:\n            models (Tuple[Identifiable]): The models to load into the data model.\n            data (Dict[str, Any]): The data to load into the data model.\n\n        Returns:\n            DataModel: The data model with loaded models\n        \"\"\"\n        data_model = cls(**data)\n        data_model.add(*models)\n        return data_model\n\n    @classmethod\n    def from_model_types(cls, *model_types: Tuple[Type[Identifiable]], **data: Dict[str, Any]) -&gt; DataModel:\n        \"\"\"\n        Method to create a data model a provided list of model types.\n\n        Args:\n            model_types (Tuple[Type[Identifiable]]): The model types to load into the data model.\n            data (Dict[str, Any]): The data to load into the data model.\n\n        Returns:\n            DataModel: The data model with loaded models\n        \"\"\"\n        data_model = cls(**data)\n        for model_type in model_types:\n            data_model.add_schema(model_type)\n        return data_model\n\n    @property\n    def model_ids(self) -&gt; Set[str]:\n        \"\"\"\n        Property to get the ids of all contained models.\n\n        Returns:\n            Set[str]: The set of ids.\n        \"\"\"\n        return set(str(key) for key in self._key_ids_models.keys())\n\n    def get_contained_ids(self) -&gt; Set[str]:\n        \"\"\"\n        Method to get all ids of contained models.\n\n        Returns:\n            Set[str]: The set of ids.\n        \"\"\"\n        return self.model_ids\n\n    def add(self, *models: Identifiable) -&gt; None:\n        \"\"\"\n        Method to add models to the data model.\n\n        Args:\n            *models (Tuple[Identifiable]): The models to load into the data model.\n        \"\"\"\n        for model in models:\n            self.add_model(model)\n\n    def add_schema(self, schema: Type[Identifiable]) -&gt; None:\n        \"\"\"\n        Method to add a schema of the data model.\n\n        Args:\n            schema (Type[Identifiable]): The schema to load.\n        \"\"\"\n        all_schemas, schema_reference_infos = ReferenceFinder.find_schema_references(schema)\n        self._add_contained_schemas(all_schemas)\n        self._add_top_level_schema(schema)\n        self._add_schema_references_to_referencing_schemas_dict(schema_reference_infos)\n\n    def add_model(self, model: Identifiable) -&gt; None:\n        \"\"\"\n        Method to load a model of the data model.\n\n        Args:\n            model (Identifiable): The model to load.\n        \"\"\"\n        # Identifiable.model_validate(model)\n        model_id = get_id_with_patch(model)\n        if model_id in self.model_ids:\n            raise ValueError(f\"Model with id {model_id} already loaded.\")\n        self.add_schema(type(model))\n        all_identifiables, reference_infos = ReferenceFinder.find(model)\n        self._add_contained_models(model, all_identifiables)\n        self._add_top_level_model(model)\n        self._add_references_to_referencing_models_dict(reference_infos)\n\n    def check_different_model_with_same_id_contained(self, model: Identifiable) -&gt; bool:\n        \"\"\"\n        Method to check if a model is already contained in the data model.\n\n        Args:\n            model (Identifiable): The model to check.\n\n        Returns:\n            bool: True if the model is already contained, False otherwise.\n        \"\"\"\n        model_id = get_id_with_patch(model)\n        if model_id in self.model_ids:\n            same_id_model = self.get_model(model_id)\n            if not same_id_model == model:\n                return True\n        return False\n\n    def _add_contained_models(\n        self, top_level_model: Identifiable, contained_models: List[Identifiable]\n    ) -&gt; None:\n        \"\"\"\n        Method to load all contained models of a model.\n\n        Args:\n            top_level_model (Identifiable): The top level model to load.\n            contained_models (List[Identifiable]): The contained models to load.\n        \"\"\"\n        for contained_model in contained_models:\n            contained_model_id = get_id_with_patch(contained_model)\n            if contained_model_id in self.model_ids:\n                same_id_model = self.get_model(contained_model_id)\n                if not models_are_equal(same_id_model, contained_model):\n                    raise ValueError(\n                        f\"Model with id {contained_model_id} already loaded but with different content. Make sure to only load models with unique ids.\"\n                    )\n                replace_attribute_with_model(top_level_model, same_id_model)\n                continue\n            self._add_model(contained_model)\n\n    def _add_contained_schemas(\n        self, contained_schemas: List[Type[Identifiable]]\n    ) -&gt; None:\n        \"\"\"\n        Method to load all contained schemas of a schema.\n\n        Args:\n            top_level_schema (Type[Identifiable]): The top level schema to load.\n            contained_schemas (List[Type[Identifiable]]): The contained schemas to load.\n        \"\"\"\n        for contained_schema in contained_schemas:\n            self._schemas[contained_schema.__name__] = contained_schema\n\n\n    def patch_schema_references(self) -&gt; None:\n        \"\"\"\n        Function tries to patch schema reference infos to represent a more realistic data model.\n\n        ReferenceInfos of Type Reference are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id.\n        ReferenceInfos of Type Attribute are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id.\n        \"\"\"\n        reference_infos = patch_references(self._schema_reference_infos, self._schemas.values())\n        self._schema_reference_infos = reference_infos\n        self._add_schema_references_to_referencing_schemas_dict(reference_infos)\n\n    def _add_references_to_referencing_models_dict(\n        self, reference_infos: Set[ReferenceInfo]\n    ) -&gt; None:\n        \"\"\"\n        Method to add information about referencing model ids of the input model.\n\n        Args:\n            model (Identifiable): The model to add the information for.\n        \"\"\"\n        self._reference_infos = self._reference_infos | reference_infos\n        for reference_info in reference_infos:\n            referencing_model_id = reference_info.identifiable_id\n            referenced_model_id = reference_info.reference_id\n            if not referencing_model_id in self._reference_info_dict_for_referencing:\n                self._reference_info_dict_for_referencing[referencing_model_id] = {}\n            self._reference_info_dict_for_referencing[referencing_model_id][\n                referenced_model_id\n            ] = reference_info\n            if not referenced_model_id in self._reference_info_dict_for_referenced:\n                self._reference_info_dict_for_referenced[referenced_model_id] = {}\n            self._reference_info_dict_for_referenced[referenced_model_id][\n                referencing_model_id\n            ] = reference_info\n\n    def _add_schema_references_to_referencing_schemas_dict(self, reference_infos: Set[ReferenceInfo]) -&gt; None:\n        \"\"\"\n        Method to add information about referencing schema ids of the input schema.\n\n        Args:\n            schema (Type[Identifiable]): The schema to add the information for.\n        \"\"\"\n        self._schema_reference_infos = self._schema_reference_infos | reference_infos\n        for reference_info in reference_infos:\n            referencing_schema_id = reference_info.identifiable_id\n            referenced_schema_id = reference_info.reference_id\n            if not referencing_schema_id in self._schema_reference_info_for_referencing:\n                self._schema_reference_info_for_referencing[referencing_schema_id] = {}\n            self._schema_reference_info_for_referencing[referencing_schema_id][\n                referenced_schema_id\n            ] = reference_info\n            if not referenced_schema_id in self._schema_reference_info_for_referenced:\n                self._schema_reference_info_for_referenced[referenced_schema_id] = {}\n            self._schema_reference_info_for_referenced[referenced_schema_id][\n                referencing_schema_id\n            ] = reference_info\n\n\n    def _add_model(self, model: Identifiable) -&gt; None:\n        \"\"\"\n        Method to add a model to the data model.\n\n        Args:\n            model (Identifiable): The model to add.\n        \"\"\"\n        model_id = get_id_with_patch(model)\n        if model_id in self.model_ids:\n            raise ValueError(f\"Model with id {model_id} already loaded.\")\n        self._key_ids_models[model_id] = model\n        type_name = model.__class__.__name__.split(\".\")[-1]\n        if not type_name in self._models_key_type:\n            self._models_key_type[type_name] = []\n        self._models_key_type[type_name].append(model_id)\n\n    def _add_top_level_model(self, model: Identifiable) -&gt; None:\n        \"\"\"\n        Method to add a model to the data model.\n\n        Args:\n            model (Identifiable): The model to add.\n        \"\"\"\n        type_name = model.__class__.__name__.split(\".\")[-1]\n        underscore_type_name = convert_camel_case_to_underscrore_str(type_name)\n        if not underscore_type_name in self._top_level_models:\n            self._top_level_models[underscore_type_name] = []\n        self._top_level_models[underscore_type_name].append(get_id_with_patch(model))\n\n    def _add_top_level_schema(self, schema: Type[Identifiable]) -&gt; None:\n        \"\"\"\n        Method to add a schema to the data model.\n\n        Args:\n            schema (Type[Identifiable]): The schema to add.\n        \"\"\"\n        schema_name = schema.__name__\n        if not schema_name in self._top_level_schemas:\n            self._top_level_schemas.add(schema_name)\n\n    def from_dict(self, data: NESTED_DICT, types: List[Type]) -&gt; None:\n        \"\"\"\n        Method to load a data model from a dict.\n\n        Args:\n            data (NESTED_DICT): The dict to load the data model from.\n        \"\"\"\n        for attribute_name, attribute_value in data.items():\n            class_name = convert_under_score_to_camel_case_str(attribute_name)\n            for type_ in types:\n                if type_.__name__ == class_name:\n                    type_for_attribute_values = type_\n                    break\n            else:\n                raise ValueError(f\"Type {class_name} not supported.\")\n            for model_dict in attribute_value:\n                model = type_for_attribute_values(**model_dict)\n                self.add(model)\n\n    def dict(self) -&gt; NESTED_DICT:\n        \"\"\"\n        Method to get the dict of the data model.\n\n        Returns:\n            NESTED_DICT: The dict of the data model.\n        \"\"\"\n        nested_dict = {}\n        for attribute_name, attribute_value in self.get_top_level_models().items():\n            nested_dict[attribute_name] = [\n                model.model_dump() for model in attribute_value\n            ]\n        return nested_dict\n\n    def json(self) -&gt; str:\n        \"\"\"\n        Method to get the json of the data model.\n\n        Returns:\n            str: The json of the data model.\n        \"\"\"\n        nested_dict = {}\n        for attribute_name, attribute_value in self.get_top_level_models().items():\n            # TODO: if a non-BaseModel object is loaded, this breakds down -&gt; adjust this\n            nested_dict[attribute_name] = [\n                model.model_dump() for model in attribute_value\n            ]\n        return json.dumps(nested_dict, indent=4, cls=DateTimeEncoder)\n\n    def get_top_level_models(self) -&gt; Dict[str, List[Identifiable]]:\n        \"\"\"\n        Method to get all models of the data model.\n\n        Returns:\n            Dict[str, List[Identifiable]]: The dictionary of models.\n        \"\"\"\n        top_level_models = {}\n        for top_level_model_name, top_level_model_ids in self._top_level_models.items():\n            top_level_models[top_level_model_name] = [\n                self.get_model(model_id) for model_id in top_level_model_ids\n            ]\n        return top_level_models\n\n    def get_top_level_types(self) -&gt; List[Type[Identifiable]]:\n        \"\"\"\n        Method to get all types of the top level models in the data model.\n\n        Returns:\n            List[Type[Identifiable]]: The types of the top level models in the data model\n        \"\"\"\n        top_level_types = []\n        for schema_name in self._top_level_schemas:\n            top_level_types.append(self._schemas[schema_name])\n        return top_level_types\n\n    def get_models_of_type_name(self, model_type_name: str) -&gt; List[Identifiable]:\n        \"\"\"\n        Method to get all models of a specific type.\n\n        Args:\n            model_type (str): The type of the models to get.\n\n        Returns:\n            List[Identifiable]: The list of models of the type.\n        \"\"\"\n        if not model_type_name in self._models_key_type:\n            raise ValueError(f\"Model type {model_type_name} not supported.\")\n        return [\n            self.get_model(model_id)\n            for model_id in self._models_key_type[model_type_name]\n        ]\n\n    def get_models_of_type(self, model_type: Type[T]) -&gt; List[T]:\n        \"\"\"\n        Method to get all models of a specific type.\n\n        Args:\n            model_type (Type[T]): The type of the models to get.\n\n        Returns:\n            List[T]: The list of models of the type.\n        \"\"\"\n        type_name = model_type.__name__.split(\".\")[-1]\n        return self.get_models_of_type_name(type_name)\n\n    def get_contained_models(self) -&gt; List[Identifiable]:\n        \"\"\"\n        Method to get all models that are contained in the data model.\n\n        Returns:\n            List[Identifiable]: The list of models.\n        \"\"\"\n        return list(self._key_ids_models.values())\n\n    def get_referencing_info(\n        self, referenced_model: Identifiable\n    ) -&gt; List[ReferenceInfo]:\n        \"\"\"\n        Method to get all reference infos of a model.\n\n        Args:\n            referenced_model (Identifiable): The model to get the reference infos for.\n\n        Returns:\n            List[ReferenceInfo]: The list of reference infos.\n        \"\"\"\n        referenced_model_id = get_id_with_patch(referenced_model)\n        if not referenced_model_id in self._reference_info_dict_for_referenced:\n            return []\n        return list(\n            self._reference_info_dict_for_referenced[referenced_model_id].values()\n        )\n\n    def get_referencing_models(\n        self, referenced_model: Identifiable\n    ) -&gt; List[Identifiable]:\n        \"\"\"\n        Method to get all models that reference a specific model directly as an attribute or by its id.\n\n        Args:\n            referenced_model (Identifiable): The model to get the referencing models for.\n\n        Returns:\n            List[Identifiable]: The list of referencing models of the model.\n        \"\"\"\n        referenced_model_id = get_id_with_patch(referenced_model)\n        if not referenced_model_id in self._reference_info_dict_for_referenced:\n            return []\n        referencing_model_dict = self._reference_info_dict_for_referenced[\n            referenced_model_id\n        ]\n        return [self.get_model(model_id) for model_id in referencing_model_dict]\n\n    def get_referencing_models_of_type(\n        self, referenced_model: Identifiable, referencing_model_type: Type[T]\n    ) -&gt; List[T]:\n        \"\"\"\n        Method to get all models that reference a specific model directly as an attribute or by its id.\n\n        Args:\n            referenced_model (Identifiable): The model to get the referencing models for.\n            referencing_model_type (Type[T]): The type of the referencing models to get.\n\n        Returns:\n            List[T]: The list of referencing models of the model.\n        \"\"\"\n        referenced_model_id = get_id_with_patch(referenced_model)\n        if not referenced_model_id in self._reference_info_dict_for_referenced:\n            return []\n        referencing_model_dict = self._reference_info_dict_for_referenced[\n            referenced_model_id\n        ]\n        return [\n            self.get_model(model_id)\n            for model_id in referencing_model_dict\n            if isinstance(self.get_model(model_id), referencing_model_type)\n        ]\n\n    def get_referenced_info(\n        self, referencing_model: Identifiable\n    ) -&gt; List[ReferenceInfo]:\n        \"\"\"\n        Method to get all reference infos of a model.\n\n        Args:\n            referencing_model (Identifiable): The model to get the reference infos for.\n\n        Returns:\n            List[ReferenceInfo]: The list of reference infos.\n        \"\"\"\n        referencing_model_id = get_id_with_patch(referencing_model)\n        if not referencing_model_id in self._reference_info_dict_for_referencing:\n            return []\n        return list(\n            self._reference_info_dict_for_referencing[referencing_model_id].values()\n        )\n\n    def get_referenced_models(\n        self, referencing_model: Identifiable\n    ) -&gt; List[Identifiable]:\n        \"\"\"\n        Method to get all models that are referenced by a specific model directly as an attribute or by its id.\n\n        Args:\n            referencing_model (Identifiable): The model to get the referenced models for.\n\n        Returns:\n            List[Identifiable]: The list of referenced models of the model.\n        \"\"\"\n        referencing_model_id = get_id_with_patch(referencing_model)\n        if not referencing_model_id in self._reference_info_dict_for_referencing:\n            return []\n        referenced_model_dict = self._reference_info_dict_for_referencing[\n            referencing_model_id\n        ]\n        return [self.get_model(model_id) for model_id in referenced_model_dict if model_id in self.model_ids]\n\n    def get_referenced_models_of_type(\n        self, referencing_model: Identifiable, referenced_model_type: Type[T]\n    ) -&gt; List[T]:\n        \"\"\"\n        Method to get all models that are referenced by a specific model directly as an attribute or by its id.\n\n        Args:\n            referencing_model (Identifiable): The model to get the referenced models for.\n            referenced_model_type (Type[T]): The type of the referenced models to get.\n\n        Returns:\n            List[T]: The list of referenced models of the model.\n        \"\"\"\n        referencing_model_id = get_id_with_patch(referencing_model)\n        if not referencing_model_id in self._reference_info_dict_for_referencing:\n            return []\n        referenced_model_dict = self._reference_info_dict_for_referencing[\n            referencing_model_id\n        ]\n        return [\n            self.get_model(model_id)\n            for model_id in referenced_model_dict\n            if isinstance(self.get_model(model_id), referenced_model_type)\n        ]\n\n    def get_model(self, model_id: str) -&gt; Identifiable:\n        \"\"\"\n        Method to get a model by its id.\n\n        Args:\n            model_id (str): The id of the model to get.\n\n        Returns:\n            Identifiable: The model.\n        \"\"\"\n        if model_id not in self.model_ids:\n            return None\n        return self._key_ids_models[model_id]\n\n    def contains_model(self, model_id: str) -&gt; bool:\n        \"\"\"\n        Method to check if a model is contained in the data model.\n\n        Args:\n            model_id (str): The id of the model to check.\n\n        Returns:\n            bool: True if the model is contained, False otherwise.\n        \"\"\"\n        if self.get_model(model_id) is not None:\n            return True\n        return False\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.model_ids","title":"<code>model_ids: Set[str]</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to get the ids of all contained models.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>The set of ids.</p>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.add","title":"<code>add(self, *models)</code>","text":"<p>Method to add models to the data model.</p> <p>Parameters:</p> Name Type Description Default <code>*models</code> <code>Tuple[Identifiable]</code> <p>The models to load into the data model.</p> <code>()</code> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def add(self, *models: Identifiable) -&gt; None:\n    \"\"\"\n    Method to add models to the data model.\n\n    Args:\n        *models (Tuple[Identifiable]): The models to load into the data model.\n    \"\"\"\n    for model in models:\n        self.add_model(model)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.add_model","title":"<code>add_model(self, model)</code>","text":"<p>Method to load a model of the data model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The model to load.</p> required Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def add_model(self, model: Identifiable) -&gt; None:\n    \"\"\"\n    Method to load a model of the data model.\n\n    Args:\n        model (Identifiable): The model to load.\n    \"\"\"\n    # Identifiable.model_validate(model)\n    model_id = get_id_with_patch(model)\n    if model_id in self.model_ids:\n        raise ValueError(f\"Model with id {model_id} already loaded.\")\n    self.add_schema(type(model))\n    all_identifiables, reference_infos = ReferenceFinder.find(model)\n    self._add_contained_models(model, all_identifiables)\n    self._add_top_level_model(model)\n    self._add_references_to_referencing_models_dict(reference_infos)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.add_schema","title":"<code>add_schema(self, schema)</code>","text":"<p>Method to add a schema of the data model.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Identifiable]</code> <p>The schema to load.</p> required Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def add_schema(self, schema: Type[Identifiable]) -&gt; None:\n    \"\"\"\n    Method to add a schema of the data model.\n\n    Args:\n        schema (Type[Identifiable]): The schema to load.\n    \"\"\"\n    all_schemas, schema_reference_infos = ReferenceFinder.find_schema_references(schema)\n    self._add_contained_schemas(all_schemas)\n    self._add_top_level_schema(schema)\n    self._add_schema_references_to_referencing_schemas_dict(schema_reference_infos)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.check_different_model_with_same_id_contained","title":"<code>check_different_model_with_same_id_contained(self, model)</code>","text":"<p>Method to check if a model is already contained in the data model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The model to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the model is already contained, False otherwise.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def check_different_model_with_same_id_contained(self, model: Identifiable) -&gt; bool:\n    \"\"\"\n    Method to check if a model is already contained in the data model.\n\n    Args:\n        model (Identifiable): The model to check.\n\n    Returns:\n        bool: True if the model is already contained, False otherwise.\n    \"\"\"\n    model_id = get_id_with_patch(model)\n    if model_id in self.model_ids:\n        same_id_model = self.get_model(model_id)\n        if not same_id_model == model:\n            return True\n    return False\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.contains_model","title":"<code>contains_model(self, model_id)</code>","text":"<p>Method to check if a model is contained in the data model.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>The id of the model to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the model is contained, False otherwise.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def contains_model(self, model_id: str) -&gt; bool:\n    \"\"\"\n    Method to check if a model is contained in the data model.\n\n    Args:\n        model_id (str): The id of the model to check.\n\n    Returns:\n        bool: True if the model is contained, False otherwise.\n    \"\"\"\n    if self.get_model(model_id) is not None:\n        return True\n    return False\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.dict","title":"<code>dict(self)</code>","text":"<p>Method to get the dict of the data model.</p> <p>Returns:</p> Type Description <code>NESTED_DICT</code> <p>The dict of the data model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def dict(self) -&gt; NESTED_DICT:\n    \"\"\"\n    Method to get the dict of the data model.\n\n    Returns:\n        NESTED_DICT: The dict of the data model.\n    \"\"\"\n    nested_dict = {}\n    for attribute_name, attribute_value in self.get_top_level_models().items():\n        nested_dict[attribute_name] = [\n            model.model_dump() for model in attribute_value\n        ]\n    return nested_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.from_dict","title":"<code>from_dict(self, data, types)</code>","text":"<p>Method to load a data model from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NESTED_DICT</code> <p>The dict to load the data model from.</p> required Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def from_dict(self, data: NESTED_DICT, types: List[Type]) -&gt; None:\n    \"\"\"\n    Method to load a data model from a dict.\n\n    Args:\n        data (NESTED_DICT): The dict to load the data model from.\n    \"\"\"\n    for attribute_name, attribute_value in data.items():\n        class_name = convert_under_score_to_camel_case_str(attribute_name)\n        for type_ in types:\n            if type_.__name__ == class_name:\n                type_for_attribute_values = type_\n                break\n        else:\n            raise ValueError(f\"Type {class_name} not supported.\")\n        for model_dict in attribute_value:\n            model = type_for_attribute_values(**model_dict)\n            self.add(model)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.from_model_types","title":"<code>from_model_types(*model_types, **data)</code>  <code>classmethod</code>","text":"<p>Method to create a data model a provided list of model types.</p> <p>Parameters:</p> Name Type Description Default <code>model_types</code> <code>Tuple[Type[Identifiable]]</code> <p>The model types to load into the data model.</p> <code>()</code> <code>data</code> <code>Dict[str, Any]</code> <p>The data to load into the data model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataModel</code> <p>The data model with loaded models</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>@classmethod\ndef from_model_types(cls, *model_types: Tuple[Type[Identifiable]], **data: Dict[str, Any]) -&gt; DataModel:\n    \"\"\"\n    Method to create a data model a provided list of model types.\n\n    Args:\n        model_types (Tuple[Type[Identifiable]]): The model types to load into the data model.\n        data (Dict[str, Any]): The data to load into the data model.\n\n    Returns:\n        DataModel: The data model with loaded models\n    \"\"\"\n    data_model = cls(**data)\n    for model_type in model_types:\n        data_model.add_schema(model_type)\n    return data_model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.from_models","title":"<code>from_models(*models, **data)</code>  <code>classmethod</code>","text":"<p>Method to create a data model from a list of provided models.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>Tuple[Identifiable]</code> <p>The models to load into the data model.</p> <code>()</code> <code>data</code> <code>Dict[str, Any]</code> <p>The data to load into the data model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataModel</code> <p>The data model with loaded models</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>@classmethod\ndef from_models(\n    cls, *models: Tuple[Identifiable], **data: Dict[str, Any]\n) -&gt; DataModel:\n    \"\"\"\n    Method to create a data model from a list of provided models.\n\n    Args:\n        models (Tuple[Identifiable]): The models to load into the data model.\n        data (Dict[str, Any]): The data to load into the data model.\n\n    Returns:\n        DataModel: The data model with loaded models\n    \"\"\"\n    data_model = cls(**data)\n    data_model.add(*models)\n    return data_model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_contained_ids","title":"<code>get_contained_ids(self)</code>","text":"<p>Method to get all ids of contained models.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>The set of ids.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_contained_ids(self) -&gt; Set[str]:\n    \"\"\"\n    Method to get all ids of contained models.\n\n    Returns:\n        Set[str]: The set of ids.\n    \"\"\"\n    return self.model_ids\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_contained_models","title":"<code>get_contained_models(self)</code>","text":"<p>Method to get all models that are contained in the data model.</p> <p>Returns:</p> Type Description <code>List[Identifiable]</code> <p>The list of models.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_contained_models(self) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to get all models that are contained in the data model.\n\n    Returns:\n        List[Identifiable]: The list of models.\n    \"\"\"\n    return list(self._key_ids_models.values())\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_model","title":"<code>get_model(self, model_id)</code>","text":"<p>Method to get a model by its id.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>The id of the model to get.</p> required <p>Returns:</p> Type Description <code>Identifiable</code> <p>The model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_model(self, model_id: str) -&gt; Identifiable:\n    \"\"\"\n    Method to get a model by its id.\n\n    Args:\n        model_id (str): The id of the model to get.\n\n    Returns:\n        Identifiable: The model.\n    \"\"\"\n    if model_id not in self.model_ids:\n        return None\n    return self._key_ids_models[model_id]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_models_of_type","title":"<code>get_models_of_type(self, model_type)</code>","text":"<p>Method to get all models of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T]</code> <p>The type of the models to get.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>The list of models of the type.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_models_of_type(self, model_type: Type[T]) -&gt; List[T]:\n    \"\"\"\n    Method to get all models of a specific type.\n\n    Args:\n        model_type (Type[T]): The type of the models to get.\n\n    Returns:\n        List[T]: The list of models of the type.\n    \"\"\"\n    type_name = model_type.__name__.split(\".\")[-1]\n    return self.get_models_of_type_name(type_name)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_models_of_type_name","title":"<code>get_models_of_type_name(self, model_type_name)</code>","text":"<p>Method to get all models of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>The type of the models to get.</p> required <p>Returns:</p> Type Description <code>List[Identifiable]</code> <p>The list of models of the type.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_models_of_type_name(self, model_type_name: str) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to get all models of a specific type.\n\n    Args:\n        model_type (str): The type of the models to get.\n\n    Returns:\n        List[Identifiable]: The list of models of the type.\n    \"\"\"\n    if not model_type_name in self._models_key_type:\n        raise ValueError(f\"Model type {model_type_name} not supported.\")\n    return [\n        self.get_model(model_id)\n        for model_id in self._models_key_type[model_type_name]\n    ]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referenced_info","title":"<code>get_referenced_info(self, referencing_model)</code>","text":"<p>Method to get all reference infos of a model.</p> <p>Parameters:</p> Name Type Description Default <code>referencing_model</code> <code>Identifiable</code> <p>The model to get the reference infos for.</p> required <p>Returns:</p> Type Description <code>List[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referenced_info(\n    self, referencing_model: Identifiable\n) -&gt; List[ReferenceInfo]:\n    \"\"\"\n    Method to get all reference infos of a model.\n\n    Args:\n        referencing_model (Identifiable): The model to get the reference infos for.\n\n    Returns:\n        List[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    referencing_model_id = get_id_with_patch(referencing_model)\n    if not referencing_model_id in self._reference_info_dict_for_referencing:\n        return []\n    return list(\n        self._reference_info_dict_for_referencing[referencing_model_id].values()\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referenced_models","title":"<code>get_referenced_models(self, referencing_model)</code>","text":"<p>Method to get all models that are referenced by a specific model directly as an attribute or by its id.</p> <p>Parameters:</p> Name Type Description Default <code>referencing_model</code> <code>Identifiable</code> <p>The model to get the referenced models for.</p> required <p>Returns:</p> Type Description <code>List[Identifiable]</code> <p>The list of referenced models of the model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referenced_models(\n    self, referencing_model: Identifiable\n) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to get all models that are referenced by a specific model directly as an attribute or by its id.\n\n    Args:\n        referencing_model (Identifiable): The model to get the referenced models for.\n\n    Returns:\n        List[Identifiable]: The list of referenced models of the model.\n    \"\"\"\n    referencing_model_id = get_id_with_patch(referencing_model)\n    if not referencing_model_id in self._reference_info_dict_for_referencing:\n        return []\n    referenced_model_dict = self._reference_info_dict_for_referencing[\n        referencing_model_id\n    ]\n    return [self.get_model(model_id) for model_id in referenced_model_dict if model_id in self.model_ids]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referenced_models_of_type","title":"<code>get_referenced_models_of_type(self, referencing_model, referenced_model_type)</code>","text":"<p>Method to get all models that are referenced by a specific model directly as an attribute or by its id.</p> <p>Parameters:</p> Name Type Description Default <code>referencing_model</code> <code>Identifiable</code> <p>The model to get the referenced models for.</p> required <code>referenced_model_type</code> <code>Type[T]</code> <p>The type of the referenced models to get.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>The list of referenced models of the model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referenced_models_of_type(\n    self, referencing_model: Identifiable, referenced_model_type: Type[T]\n) -&gt; List[T]:\n    \"\"\"\n    Method to get all models that are referenced by a specific model directly as an attribute or by its id.\n\n    Args:\n        referencing_model (Identifiable): The model to get the referenced models for.\n        referenced_model_type (Type[T]): The type of the referenced models to get.\n\n    Returns:\n        List[T]: The list of referenced models of the model.\n    \"\"\"\n    referencing_model_id = get_id_with_patch(referencing_model)\n    if not referencing_model_id in self._reference_info_dict_for_referencing:\n        return []\n    referenced_model_dict = self._reference_info_dict_for_referencing[\n        referencing_model_id\n    ]\n    return [\n        self.get_model(model_id)\n        for model_id in referenced_model_dict\n        if isinstance(self.get_model(model_id), referenced_model_type)\n    ]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referencing_info","title":"<code>get_referencing_info(self, referenced_model)</code>","text":"<p>Method to get all reference infos of a model.</p> <p>Parameters:</p> Name Type Description Default <code>referenced_model</code> <code>Identifiable</code> <p>The model to get the reference infos for.</p> required <p>Returns:</p> Type Description <code>List[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referencing_info(\n    self, referenced_model: Identifiable\n) -&gt; List[ReferenceInfo]:\n    \"\"\"\n    Method to get all reference infos of a model.\n\n    Args:\n        referenced_model (Identifiable): The model to get the reference infos for.\n\n    Returns:\n        List[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    referenced_model_id = get_id_with_patch(referenced_model)\n    if not referenced_model_id in self._reference_info_dict_for_referenced:\n        return []\n    return list(\n        self._reference_info_dict_for_referenced[referenced_model_id].values()\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referencing_models","title":"<code>get_referencing_models(self, referenced_model)</code>","text":"<p>Method to get all models that reference a specific model directly as an attribute or by its id.</p> <p>Parameters:</p> Name Type Description Default <code>referenced_model</code> <code>Identifiable</code> <p>The model to get the referencing models for.</p> required <p>Returns:</p> Type Description <code>List[Identifiable]</code> <p>The list of referencing models of the model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referencing_models(\n    self, referenced_model: Identifiable\n) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to get all models that reference a specific model directly as an attribute or by its id.\n\n    Args:\n        referenced_model (Identifiable): The model to get the referencing models for.\n\n    Returns:\n        List[Identifiable]: The list of referencing models of the model.\n    \"\"\"\n    referenced_model_id = get_id_with_patch(referenced_model)\n    if not referenced_model_id in self._reference_info_dict_for_referenced:\n        return []\n    referencing_model_dict = self._reference_info_dict_for_referenced[\n        referenced_model_id\n    ]\n    return [self.get_model(model_id) for model_id in referencing_model_dict]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_referencing_models_of_type","title":"<code>get_referencing_models_of_type(self, referenced_model, referencing_model_type)</code>","text":"<p>Method to get all models that reference a specific model directly as an attribute or by its id.</p> <p>Parameters:</p> Name Type Description Default <code>referenced_model</code> <code>Identifiable</code> <p>The model to get the referencing models for.</p> required <code>referencing_model_type</code> <code>Type[T]</code> <p>The type of the referencing models to get.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>The list of referencing models of the model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_referencing_models_of_type(\n    self, referenced_model: Identifiable, referencing_model_type: Type[T]\n) -&gt; List[T]:\n    \"\"\"\n    Method to get all models that reference a specific model directly as an attribute or by its id.\n\n    Args:\n        referenced_model (Identifiable): The model to get the referencing models for.\n        referencing_model_type (Type[T]): The type of the referencing models to get.\n\n    Returns:\n        List[T]: The list of referencing models of the model.\n    \"\"\"\n    referenced_model_id = get_id_with_patch(referenced_model)\n    if not referenced_model_id in self._reference_info_dict_for_referenced:\n        return []\n    referencing_model_dict = self._reference_info_dict_for_referenced[\n        referenced_model_id\n    ]\n    return [\n        self.get_model(model_id)\n        for model_id in referencing_model_dict\n        if isinstance(self.get_model(model_id), referencing_model_type)\n    ]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_top_level_models","title":"<code>get_top_level_models(self)</code>","text":"<p>Method to get all models of the data model.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Identifiable]]</code> <p>The dictionary of models.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_top_level_models(self) -&gt; Dict[str, List[Identifiable]]:\n    \"\"\"\n    Method to get all models of the data model.\n\n    Returns:\n        Dict[str, List[Identifiable]]: The dictionary of models.\n    \"\"\"\n    top_level_models = {}\n    for top_level_model_name, top_level_model_ids in self._top_level_models.items():\n        top_level_models[top_level_model_name] = [\n            self.get_model(model_id) for model_id in top_level_model_ids\n        ]\n    return top_level_models\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.get_top_level_types","title":"<code>get_top_level_types(self)</code>","text":"<p>Method to get all types of the top level models in the data model.</p> <p>Returns:</p> Type Description <code>List[Type[Identifiable]]</code> <p>The types of the top level models in the data model</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def get_top_level_types(self) -&gt; List[Type[Identifiable]]:\n    \"\"\"\n    Method to get all types of the top level models in the data model.\n\n    Returns:\n        List[Type[Identifiable]]: The types of the top level models in the data model\n    \"\"\"\n    top_level_types = []\n    for schema_name in self._top_level_schemas:\n        top_level_types.append(self._schemas[schema_name])\n    return top_level_types\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.json","title":"<code>json(self)</code>","text":"<p>Method to get the json of the data model.</p> <p>Returns:</p> Type Description <code>str</code> <p>The json of the data model.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"\n    Method to get the json of the data model.\n\n    Returns:\n        str: The json of the data model.\n    \"\"\"\n    nested_dict = {}\n    for attribute_name, attribute_value in self.get_top_level_models().items():\n        # TODO: if a non-BaseModel object is loaded, this breakds down -&gt; adjust this\n        nested_dict[attribute_name] = [\n            model.model_dump() for model in attribute_value\n        ]\n    return json.dumps(nested_dict, indent=4, cls=DateTimeEncoder)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.model_post_init","title":"<code>model_post_init(/, self, context)</code>","text":"<p>This function is meant to behave like a BaseModel method to initialise private attributes.</p> <p>It takes context as an argument since that's what pydantic-core passes when calling it.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>BaseModel</code> <p>The BaseModel instance.</p> required <code>context</code> <code>Any</code> <p>The context.</p> required Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def init_private_attributes(self: BaseModel, context: Any, /) -&gt; None:\n    \"\"\"This function is meant to behave like a BaseModel method to initialise private attributes.\n\n    It takes context as an argument since that's what pydantic-core passes when calling it.\n\n    Args:\n        self: The BaseModel instance.\n        context: The context.\n    \"\"\"\n    if getattr(self, '__pydantic_private__', None) is None:\n        pydantic_private = {}\n        for name, private_attr in self.__private_attributes__.items():\n            default = private_attr.get_default()\n            if default is not PydanticUndefined:\n                pydantic_private[name] = default\n        object_setattr(self, '__pydantic_private__', pydantic_private)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DataModel.patch_schema_references","title":"<code>patch_schema_references(self)</code>","text":"<p>Function tries to patch schema reference infos to represent a more realistic data model.</p> <p>ReferenceInfos of Type Reference are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id. ReferenceInfos of Type Attribute are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id.</p> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def patch_schema_references(self) -&gt; None:\n    \"\"\"\n    Function tries to patch schema reference infos to represent a more realistic data model.\n\n    ReferenceInfos of Type Reference are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id.\n    ReferenceInfos of Type Attribute are patched so that another ReferenceInfo is added to every schema that has a class name that contains the reference id.\n    \"\"\"\n    reference_infos = patch_references(self._schema_reference_infos, self._schemas.values())\n    self._schema_reference_infos = reference_infos\n    self._add_schema_references_to_referencing_schemas_dict(reference_infos)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DateTimeEncoder","title":"<code> DateTimeEncoder            (JSONEncoder)         </code>","text":"Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>class DateTimeEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, datetime):\n            return o.isoformat()\n\n        return super().default(o)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model.DateTimeEncoder.default","title":"<code>default(self, o)</code>","text":"<p>Implement this method in a subclass such that it returns a serializable object for <code>o</code>, or calls the base implementation (to raise a <code>TypeError</code>).</p> <p>For example, to support arbitrary iterators, you could implement default like this::</p> <pre><code>def default(self, o):\n    !!! try\n        iterable = iter(o)\n    except TypeError:\n        pass\n    !!! else\n        return list(iterable)\n    # Let the base class default method raise the TypeError\n    return JSONEncoder.default(self, o)\n</code></pre> Source code in <code>aas_middleware\\model\\data_model.py</code> <pre><code>def default(self, o):\n    if isinstance(o, datetime):\n        return o.isoformat()\n\n    return super().default(o)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder","title":"<code>data_model_rebuilder</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.DataModelRebuilder","title":"<code> DataModelRebuilder        </code>","text":"Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>class DataModelRebuilder:\n    def __init__(self, data_model: DataModel):\n        \"\"\"\n        Rebuilds a data model with either direct or indirect references.\n\n        Args:\n            data_model (DataModel): The data model to rebuild.\n        \"\"\"\n        self.data_model = data_model\n\n    def rebuild_data_model_with_associations(self) -&gt; DataModel:\n        \"\"\"\n        Rebuilds all models in the data model with assosiations.\n\n        Returns:\n            DataModel: The rebuilt data model.\n        \"\"\"\n        raise NotImplementedError\n\n    def rebuild_data_model_for_AAS_structure(self) -&gt; DataModel:\n        \"\"\"\n        Rebuilds the data model for AAS meta model structure by adjusting the associations and references and infering correct AAS types.\n\n        Returns:\n            DataModel: The rebuilt data model.\n        \"\"\"\n        aas_candidates = []\n        submodel_candidates = []\n        top_level_models_list = []\n        for models in self.data_model.get_top_level_models().values():\n            top_level_models_list += models\n\n        for model in top_level_models_list:\n            if isinstance(model, aas_model.AAS):\n                aas_candidates.append(model)\n                continue\n            if any(\n                reference_info.reference_type == ReferenceType.ASSOCIATION\n                for reference_info in self.data_model.get_referencing_info(model)\n            ):\n                continue\n            if not all(\n                is_identifiable(attribute_value)\n                for attribute_value in get_value_attributes(model).values()\n            ):\n                continue\n            aas_candidates.append(model)\n\n        for model in top_level_models_list:\n            if model in aas_candidates:\n                continue\n            submodel_candidates.append(model)\n\n        submodel_objects = []\n        for submodel_candidate in submodel_candidates:\n            # TODO: remove the need to patch models that are already subclasses of submodel...\n            patched_submodel_object = get_patched_aas_object(\n                submodel_candidate, patch_type=aas_model.Submodel\n            )\n            submodel_objects.append(patched_submodel_object)\n\n        aas_objects = []\n        for aas_candidate in aas_candidates:\n            # TODO: remove the need to patch models that are already subclasses of aas...\n            patched_aas_object = get_patched_aas_object(\n                aas_candidate, patch_type=aas_model.AAS\n            )\n            aas_objects.append(patched_aas_object)\n\n        aas_data_model = DataModel.from_models(*aas_objects + submodel_objects)\n        return aas_data_model\n\n    def rebuild_data_model_with_references(self) -&gt; DataModel:\n        \"\"\"\n        Rebuilds all models in the data model with references.\n\n        Returns:\n            DataModel: The rebuilt data model.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.DataModelRebuilder.__init__","title":"<code>__init__(self, data_model)</code>  <code>special</code>","text":"<p>Rebuilds a data model with either direct or indirect references.</p> <p>Parameters:</p> Name Type Description Default <code>data_model</code> <code>DataModel</code> <p>The data model to rebuild.</p> required Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>def __init__(self, data_model: DataModel):\n    \"\"\"\n    Rebuilds a data model with either direct or indirect references.\n\n    Args:\n        data_model (DataModel): The data model to rebuild.\n    \"\"\"\n    self.data_model = data_model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.DataModelRebuilder.rebuild_data_model_for_AAS_structure","title":"<code>rebuild_data_model_for_AAS_structure(self)</code>","text":"<p>Rebuilds the data model for AAS meta model structure by adjusting the associations and references and infering correct AAS types.</p> <p>Returns:</p> Type Description <code>DataModel</code> <p>The rebuilt data model.</p> Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>def rebuild_data_model_for_AAS_structure(self) -&gt; DataModel:\n    \"\"\"\n    Rebuilds the data model for AAS meta model structure by adjusting the associations and references and infering correct AAS types.\n\n    Returns:\n        DataModel: The rebuilt data model.\n    \"\"\"\n    aas_candidates = []\n    submodel_candidates = []\n    top_level_models_list = []\n    for models in self.data_model.get_top_level_models().values():\n        top_level_models_list += models\n\n    for model in top_level_models_list:\n        if isinstance(model, aas_model.AAS):\n            aas_candidates.append(model)\n            continue\n        if any(\n            reference_info.reference_type == ReferenceType.ASSOCIATION\n            for reference_info in self.data_model.get_referencing_info(model)\n        ):\n            continue\n        if not all(\n            is_identifiable(attribute_value)\n            for attribute_value in get_value_attributes(model).values()\n        ):\n            continue\n        aas_candidates.append(model)\n\n    for model in top_level_models_list:\n        if model in aas_candidates:\n            continue\n        submodel_candidates.append(model)\n\n    submodel_objects = []\n    for submodel_candidate in submodel_candidates:\n        # TODO: remove the need to patch models that are already subclasses of submodel...\n        patched_submodel_object = get_patched_aas_object(\n            submodel_candidate, patch_type=aas_model.Submodel\n        )\n        submodel_objects.append(patched_submodel_object)\n\n    aas_objects = []\n    for aas_candidate in aas_candidates:\n        # TODO: remove the need to patch models that are already subclasses of aas...\n        patched_aas_object = get_patched_aas_object(\n            aas_candidate, patch_type=aas_model.AAS\n        )\n        aas_objects.append(patched_aas_object)\n\n    aas_data_model = DataModel.from_models(*aas_objects + submodel_objects)\n    return aas_data_model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.DataModelRebuilder.rebuild_data_model_with_associations","title":"<code>rebuild_data_model_with_associations(self)</code>","text":"<p>Rebuilds all models in the data model with assosiations.</p> <p>Returns:</p> Type Description <code>DataModel</code> <p>The rebuilt data model.</p> Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>def rebuild_data_model_with_associations(self) -&gt; DataModel:\n    \"\"\"\n    Rebuilds all models in the data model with assosiations.\n\n    Returns:\n        DataModel: The rebuilt data model.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.DataModelRebuilder.rebuild_data_model_with_references","title":"<code>rebuild_data_model_with_references(self)</code>","text":"<p>Rebuilds all models in the data model with references.</p> <p>Returns:</p> Type Description <code>DataModel</code> <p>The rebuilt data model.</p> Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>def rebuild_data_model_with_references(self) -&gt; DataModel:\n    \"\"\"\n    Rebuilds all models in the data model with references.\n\n    Returns:\n        DataModel: The rebuilt data model.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.data_model_rebuilder.get_patched_aas_object","title":"<code>get_patched_aas_object(model, patch_type)</code>","text":"<p>Rebuilds an Identifiable object to an AAS object.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The object to rebuild.</p> required <p>Returns:</p> Type Description <code>aas_model.AAS</code> <p>The rebuilt AAS object.</p> Source code in <code>aas_middleware\\model\\data_model_rebuilder.py</code> <pre><code>def get_patched_aas_object(model: Any, patch_type: Type[T]) -&gt; T:\n    \"\"\"\n    Rebuilds an Identifiable object to an AAS object.\n\n    Args:\n        model (object): The object to rebuild.\n\n    Returns:\n        aas_model.AAS: The rebuilt AAS object.\n    \"\"\"\n    model_id = get_id_with_patch(model)\n    dict_dynamic_model_creation = {}\n    dict_model_instantiation = {}\n    dict_model_instantiation[\"id_short\"] = model_id\n    if not patch_type == aas_model.SubmodelElementCollection:\n        dict_model_instantiation[\"id\"] = model_id\n\n    for attribute_name, attribute_value in get_value_attributes(model).items():\n        below_patch_type = get_below_patch_type(patch_type)\n\n        if is_identifiable(attribute_value):\n            patched_attribute_value = get_patched_aas_object(\n                attribute_value, patch_type=below_patch_type\n            )\n        elif is_identifiable_container(attribute_value):\n            patched_attribute_value = []\n            for element in attribute_value:\n                patched_element = get_patched_aas_object(\n                    element, patch_type=below_patch_type\n                )\n                patched_attribute_value.append(patched_element)\n        else:\n            patched_attribute_value = attribute_value\n\n        attribute_patch_type = get_patched_type(model, attribute_name, patched_attribute_value)\n\n        dict_dynamic_model_creation.update(\n            {\n                attribute_name: (\n                    attribute_patch_type,\n                    Field(examples=[patched_attribute_value]),\n                )\n            }\n        )\n        dict_model_instantiation.update({attribute_name: patched_attribute_value})\n    new_model_type = create_model(\n        model.__class__.__name__, **dict_dynamic_model_creation, __base__=patch_type\n    )\n    return new_model_type.model_validate(dict_model_instantiation)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting","title":"<code>formatting</code>  <code>special</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas","title":"<code>aas</code>  <code>special</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_json_formatter","title":"<code>aas_json_formatter</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_json_formatter.AasJsonFormatter","title":"<code> AasJsonFormatter        </code>","text":"<p>Allows to serialize and deserialize Basyx AAS objects (AssetAdministrationShells, Submodels or Containers of both) to a DataModel.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_json_formatter.py</code> <pre><code>class AasJsonFormatter:\n    \"\"\"\n    Allows to serialize and deserialize Basyx AAS objects (AssetAdministrationShells, Submodels or Containers of both) to a DataModel.\n    \"\"\"\n\n    def serialize(self, data: DataModel) -&gt; Dict[Literal[\"assetAdministrationShells\", \"submodels\"], List[str]]:\n        \"\"\"\n        Serialize a DataModel object to the specific format of the formatter.\n\n        Args:\n            data (DataModel): A data model\n\n        Returns:\n            Objectstore: the basyx object store contain all AAS elements\n        \"\"\"\n        basyx_dict_obj_store = BasyxFormatter().serialize(data)\n        return json.loads(basyx.aas.adapter.json.object_store_to_json(basyx_dict_obj_store))\n\n\n    def deserialize(self, data: str) -&gt; DataModel:\n        \"\"\"\n        Deserialize the specific format of the formater to a DataModel object.\n\n        Args:\n            data (Any): The specific format of the formatter.\n\n        Returns:\n            DataModel: A data model that holds the objects that were deserialized\n        \"\"\"\n        submodel_and_aas = json.loads(data, cls=basyx.aas.adapter.json.AASFromJsonDecoder)\n        return BasyxFormatter().deserialize(submodel_and_aas)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_json_formatter.AasJsonFormatter.deserialize","title":"<code>deserialize(self, data)</code>","text":"<p>Deserialize the specific format of the formater to a DataModel object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The specific format of the formatter.</p> required <p>Returns:</p> Type Description <code>DataModel</code> <p>A data model that holds the objects that were deserialized</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_json_formatter.py</code> <pre><code>def deserialize(self, data: str) -&gt; DataModel:\n    \"\"\"\n    Deserialize the specific format of the formater to a DataModel object.\n\n    Args:\n        data (Any): The specific format of the formatter.\n\n    Returns:\n        DataModel: A data model that holds the objects that were deserialized\n    \"\"\"\n    submodel_and_aas = json.loads(data, cls=basyx.aas.adapter.json.AASFromJsonDecoder)\n    return BasyxFormatter().deserialize(submodel_and_aas)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_json_formatter.AasJsonFormatter.serialize","title":"<code>serialize(self, data)</code>","text":"<p>Serialize a DataModel object to the specific format of the formatter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataModel</code> <p>A data model</p> required <p>Returns:</p> Type Description <code>Objectstore</code> <p>the basyx object store contain all AAS elements</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_json_formatter.py</code> <pre><code>def serialize(self, data: DataModel) -&gt; Dict[Literal[\"assetAdministrationShells\", \"submodels\"], List[str]]:\n    \"\"\"\n    Serialize a DataModel object to the specific format of the formatter.\n\n    Args:\n        data (DataModel): A data model\n\n    Returns:\n        Objectstore: the basyx object store contain all AAS elements\n    \"\"\"\n    basyx_dict_obj_store = BasyxFormatter().serialize(data)\n    return json.loads(basyx.aas.adapter.json.object_store_to_json(basyx_dict_obj_store))\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util","title":"<code>aas_middleware_util</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.convert_under_score_to_camel_case_str","title":"<code>convert_under_score_to_camel_case_str(underscore_str)</code>","text":"<p>Convert a underscore seperated string to a camel case string.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The underscore seperated string to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The camel case string.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def convert_under_score_to_camel_case_str(underscore_str: str) -&gt; str:\n    \"\"\"\n    Convert a underscore seperated string to a camel case string.\n\n    Args:\n        class_name (str): The underscore seperated string to convert.\n\n    Returns:\n        str: The camel case string.\n    \"\"\"\n    words = underscore_str.split(\"_\")\n    camel_case_str = \"\".join(word.title() for word in words)\n    return camel_case_str\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.core_model_check","title":"<code>core_model_check(fieldinfo)</code>","text":"<p>Checks if a pydantic model field is a core model.</p> <p>Parameters:</p> Name Type Description Default <code>fieldinfo</code> <code>FieldInfo</code> <p>Pydantic model field.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the model field is a core model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def core_model_check(fieldinfo: FieldInfo) -&gt; bool:\n    \"\"\"\n    Checks if a pydantic model field is a core model.\n\n    Args:\n        fieldinfo (FieldInfo): Pydantic model field.\n\n    Returns:\n        bool: If the model field is a core model.\n    \"\"\"\n    if isinstance(fieldinfo.default, BaseModel):\n        return True\n    if typing.get_origin(fieldinfo.annotation) is typing.Union:\n        args = typing.get_args(fieldinfo.annotation)\n        if all(issubclass(arg, BaseModel) for arg in args):\n            return True\n    else:\n        if issubclass(fieldinfo.annotation, BaseModel):\n            return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_all_submodel_elements_from_submodel","title":"<code>get_all_submodel_elements_from_submodel(model)</code>","text":"<p>Function to get all submodel elements from a pydantic submodel</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The pydantic submodel to get the submodel elements from</p> required <p>Returns:</p> Type Description <code>List[aas_model.SubmodelElementCollection | list | str | bool | float | int]</code> <p>A list of all submodel elements in the pydantic submodel</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_all_submodel_elements_from_submodel(\n    model: Type[aas_model.Submodel],\n) -&gt; Dict[\n    str, Type[aas_model.SubmodelElementCollection | list | str | bool | float | int]\n]:\n    \"\"\"\n    Function to get all submodel elements from a pydantic submodel\n\n    Args:\n        model (Type[BaseModel]): The pydantic submodel to get the submodel elements from\n\n    Returns:\n        List[aas_model.SubmodelElementCollection | list | str | bool | float | int]: A list of all submodel elements in the pydantic submodel\n    \"\"\"\n    submodel_elements = {}\n    for field_name, field_info in model.model_fields.items():\n        if (\n            field_name != \"description\"\n            and field_name != \"id_short\"\n            and field_name != \"semantic_id\"\n            and field_name != \"id\"\n        ):\n            submodel_elements[field_info.alias] = field_info.annotation\n    return submodel_elements\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_all_submodels_from_object_store","title":"<code>get_all_submodels_from_object_store(obj_store)</code>","text":"<p>Function to get all basyx submodels from an object store</p> <p>Parameters:</p> Name Type Description Default <code>obj_store</code> <code>model.DictObjectStore</code> <p>Object store to get submodels from</p> required <p>Returns:</p> Type Description <code>List[model.Submodel]</code> <p>List of basyx submodels</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_all_submodels_from_object_store(\n    obj_store: model.DictObjectStore,\n) -&gt; List[model.Submodel]:\n    \"\"\"\n    Function to get all basyx submodels from an object store\n    Args:\n        obj_store (model.DictObjectStore): Object store to get submodels from\n    Returns:\n        List[model.Submodel]: List of basyx submodels\n    \"\"\"\n    submodels = []\n    for item in obj_store:\n        if isinstance(item, model.Submodel):\n            submodels.append(item)\n    return submodels\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_contained_models_attribute_info","title":"<code>get_contained_models_attribute_info(model)</code>","text":"<p>Function to get all submodels from a pydantic model</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>The pydantic model to get the submodels from</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, Type[aas_model.Submodel]]]</code> <p>List of attribute name and value of all submodels in the pydantic model</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_contained_models_attribute_info(\n    model: Type[BaseModel],\n) -&gt; List[Tuple[str, Type[aas_model.Submodel]]]:\n    \"\"\"\n    Function to get all submodels from a pydantic model\n    Args:\n        model (Type[BaseModel]): The pydantic model to get the submodels from\n    Returns:\n        List[Tuple[str, Type[aas_model.Submodel]]]: List of attribute name and value of all submodels in the pydantic model\n    \"\"\"\n    submodels = []\n    for attribute_name, fieldinfo in model.model_fields.items():\n        if typing.get_args(fieldinfo.annotation) != () and any(issubclass(arg, aas_model.Submodel) for arg in typing.get_args(fieldinfo.annotation)):\n            submodels.append((attribute_name, fieldinfo.annotation))\n        elif issubclass(fieldinfo.annotation, aas_model.Submodel):\n            submodels.append((attribute_name, fieldinfo.annotation))\n    return submodels\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_field_default_value","title":"<code>get_field_default_value(fieldinfo)</code>","text":"<p>Function to get the default values of a pydantic model field. If no default is given, the function tries to infer a default cored on the type.</p> <p>Parameters:</p> Name Type Description Default <code>fieldinfo</code> <code>FieldInfo</code> <p>Pydantic model field.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Missing default value.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_field_default_value(fieldinfo: FieldInfo) -&gt; typing.Any:\n    \"\"\"\n    Function to get the default values of a pydantic model field. If no default is given, the function tries to infer a default cored on the type.\n\n    Args:\n        fieldinfo (FieldInfo): Pydantic model field.\n\n    Returns:\n        typing.Any: Missing default value.\n    \"\"\"\n    if fieldinfo.default:\n        return fieldinfo.default\n    elif fieldinfo.default_factory:\n        return fieldinfo.default_factory()\n    elif fieldinfo.annotation == str:\n        return \"string\"\n    elif fieldinfo.annotation == bool:\n        return False\n    elif fieldinfo.annotation == int:\n        return 1\n    elif fieldinfo.annotation == float:\n        return 1.0\n    elif fieldinfo.annotation == list:\n        return []\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_pydantic_model_from_dict","title":"<code>get_pydantic_model_from_dict(dict_values, model_name, all_fields_required=False)</code>","text":"<p>Functions that creates pydantic model from dict.</p> <p>Parameters:</p> Name Type Description Default <code>dict_values</code> <code>dict</code> <p>Dictionary of values.</p> required <code>model_name</code> <code>str</code> <p>Name of the model.</p> required <code>all_fields_required</code> <code>bool</code> <p>If all fields should be required (non-Optional) in the model. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Pydantic model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_pydantic_model_from_dict(\n    dict_values: dict, model_name: str, all_fields_required: bool = False\n) -&gt; Type[BaseModel]:\n    \"\"\"\n    Functions that creates pydantic model from dict.\n\n    Args:\n        dict_values (dict): Dictionary of values.\n        model_name (str): Name of the model.\n        all_fields_required (bool, optional): If all fields should be required (non-Optional) in the model. Defaults to False.\n    Returns:\n        Type[BaseModel]: Pydantic model.\n    \"\"\"\n    # TODO: check function below if needed...\n    pydantic_model = recusrive_model_creation(model_name, dict_values)\n    pydantic_model = set_example_values(pydantic_model)\n    if all_fields_required:\n        for field_name, field_info in pydantic_model.model_fields.items():\n            field_info.default = None\n    return pydantic_model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.get_pydantic_models_from_instances","title":"<code>get_pydantic_models_from_instances(instances)</code>","text":"<p>Functions that creates pydantic models from instances.</p> <p>Parameters:</p> Name Type Description Default <code>instances</code> <code>List[BaseModel]</code> <p>List of pydantic model instances.</p> required <p>Returns:</p> Type Description <code>List[Type[BaseModel]]</code> <p>List of pydantic models.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def get_pydantic_models_from_instances(\n    instances: List[BaseModel],\n) -&gt; List[Type[BaseModel]]:\n    \"\"\"\n    Functions that creates pydantic models from instances.\n\n    Args:\n        instances (typing.List[BaseModel]): List of pydantic model instances.\n\n    Returns:\n        List[Type[BaseModel]]: List of pydantic models.\n    \"\"\"\n    # TODO: update method with pydantic v2 arguments of create_model\n    models = []\n    for instance in instances:\n        model_name = type(instance).__name__\n        pydantic_model = create_model(model_name, **vars(instance))\n        pydantic_model = set_example_values(pydantic_model)\n        pydantic_model = set_required_fields(pydantic_model, instance.__class__)\n        pydantic_model = set_default_values(pydantic_model, instance.__class__)\n        models.append(pydantic_model)\n    return models\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.recusrive_model_creation","title":"<code>recusrive_model_creation(model_name, dict_values, depth=0)</code>","text":"<p>Function that creates a pydantic model from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>_type_</code> <p>description</p> required <code>dict_values</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Type Description <code>_type_</code> <p>description</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def recusrive_model_creation(model_name, dict_values, depth=0):\n    \"\"\"\n    Function that creates a pydantic model from a dict.\n\n    Args:\n        model_name (_type_): _description_\n        dict_values (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # TODO: check function below if needed\n    for attribute_name, attribute_values in dict_values.items():\n        if isinstance(attribute_values, dict):\n            class_name = convert_under_score_to_camel_case_str(attribute_name)\n            created_model = recusrive_model_creation(\n                class_name, attribute_values, depth=depth + 1\n            )\n            dict_values[attribute_name] = created_model(**attribute_values)\n    if depth == 0:\n        core_class = aas_model.AAS\n    elif depth == 1:\n        core_class = aas_model.Submodel\n    else:\n        core_class = aas_model.SubmodelElementCollection\n    return create_model(model_name, **dict_values, __core__=core_class)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.save_model_list_with_schema","title":"<code>save_model_list_with_schema(model_list, path)</code>","text":"<p>Saves a list of pydantic models to a json file.</p> <p>Parameters:</p> Name Type Description Default <code>model_list</code> <code>List[aas_model.AAS]</code> <p>List of pydantic models</p> required <code>path</code> <code>str</code> <p>Path to the json file</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def save_model_list_with_schema(model_list: typing.List[BaseModel], path: str):\n    \"\"\"\n    Saves a list of pydantic models to a json file.\n    Args:\n        model_list (typing.List[aas_model.AAS]): List of pydantic models\n        path (str): Path to the json file\n    \"\"\"\n    save_dict = {\n        \"models\": [model.model_dump() for model in model_list],\n        \"schema\": [model.model_json_schema() for model in model_list],\n    }\n\n    with open(path, \"w\", encoding=\"utf-8\") as json_file:\n        json.dump(save_dict, json_file, indent=4)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.set_default_values","title":"<code>set_default_values(model, origin_model)</code>","text":"<p>Sets the default values and default factory of a pydantic model cored on a original model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>Pydantic model where default values should be removed.</p> required <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Pydantic model with the default values set.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def set_default_values(\n    model: Type[BaseModel], origin_model: Type[BaseModel]\n) -&gt; Type[BaseModel]:\n    \"\"\"\n    Sets the default values and default factory of a pydantic model cored on a original model.\n\n    Args:\n        model (Type[BaseModel]): Pydantic model where default values should be removed.\n\n    Returns:\n        Type[BaseModel]: Pydantic model with the default values set.\n    \"\"\"\n    # TODO: validate if this method is still needed in pydantic 2.0\n    for field_name, fieldinfo in origin_model.model_fields.items():\n        if union_type_field_check(fieldinfo):\n            original_sub_types = typing.get_args(fieldinfo.annotation)\n            model_sub_types = typing.get_args(model.model_fields[field_name].annotation)\n            new_types = []\n            for original_sub_type, model_sub_type in zip(\n                original_sub_types, model_sub_types\n            ):\n                new_type = set_default_values(model_sub_type, original_sub_type)\n                new_types.append(new_type)\n            model.model_fields[field_name].annotation = typing.Union[tuple(new_types)]\n        elif core_model_check(fieldinfo):\n            new_type = set_default_values(\n                model.model_fields[field_name].annotation, fieldinfo.annotation\n            )\n            model.model_fields[field_name].annotation = new_type\n        if not fieldinfo.is_required() and (\n            fieldinfo.default\n            or fieldinfo.default == \"\"\n            or fieldinfo.default == 0\n            or fieldinfo.default == 0.0\n            or fieldinfo.default == False\n            or fieldinfo.default == []\n            or fieldinfo.default == {}\n        ):\n            model.model_fields[field_name].default = fieldinfo.default\n        else:\n            model.model_fields[field_name].default = None\n\n        if not fieldinfo.is_required() and fieldinfo.default_factory:\n            model.model_fields[field_name].default_factory = fieldinfo.default_factory\n        else:\n            model.model_fields[field_name].default_factory = None\n    return model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.set_example_values","title":"<code>set_example_values(model)</code>","text":"<p>Sets the example values of a pydantic model cored on its default values.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>Pydantic model.</p> required <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Pydantic model with the example values set.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def set_example_values(model: Type[BaseModel]) -&gt; Type[BaseModel]:\n    \"\"\"\n    Sets the example values of a pydantic model cored on its default values.\n\n    Args:\n        model (Type[BaseModel]): Pydantic model.\n\n    Returns:\n        Type[BaseModel]: Pydantic model with the example values set.\n    \"\"\"\n    # TODO: potentially delete this method, since not required...\n    example_dict = {}\n    for field_name, fieldinfo in model.model_fields.items():\n        if issubclass(fieldinfo.annotation, BaseModel):\n            config_dict = ConfigDict(\n                json_schema_extra={\"examples\": [fieldinfo.default.model_dump_json()]}\n            )\n            fieldinfo.annotation.model_config = config_dict\n        example_dict[field_name] = get_field_default_value(fieldinfo)\n    serialized_example = model(**example_dict).model_dump_json()\n    config_dict = ConfigDict(json_schema_extra={\"examples\": [serialized_example]})\n    model.model_config = config_dict\n    return model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.set_required_fields","title":"<code>set_required_fields(model, origin_model)</code>","text":"<p>Sets the required fields of a pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[BaseModel]</code> <p>Pydantic model.</p> required <code>origin_model</code> <code>Type[BaseModel]</code> <p>Pydantic model from which the required fields should be copied.</p> required <p>Returns:</p> Type Description <code>Type[BaseModel]</code> <p>Pydantic model with the required fields set.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def set_required_fields(\n    model: Type[BaseModel], origin_model: Type[BaseModel]\n) -&gt; Type[BaseModel]:\n    \"\"\"\n    Sets the required fields of a pydantic model.\n\n    Args:\n        model (Type[BaseModel]): Pydantic model.\n        origin_model (Type[BaseModel]): Pydantic model from which the required fields should be copied.\n\n    Returns:\n        Type[BaseModel]: Pydantic model with the required fields set.\n    \"\"\"\n    # TODO: potentially delete this method, since not required in pydantic v2\n    for field_name, fieldinfo in origin_model.model_fields.items():\n        if union_type_field_check(fieldinfo):\n            original_sub_types = typing.get_args(fieldinfo.annotation)\n            model_sub_types = typing.get_args(model.model_fields[field_name].annotation)\n            new_types = []\n            for original_sub_type, model_sub_type in zip(\n                original_sub_types, model_sub_types\n            ):\n                new_type = set_required_fields(model_sub_type, original_sub_type)\n                new_types.append(new_type)\n            model.model_fields[field_name].annotation = typing.Union[tuple(new_types)]\n        elif core_model_check(fieldinfo):\n            new_type = set_required_fields(\n                model.model_fields[field_name].annotation, fieldinfo.annotation\n            )\n            model.model_fields[field_name].annotation = new_type\n        if fieldinfo.is_required():\n            model.model_fields[field_name].default = None\n            model.model_fields[field_name].default_factory = True\n    return model\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.union_type_check","title":"<code>union_type_check(model)</code>","text":"<p>Checks if a type is a union type.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type</code> <p>Type.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the type is a union type.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def union_type_check(model: Type) -&gt; bool:\n    \"\"\"\n    Checks if a type is a union type.\n\n    Args:\n        model (Type): Type.\n\n    Returns:\n        bool: If the type is a union type.\n    \"\"\"\n    if typing.get_origin(model) == typing.Union:\n        args = typing.get_args(model)\n        if all(issubclass(arg, BaseModel) for arg in args):\n            return True\n        else:\n            False\n    else:\n        return False\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_middleware_util.union_type_field_check","title":"<code>union_type_field_check(fieldinfo)</code>","text":"<p>Checks if a pydantic model field is a union type.</p> <p>Parameters:</p> Name Type Description Default <code>fieldinfo</code> <code>FieldInfo</code> <p>Pydantic model field.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the model field is a union type.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_middleware_util.py</code> <pre><code>def union_type_field_check(fieldinfo: FieldInfo) -&gt; bool:\n    \"\"\"\n    Checks if a pydantic model field is a union type.\n\n    Args:\n        fieldinfo (FieldInfo): Pydantic model field.\n\n    Returns:\n        bool: If the model field is a union type.\n    \"\"\"\n    return union_type_check(fieldinfo.annotation)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model","title":"<code>aas_model</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.AAS","title":"<code> AAS            (Identifiable)         </code>","text":"<p>Base class for all Asset Administration Shells (AAS).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Global id of the object.</p> required <code>id_short</code> <code>str</code> <p>Local id of the object.</p> required <code>description</code> <code>str</code> <p>Description of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class AAS(Identifiable):\n    \"\"\"\n    Base class for all Asset Administration Shells (AAS).\n\n    Args:\n        id (str): Global id of the object.\n        id_short (str): Local id of the object.\n        description (str, optional): Description of the object. Defaults to None.\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def set_optional_fields_to_None(cls, data):\n        if isinstance(data, BaseModel):\n            data = data.model_dump()\n        for field_name, field_info in cls.model_fields.items():\n            if field_name in data:\n                continue\n            if typing.get_origin(field_info.annotation) == Union and type(None) in typing.get_args(field_info.annotation):\n                data[field_name] = None\n        return data\n\n    @model_validator(mode=\"after\")\n    def check_submodels(self) -&gt; Self:\n        for field_name, field_info in self.model_fields.items():\n            if field_name in [\"id\", \"id_short\", \"description\"]:\n                continue\n            elif typing.get_origin(field_info.annotation) == Union and type(None) in typing.get_args(field_info.annotation) and getattr(self, field_name) is None:\n                continue\n            try:\n                Submodel.model_validate(getattr(self, field_name))\n            except ValidationError:\n                assert (\n                    False\n                ), f\"All attributes of an AAS must be of type Submodel or inherit from Submodel\"\n        return self\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.HasSemantics","title":"<code> HasSemantics            (BaseModel)         </code>","text":"<p>Base class for all classes that have semantics of the AAS meta model. Semantics are defined by a semantic id, which reference the semantic definition of the object.</p> <p>Parameters:</p> Name Type Description Default <code>semantic_id</code> <code>str</code> <p>Semantic id of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class HasSemantics(BaseModel):\n    \"\"\"\n    Base class for all classes that have semantics of the AAS meta model. Semantics are defined by a semantic id, which reference the semantic definition of the object.\n\n    Args:\n        semantic_id (str): Semantic id of the object. Defaults to None.\n    \"\"\"\n\n    semantic_id: str = \"\"\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.Identifiable","title":"<code> Identifiable            (Referable)         </code>","text":"<p>Base class for all identifiable classes in the AAS Meta model. An Identifiable is a Referable with a global id (id_).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Global id of the object.</p> required <code>id_short</code> <code>str</code> <p>Local id of the object.</p> required <code>description</code> <code>str</code> <p>Description of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class Identifiable(Referable):\n    \"\"\"\n    Base class for all identifiable classes in the AAS Meta model. An Identifiable is a Referable with a global id (id_).\n\n    Args:\n        id (str): Global id of the object.\n        id_short (str): Local id of the object.\n        description (str, optional): Description of the object. Defaults to None.\n    \"\"\"\n\n    id: AasIdString\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_id_and_id_short(cls, data: Any) -&gt; Any:\n        if isinstance(data, BaseModel):\n            data = data.model_dump()\n        elif not isinstance(data, dict):\n            data = {\n                \"id\": getattr(data, \"id\", \"\"),\n                \"id_short\": getattr(data, \"id_short\", \"\"),\n            }\n        assert \"id\" in data or \"id_short\" in data, \"Either id or id_short must be set\"\n        if \"id_short\" not in data:\n            data[\"id_short\"] = data[\"id\"]\n        if \"id\" not in data:\n            data[\"id\"] = data[\"id_short\"]\n        return data\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.Referable","title":"<code> Referable            (BaseModel)         </code>","text":"<p>Base class for all referable classes of the AAS meta model. A Referable is an object with a local id (id_short) and a description.</p> <p>Parameters:</p> Name Type Description Default <code>id_short</code> <code>IdString</code> <p>Local id of the object.</p> required <code>description</code> <code>str</code> <p>Description of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class Referable(BaseModel):\n    \"\"\"\n    Base class for all referable classes of the AAS meta model. A Referable is an object with a local id (id_short) and a description.\n\n    Args:\n        id_short (IdString): Local id of the object.\n        description (str): Description of the object. Defaults to None.\n    \"\"\"\n\n    id_short: AasIdString\n    description: str = \"\"\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.Submodel","title":"<code> Submodel            (HasSemantics, Identifiable)         </code>","text":"<p>Base class for all submodels.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Global id of the object.</p> required <code>id_short</code> <code>str</code> <p>Local id of the object.</p> required <code>description</code> <code>str</code> <p>Description of the object. Defaults to None.</p> required <code>semantic_id</code> <code>str</code> <p>Semantic id of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class Submodel(HasSemantics, Identifiable):\n    \"\"\"\n    Base class for all submodels.\n\n    Args:\n        id (str): Global id of the object.\n        id_short (str): Local id of the object.\n        description (str, optional): Description of the object. Defaults to None.\n        semantic_id (str, optional): Semantic id of the object. Defaults to None.\n    \"\"\"\n\n    @model_validator(mode=\"after\")\n    def check_submodel_elements(self) -&gt; Self:\n        for field_name in self.model_fields:\n            if field_name in [\"id\", \"id_short\", \"description\", \"semantic_id\"]:\n                continue\n            assert is_valid_submodel_element(\n                getattr(self, field_name)\n            ), f\"All attributes of a Submodel must be valid SubmodelElements.\"\n        return self\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.aas_model.SubmodelElementCollection","title":"<code> SubmodelElementCollection            (HasSemantics, Referable)         </code>","text":"<p>Base class for all submodel element collections.</p> <p>Parameters:</p> Name Type Description Default <code>id_short</code> <code>str</code> <p>Local id of the object.</p> required <code>description</code> <code>str</code> <p>Description of the object. Defaults to None.</p> required <code>semantic_id</code> <code>str</code> <p>Semantic id of the object. Defaults to None.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\aas_model.py</code> <pre><code>class SubmodelElementCollection(HasSemantics, Referable):\n    \"\"\"\n    Base class for all submodel element collections.\n\n    Args:\n        id_short (str): Local id of the object.\n        description (str, optional): Description of the object. Defaults to None.\n        semantic_id (str, optional): Semantic id of the object. Defaults to None.\n    \"\"\"\n\n    @model_validator(mode=\"after\")\n    def check_submodel_elements(self) -&gt; Self:\n        for field_name in self.model_fields:\n            if field_name in [\"id\", \"id_short\", \"description\", \"semantic_id\"]:\n                continue\n            assert is_valid_submodel_element(\n                getattr(self, field_name)\n            ), f\"All attributes of a SubmodelElementCollection must be valid SubmodelElements. Field {field_name} is not valid.\"\n        return self\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.basyx_formatter","title":"<code>basyx_formatter</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.basyx_formatter.BasyxFormatter","title":"<code> BasyxFormatter        </code>","text":"<p>Allows to serialize and deserialize Basyx AAS objects (AssetAdministrationShells, Submodels or Containers of both) to a DataModel.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\basyx_formatter.py</code> <pre><code>class BasyxFormatter:\n    \"\"\"\n    Allows to serialize and deserialize Basyx AAS objects (AssetAdministrationShells, Submodels or Containers of both) to a DataModel.\n    \"\"\"\n\n    def serialize(self, data: DataModel) -&gt; DictObjectStore[model.Identifiable]:\n        \"\"\"\n        Serialize a DataModel object to the specific format of the formatter.\n\n        Args:\n            data (DataModel): A data model\n\n        Returns:\n            Objectstore: the basyx object store contain all AAS elements\n        \"\"\"\n        aas_models, submodel_models = infere_aas_structure(data)\n        obj_store = DictObjectStore()\n        for aas in aas_models:\n            obj_store_to_add = convert_model_to_aas(aas)\n            for identifiable in obj_store_to_add:\n                if obj_store.get(identifiable.id_short) is not None:\n                    continue\n                obj_store.add(identifiable)\n        for submodel in submodel_models:\n            submodel_to_add = convert_model_to_submodel(submodel)\n            if obj_store.get(submodel_to_add.id_short) is not None:\n                continue\n            obj_store.add(submodel_to_add)\n        return obj_store\n\n    def deserialize(self, data: BasyxModels) -&gt; DataModel:\n        \"\"\"\n        Deserialize the specific format of the formater to a DataModel object.\n\n        Args:\n            data (Any): The specific format of the formatter.\n\n        Returns:\n            DataModel: A data model that holds the objects that were deserialized\n        \"\"\"\n        if not isinstance(data, DictObjectStore):\n            data = DictObjectStore(data)\n        models = convert_object_store_to_pydantic_models(data)\n        return DataModel.from_models(*models)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.basyx_formatter.BasyxFormatter.deserialize","title":"<code>deserialize(self, data)</code>","text":"<p>Deserialize the specific format of the formater to a DataModel object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The specific format of the formatter.</p> required <p>Returns:</p> Type Description <code>DataModel</code> <p>A data model that holds the objects that were deserialized</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\basyx_formatter.py</code> <pre><code>def deserialize(self, data: BasyxModels) -&gt; DataModel:\n    \"\"\"\n    Deserialize the specific format of the formater to a DataModel object.\n\n    Args:\n        data (Any): The specific format of the formatter.\n\n    Returns:\n        DataModel: A data model that holds the objects that were deserialized\n    \"\"\"\n    if not isinstance(data, DictObjectStore):\n        data = DictObjectStore(data)\n    models = convert_object_store_to_pydantic_models(data)\n    return DataModel.from_models(*models)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.basyx_formatter.BasyxFormatter.serialize","title":"<code>serialize(self, data)</code>","text":"<p>Serialize a DataModel object to the specific format of the formatter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataModel</code> <p>A data model</p> required <p>Returns:</p> Type Description <code>Objectstore</code> <p>the basyx object store contain all AAS elements</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\basyx_formatter.py</code> <pre><code>def serialize(self, data: DataModel) -&gt; DictObjectStore[model.Identifiable]:\n    \"\"\"\n    Serialize a DataModel object to the specific format of the formatter.\n\n    Args:\n        data (DataModel): A data model\n\n    Returns:\n        Objectstore: the basyx object store contain all AAS elements\n    \"\"\"\n    aas_models, submodel_models = infere_aas_structure(data)\n    obj_store = DictObjectStore()\n    for aas in aas_models:\n        obj_store_to_add = convert_model_to_aas(aas)\n        for identifiable in obj_store_to_add:\n            if obj_store.get(identifiable.id_short) is not None:\n                continue\n            obj_store.add(identifiable)\n    for submodel in submodel_models:\n        submodel_to_add = convert_model_to_submodel(submodel)\n        if obj_store.get(submodel_to_add.id_short) is not None:\n            continue\n        obj_store.add(submodel_to_add)\n    return obj_store\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas","title":"<code>convert_aas</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_aas_to_pydantic_model","title":"<code>convert_aas_to_pydantic_model(aas, pydantic_submodels)</code>","text":"<p>Converts an AAS to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>aas</code> <code>model.AssetAdministrationShell</code> <p>AAS to convert</p> required <p>Returns:</p> Type Description <code>aas_model.AAS</code> <p>Pydantic model of the asset administration shell</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_aas_to_pydantic_model(\n    aas: model.AssetAdministrationShell,\n    pydantic_submodels: typing.List[aas_model.Submodel],\n) -&gt; aas_model.AAS:\n    \"\"\"\n    Converts an AAS to a Pydantic model.\n\n    Args:\n        aas (model.AssetAdministrationShell): AAS to convert\n\n    Returns:\n        aas_model.AAS: Pydantic model of the asset administration shell\n    \"\"\"\n    aas_class_name = convert_util.get_class_name_from_basyx_model(aas)\n    dict_dynamic_model_creation = get_initial_dict_for_dynamic_model_creation(aas)\n    dict_model_instantiation = get_initial_dict_for_model_instantiation(aas)\n    aas_submodel_ids = [sm.get_identifier() for sm in aas.submodel]\n\n    for sm in pydantic_submodels:\n        if not sm.id in aas_submodel_ids:\n            continue\n        attribute_name_of_submodel = convert_util.get_attribute_name_from_basyx_model(\n            aas, sm.id\n        )\n        dict_dynamic_model_creation.update(\n            {\n                attribute_name_of_submodel: typing.Annotated[\n                    type(sm), Field(examples=[sm])\n                ]\n            }\n        )\n        dict_model_instantiation.update({attribute_name_of_submodel: sm.model_dump()})\n    model_type = create_model(\n        aas_class_name, **dict_dynamic_model_creation, __base__=aas_model.AAS\n    )\n    return model_type(**dict_model_instantiation)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_object_store_to_pydantic_models","title":"<code>convert_object_store_to_pydantic_models(obj_store)</code>","text":"<p>Converts an object store with AAS and submodels to pydantic models, representing the original data structure.</p> <p>Parameters:</p> Name Type Description Default <code>obj_store</code> <code>model.DictObjectStore</code> <p>Object store with AAS and submodels</p> required <p>Returns:</p> Type Description <code>List[aas_model.AAS]</code> <p>List of pydantic models</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_object_store_to_pydantic_models(\n    obj_store: model.DictObjectStore,\n) -&gt; typing.List[aas_model.AAS]:\n    \"\"\"\n    Converts an object store with AAS and submodels to pydantic models, representing the original data structure.\n\n    Args:\n        obj_store (model.DictObjectStore): Object store with AAS and submodels\n\n    Returns:\n        typing.List[aas_model.AAS]: List of pydantic models\n    \"\"\"\n    pydantic_submodels: typing.List[aas_model.Submodel] = []\n    for identifiable in obj_store:\n        if isinstance(identifiable, model.Submodel):\n            pydantic_submodel = convert_submodel_to_model(identifiable)\n            pydantic_submodels.append(pydantic_submodel)\n\n    pydantic_aas_list: typing.List[aas_model.AAS] = []\n    for identifiable in obj_store:\n        if isinstance(identifiable, model.AssetAdministrationShell):\n            pydantic_aas = convert_aas_to_pydantic_model(\n                identifiable, pydantic_submodels\n            )\n            pydantic_aas_list.append(pydantic_aas)\n\n    return pydantic_aas_list\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_property_to_pydantic_model","title":"<code>convert_property_to_pydantic_model(sm_element)</code>","text":"<p>Converts a Property to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.Property</code> <p>Property to convert.</p> required <p>Returns:</p> Type Description <code>aas_model.PrimitiveSubmodelElement</code> <p>Value of the Property.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_property_to_pydantic_model(\n    sm_element: model.Property,\n) -&gt; aas_model.PrimitiveSubmodelElement:\n    \"\"\"\n    Converts a Property to a Pydantic model.\n\n    Args:\n        sm_element (model.Property): Property to convert.\n\n    Returns:\n        aas_model.PrimitiveSubmodelElement: Value of the Property.\n    \"\"\"\n    return sm_element.value\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_reference_element_to_pydantic_model","title":"<code>convert_reference_element_to_pydantic_model(sm_element)</code>","text":"<p>Converts a ReferenceElement to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.ReferenceElement</code> <p>ReferenceElement to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Value of the ReferenceElement.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_reference_element_to_pydantic_model(\n    sm_element: model.ReferenceElement,\n) -&gt; str:\n    \"\"\"\n    Converts a ReferenceElement to a Pydantic model.\n\n    Args:\n        sm_element (model.ReferenceElement): ReferenceElement to convert.\n\n    Returns:\n        str: Value of the ReferenceElement.\n    \"\"\"\n    return sm_element.value.key[0].value\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_submodel_collection_to_pydantic_model","title":"<code>convert_submodel_collection_to_pydantic_model(sm_element)</code>","text":"<p>Converts a SubmodelElementCollection to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.SubmodelElementCollection</code> <p>SubmodelElementCollection to convert.</p> required <p>Returns:</p> Type Description <code>aas_model.SubmodelElementCollection</code> <p>Pydantic model of the submodel element collection.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_submodel_collection_to_pydantic_model(\n    sm_element: model.SubmodelElementCollection,\n) -&gt; aas_model.SubmodelElementCollection:\n    \"\"\"\n    Converts a SubmodelElementCollection to a Pydantic model.\n\n    Args:\n        sm_element (model.SubmodelElementCollection): SubmodelElementCollection to convert.\n\n    Returns:\n        aas_model.SubmodelElementCollection: Pydantic model of the submodel element collection.\n    \"\"\"\n    class_name = convert_util.get_class_name_from_basyx_model(sm_element)\n    dict_dynamic_model_creation = get_initial_dict_for_dynamic_model_creation(\n        sm_element\n    )\n    dict_model_instantiation = get_initial_dict_for_model_instantiation(sm_element)\n\n    for sub_sm_element in sm_element.value:\n        attribute_name = convert_util.get_attribute_name_from_basyx_model(\n            sm_element, sub_sm_element.id_short\n        )\n        immutable = is_attribute_from_basyx_model_immutable(\n            sm_element, sub_sm_element.id_short\n        )\n        attribute_value = get_submodel_element_value(sub_sm_element, immutable)\n        dict_sme = get_dynamic_model_creation_dict_from_submodel_element(\n            attribute_name, attribute_value\n        )\n        dict_dynamic_model_creation.update(dict_sme)\n        dict_sme_instantiation = get_model_instantiation_dict_from_submodel_element(\n            attribute_name, attribute_value\n        )\n        dict_model_instantiation.update(dict_sme_instantiation)\n    model_type = create_model(\n        class_name,\n        **dict_dynamic_model_creation,\n        __base__=aas_model.SubmodelElementCollection,\n    )\n    return model_type(**dict_model_instantiation)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_submodel_list_to_pydantic_model","title":"<code>convert_submodel_list_to_pydantic_model(sm_element, immutable=False)</code>","text":"<p>Converts a SubmodelElementList to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.SubmodelElementList</code> <p>SubmodelElementList to convert.</p> required <p>Returns:</p> Type Description <code>List[aas_model.SubmodelElement]</code> <p>List of Pydantic models of the submodel elements.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_submodel_list_to_pydantic_model(\n    sm_element: model.SubmodelElementList, immutable: bool = False\n) -&gt; typing.Union[typing.List[aas_model.SubmodelElement], typing.Set[aas_model.SubmodelElement], typing.Tuple[aas_model.SubmodelElement]]:\n    \"\"\"\n    Converts a SubmodelElementList to a Pydantic model.\n\n    Args:\n        sm_element (model.SubmodelElementList): SubmodelElementList to convert.\n\n    Returns:\n        typing.List[aas_model.SubmodelElement]: List of Pydantic models of the submodel elements.\n    \"\"\"\n    sme_pydantic_models = []\n    for sme in sm_element.value:\n        if isinstance(sme, model.SubmodelElementCollection):\n            sme = unpatch_id_short_from_temp_attribute(sme)\n            sme_pydantic_models.append(\n                convert_submodel_collection_to_pydantic_model(sme)\n            )\n        elif isinstance(sme, model.SubmodelElementList):\n            sme_pydantic_models.append(convert_submodel_list_to_pydantic_model(sme))\n        elif isinstance(sme, model.ReferenceElement):\n            sme_pydantic_models.append(convert_reference_element_to_pydantic_model(sme))\n        elif isinstance(sme, model.Property):\n            sme_pydantic_models.append(sme.value)\n        else:\n            raise NotImplementedError(\"Type not implemented:\", type(sme))\n    if not sm_element.order_relevant:\n        return set(sme_pydantic_models)\n    if immutable:\n        return tuple(sme_pydantic_models)\n    return sme_pydantic_models\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.convert_submodel_to_model","title":"<code>convert_submodel_to_model(sm)</code>","text":"<p>Converts a Submodel to a Pydantic model.</p> <p>Parameters:</p> Name Type Description Default <code>sm</code> <code>model.Submodel</code> <p>Submodel to convert.</p> required <p>Returns:</p> Type Description <code>aas_model.Submodel</code> <p>Pydantic model of the submodel.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def convert_submodel_to_model(sm: model.Submodel) -&gt; aas_model.Submodel:\n    \"\"\"\n    Converts a Submodel to a Pydantic model.\n\n    Args:\n        sm (model.Submodel): Submodel to convert.\n\n    Returns:\n        aas_model.Submodel: Pydantic model of the submodel.\n    \"\"\"\n    class_name = convert_util.get_class_name_from_basyx_model(sm)\n    dict_dynamic_model_creation = get_initial_dict_for_dynamic_model_creation(sm)\n    dict_model_instantiation = get_initial_dict_for_model_instantiation(sm)\n\n    for sm_element in sm.submodel_element:\n        attribute_name = convert_util.get_attribute_name_from_basyx_model(\n            sm, sm_element.id_short\n        )\n        immutable = is_attribute_from_basyx_model_immutable(sm, sm_element.id_short)\n        attribute_value = get_submodel_element_value(sm_element, immutable)\n        sme_model_creation_dict = get_dynamic_model_creation_dict_from_submodel_element(\n            attribute_name, attribute_value\n        )\n        dict_dynamic_model_creation.update(sme_model_creation_dict)\n        sme_model_instantiation_dict = (\n            get_model_instantiation_dict_from_submodel_element(\n                attribute_name, attribute_value\n            )\n        )\n        dict_model_instantiation.update(sme_model_instantiation_dict)\n    model_type = create_model(\n        class_name, **dict_dynamic_model_creation, __base__=aas_model.Submodel\n    )\n    return model_type(**dict_model_instantiation)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.get_dynamic_model_creation_dict_from_submodel_element","title":"<code>get_dynamic_model_creation_dict_from_submodel_element(attribute_name, attribute_value)</code>","text":"<p>Converts a SubmodelElement to a dict.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>Name of the attribute to create in the dictionary.</p> required <code>sm_element</code> <code>model.SubmodelElement</code> <p>SubmodelElement to convert.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary that can be used to create a Pydantic model, with Annoated types for the attributes and examples.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def get_dynamic_model_creation_dict_from_submodel_element(\n    attribute_name: str, attribute_value: typing.Any\n) -&gt; typing.Dict[str, typing.Any]:\n    \"\"\"\n    Converts a SubmodelElement to a dict.\n\n    Args:\n        attribute_name (str): Name of the attribute to create in the dictionary.\n        sm_element (model.SubmodelElement): SubmodelElement to convert.\n\n    Returns:\n        dict: Dictionary that can be used to create a Pydantic model, with Annoated types for the attributes and examples.\n    \"\"\"\n    if isinstance(attribute_value, list) and attribute_value:\n        inner_type = type(attribute_value[0])\n        attribute_type = typing.List[inner_type]\n    elif isinstance(attribute_value, set) and attribute_value:\n        inner_type = type(next(iter(attribute_value)))\n        attribute_type = typing.Set[inner_type]\n    elif isinstance(attribute_value, tuple) and attribute_value:\n        inner_type = type(attribute_value[0])\n        attribute_type = typing.Tuple[inner_type, ...]\n    else:\n        attribute_type = type(attribute_value)\n    return {\n        attribute_name: typing.Annotated[\n            attribute_type, Field(examples=[attribute_value])\n        ]\n    }\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.get_initial_dict_for_dynamic_model_creation","title":"<code>get_initial_dict_for_dynamic_model_creation(basyx_model)</code>","text":"<p>Returns a dictionary that can be used to create a Pydantic model based on a provided basyx submodel.</p> <p>Parameters:</p> Name Type Description Default <code>basyx_model</code> <code>model.Submodel | model.AssetAdministrationShell | model.SubmodelElementCollection</code> <p>Basyx model to create the dictionary from.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary that can be used to create a Pydantic model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def get_initial_dict_for_dynamic_model_creation(\n    basyx_model: (\n        model.Submodel\n        | model.AssetAdministrationShell\n        | model.SubmodelElementCollection\n    ),\n) -&gt; typing.Dict[str, typing.Any]:\n    \"\"\"\n    Returns a dictionary that can be used to create a Pydantic model based on a provided basyx submodel.\n\n    Args:\n        basyx_model (model.Submodel | model.AssetAdministrationShell | model.SubmodelElementCollection): Basyx model to create the dictionary from.\n\n    Returns:\n        typing.Dict[str, typing.Any]: Dictionary that can be used to create a Pydantic model.\n    \"\"\"\n    model_creation_dict = {\n        \"id_short\": typing.Annotated[str, Field(examples=[basyx_model.id_short])],\n        \"description\": typing.Annotated[\n            str,\n            Field(examples=[convert_util.get_str_description(basyx_model.description)]),\n        ],\n    }\n    if isinstance(basyx_model, model.Identifiable):\n        model_creation_dict[\"id\"] = typing.Annotated[\n            str, Field(examples=[str(basyx_model.id)])\n        ]\n    if isinstance(basyx_model, model.HasSemantics):\n        model_creation_dict[\"semantic_id\"] = typing.Annotated[\n            str, Field(examples=[get_semantic_id_value_of_model(basyx_model)])\n        ]\n    return model_creation_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.get_initial_dict_for_model_instantiation","title":"<code>get_initial_dict_for_model_instantiation(basyx_model)</code>","text":"<p>Returns a dictionary that can be used to instantiate a Pydantic model based on a provided basyx submodel.</p> <p>Parameters:</p> Name Type Description Default <code>basyx_model</code> <code>model.Submodel | model.AssetAdministrationShell | model.SubmodelElementCollection</code> <p>Basyx model to create the dictionary from.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary that can be used to instantiate a Pydantic model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def get_initial_dict_for_model_instantiation(\n    basyx_model: (\n        model.Submodel\n        | model.AssetAdministrationShell\n        | model.SubmodelElementCollection\n    ),\n) -&gt; typing.Dict[str, typing.Any]:\n    \"\"\"\n    Returns a dictionary that can be used to instantiate a Pydantic model based on a provided basyx submodel.\n\n    Args:\n        basyx_model (model.Submodel | model.AssetAdministrationShell | model.SubmodelElementCollection): Basyx model to create the dictionary from.\n\n    Returns:\n        typing.Dict[str, typing.Any]: Dictionary that can be used to instantiate a Pydantic model.\n    \"\"\"\n    model_instantiation_dict = {\n        \"id_short\": basyx_model.id_short,\n        \"description\": convert_util.get_str_description(basyx_model.description),\n    }\n    if isinstance(basyx_model, model.Identifiable):\n        model_instantiation_dict[\"id\"] = str(basyx_model.id)\n    if isinstance(basyx_model, model.HasSemantics):\n        model_instantiation_dict[\"semantic_id\"] = get_semantic_id_value_of_model(\n            basyx_model\n        )\n    return model_instantiation_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.get_model_instantiation_dict_from_submodel_element","title":"<code>get_model_instantiation_dict_from_submodel_element(attribute_name, attribute_value)</code>","text":"<p>Converts a SubmodelElement to a dict.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>Name of the attribute to create in the dictionary.</p> required <code>sm_element</code> <code>model.SubmodelElement</code> <p>SubmodelElement to convert.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary that can be used to instantiate a Pydantic model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def get_model_instantiation_dict_from_submodel_element(\n    attribute_name: str, attribute_value: typing.Any\n) -&gt; typing.Dict[str, typing.Any]:\n    \"\"\"\n    Converts a SubmodelElement to a dict.\n\n    Args:\n        attribute_name (str): Name of the attribute to create in the dictionary.\n        sm_element (model.SubmodelElement): SubmodelElement to convert.\n\n    Returns:\n        dict: Dictionary that can be used to instantiate a Pydantic model.\n    \"\"\"\n    if isinstance(attribute_value, BaseModel):\n        attribute_value = attribute_value.model_dump()\n    elif isinstance(attribute_value, (list, set, tuple)) and any(\n        isinstance(element, BaseModel) for element in attribute_value\n    ):\n        attribute_value = [element.model_dump() for element in attribute_value]\n    return {attribute_name: attribute_value}\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.get_submodel_element_value","title":"<code>get_submodel_element_value(sm_element, immutable=False)</code>","text":"<p>Returns the value of a SubmodelElement.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.SubmodelElement</code> <p>SubmodelElement to get the value from.</p> required <p>Returns:</p> Type Description <code>aas_model.SubmodelElement</code> <p>Value of the SubmodelElement.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def get_submodel_element_value(\n    sm_element: model.SubmodelElement, immutable: bool = False\n) -&gt; aas_model.SubmodelElement:\n    \"\"\"\n    Returns the value of a SubmodelElement.\n\n    Args:\n        sm_element (model.SubmodelElement): SubmodelElement to get the value from.\n\n    Returns:\n        aas_model.SubmodelElement: Value of the SubmodelElement.\n    \"\"\"\n    if isinstance(sm_element, model.SubmodelElementCollection):\n        return convert_submodel_collection_to_pydantic_model(sm_element)\n    elif isinstance(sm_element, model.SubmodelElementList):\n        return convert_submodel_list_to_pydantic_model(sm_element, immutable)\n    elif isinstance(sm_element, model.ReferenceElement):\n        return convert_reference_element_to_pydantic_model(sm_element)\n    elif isinstance(sm_element, model.Property):\n        return convert_property_to_pydantic_model(sm_element)\n    else:\n        raise NotImplementedError(\"Type not implemented:\", type(sm_element))\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_aas.unpatch_id_short_from_temp_attribute","title":"<code>unpatch_id_short_from_temp_attribute(smec)</code>","text":"<p>Unpatches the id_short attribute of a SubmodelElementCollection from the temporary attribute.</p> <p>Parameters:</p> Name Type Description Default <code>sm_element</code> <code>model.SubmodelElementCollection</code> <p>SubmodelElementCollection to unpatch.</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_aas.py</code> <pre><code>def unpatch_id_short_from_temp_attribute(smec: model.SubmodelElementCollection):\n    \"\"\"\n    Unpatches the id_short attribute of a SubmodelElementCollection from the temporary attribute.\n\n    Args:\n        sm_element (model.SubmodelElementCollection): SubmodelElementCollection to unpatch.\n    \"\"\"\n    if not smec.id_short.startswith(\"generated_submodel_list_hack_\"):\n        return smec\n    if not any(isinstance(sm_element, model.Property) and sm_element.id_short.startswith(\"temp_id_short_attribute\") for sm_element in smec.value):\n        raise ValueError(\"No temporary id_short attribute found in SubmodelElementCollection.\")\n    no_temp_values = []\n    id_short = None\n    for sm_element in smec.value:\n        if isinstance(sm_element, model.Property) and sm_element.id_short.startswith(\"temp_id_short_attribute\"):\n            id_short = sm_element.value\n            continue\n        no_temp_values.append(sm_element)\n\n    for value in no_temp_values:\n        smec.value.remove(value)\n    new_smec = model.SubmodelElementCollection(\n        id_short=id_short, value=no_temp_values,\n        embedded_data_specifications=smec.embedded_data_specifications,\n    )\n    # new_smec.value.remove(contained_sm_element)\n    return new_smec\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_pydantic","title":"<code>convert_pydantic</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_pydantic.convert_model_to_aas","title":"<code>convert_model_to_aas(model_aas)</code>","text":"<p>Convert a model aas to an Basyx AssetAdministrationShell and return it as a DictObjectStore with all Submodels</p> <p>Parameters:</p> Name Type Description Default <code>model_aas</code> <code>aas_model.AAS</code> <p>model aas to convert</p> required <p>Returns:</p> Type Description <code>model.DictObjectStore[model.Identifiable]</code> <p>DictObjectStore with all Submodels</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_pydantic.py</code> <pre><code>def convert_model_to_aas(\n    model_aas: aas_model.AAS,\n) -&gt; model.DictObjectStore[model.Identifiable]:\n    \"\"\"\n    Convert a model aas to an Basyx AssetAdministrationShell and return it as a DictObjectStore with all Submodels\n\n    Args:\n        model_aas (aas_model.AAS): model aas to convert\n\n    Returns:\n        model.DictObjectStore[model.Identifiable]: DictObjectStore with all Submodels\n    \"\"\"\n    aas_attributes = get_attribute_dict(model_aas)\n    aas_submodels = []  # placeholder for submodels created\n    aas_submodel_data_specifications = []\n    for attribute_name, attribute_value in aas_attributes.items():\n        if isinstance(attribute_value, aas_model.Submodel):\n            tempsubmodel = convert_model_to_submodel(model_submodel=attribute_value)\n            aas_submodels.append(tempsubmodel)\n            attribute_data_specifications = convert_util.get_data_specification_for_attribute(\n                    attribute_name, attribute_value.id, attribute_value\n\n            )\n            aas_submodel_data_specifications += attribute_data_specifications\n\n    asset_information = model.AssetInformation(\n        global_asset_id=model.Identifier(model_aas.id),\n    )\n\n    basyx_aas = model.AssetAdministrationShell(\n        asset_information=asset_information,\n        id_short=get_id_short(model_aas),\n        id_=model.Identifier(model_aas.id),\n        description=convert_util.get_basyx_description_from_model(model_aas),\n        submodel={\n            model.ModelReference.from_referable(submodel) for submodel in aas_submodels\n        },\n        embedded_data_specifications=convert_util.get_data_specification_for_model(model_aas) + aas_submodel_data_specifications,\n    )\n    obj_store: model.DictObjectStore[model.Identifiable] = model.DictObjectStore()\n    obj_store.add(basyx_aas)\n    for sm in aas_submodels:\n        obj_store.add(sm)\n    return obj_store\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_pydantic.create_submodel_element","title":"<code>create_submodel_element(attribute_name, attribute_value)</code>","text":"<p>Create a basyx SubmodelElement from a model SubmodelElementCollection or a primitive type</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>Name of the attribute that is used for ID and id_short</p> required <code>attribute_value</code> <code>Union[ aas_model.SubmodelElementCollection, str, float, int, bool, tuple, list, set ]</code> <p>Value of the attribute</p> required <p>Returns:</p> Type Description <code>model.SubmodelElement</code> <p>basyx SubmodelElement</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_pydantic.py</code> <pre><code>def create_submodel_element(\n    attribute_name: str,\n    attribute_value: Union[\n        aas_model.SubmodelElementCollection, str, float, int, bool, tuple, list, set\n    ],\n) -&gt; model.SubmodelElement:\n    \"\"\"\n    Create a basyx SubmodelElement from a model SubmodelElementCollection or a primitive type\n\n    Args:\n        attribute_name (str): Name of the attribute that is used for ID and id_short\n        attribute_value (Union[ aas_model.SubmodelElementCollection, str, float, int, bool, tuple, list, set ]): Value of the attribute\n\n\n    Returns:\n        model.SubmodelElement: basyx SubmodelElement\n    \"\"\"\n    if isinstance(attribute_value, aas_model.SubmodelElementCollection):\n        smc = create_submodel_element_collection(attribute_value)\n        return smc\n    elif isinstance(attribute_value, list):\n        sml = create_submodel_element_list(attribute_name, attribute_value)\n        return sml\n    elif isinstance(attribute_value, tuple):\n        attribute_value_as_list = list(attribute_value)\n        sml = create_submodel_element_list(attribute_name, attribute_value_as_list)\n        return sml\n    elif isinstance(attribute_value, set):\n        attribute_value_as_list = list(attribute_value)\t\n        sml = create_submodel_element_list(\n            attribute_name, attribute_value_as_list, ordered=False\n        )\n        return sml\n    elif (isinstance(attribute_value, str)) and (\n        (\n            parse.urlparse(attribute_value).scheme\n            and parse.urlparse(attribute_value).netloc\n        )\n        or (attribute_value.split(\"_\")[-1] in [\"id\", \"ids\"])\n    ):\n        key = model.Key(\n            type_=model.KeyTypes.ASSET_ADMINISTRATION_SHELL,\n            value=attribute_value,\n        )\n        reference = model.ModelReference(key=(key,), type_=\"\")\n        reference_element = model.ReferenceElement(\n            id_short=attribute_name,\n            value=reference,\n        )\n        return reference_element\n    else:\n        property = create_property(attribute_name, attribute_value)\n\n        return property\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_pydantic.infere_aas_structure","title":"<code>infere_aas_structure(data)</code>","text":"<p>The function assert that the data contained in the data model fulfills the aas meta model structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataModel</code> <p>The Data Model containing the objects that should be transformed to AAS models</p> required <p>Returns:</p> Type Description <code>Tuple[List[aas_model.AAS], List[aas_model.Submodel]]</code> <p>Tuple with AAS models and Submodel models</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_pydantic.py</code> <pre><code>def infere_aas_structure(\n    data: DataModel,\n) -&gt; Tuple[List[aas_model.AAS], List[aas_model.Submodel]]:\n    \"\"\"\n    The function assert that the data contained in the data model fulfills the aas meta model structure.\n\n    Args:\n        data (DataModel): The Data Model containing the objects that should be transformed to AAS models\n\n    Returns:\n        Tuple[List[aas_model.AAS], List[aas_model.Submodel]]: Tuple with AAS models and Submodel models\n    \"\"\"\n    if all(isinstance(model, aas_model.AAS) for model in data.get_top_level_models()):\n        return data.get_top_level_models(), []\n    logger.warning(\n        \"The data model does not contain only AAS models. Trying to infer the AAS structure by rebuilding the data model.\"\n    )\n    new_data_model = DataModelRebuilder(data).rebuild_data_model_for_AAS_structure()\n    top_level_models_list = []\n    for models in new_data_model.get_top_level_models().values():\n        top_level_models_list += models\n    aas_models = [\n        model for model in top_level_models_list if isinstance(model, aas_model.AAS)\n    ]\n    submodel_models = [\n        model\n        for model in top_level_models_list\n        if isinstance(model, aas_model.Submodel)\n    ]\n    return aas_models, submodel_models\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_pydantic.patch_id_short_with_temp_attribute","title":"<code>patch_id_short_with_temp_attribute(submodel_element_collection)</code>","text":"<p>Patch the id_short of a SubmodelElementCollection as an attribute in the value of the SubmodelElementCollection, to make it accesible after retrieving from the value list.</p> <p>Parameters:</p> Name Type Description Default <code>submodel_element_collection</code> <code>model.SubmodelElementCollection</code> <p>SubmodelElementCollection to patch</p> required Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_pydantic.py</code> <pre><code>def patch_id_short_with_temp_attribute(\n        submodel_element_collection: model.SubmodelElementCollection\n    ) -&gt; None:\n    \"\"\"\n    Patch the id_short of a SubmodelElementCollection as an attribute in the value of the SubmodelElementCollection, to make it accesible after retrieving from the value list.\n\n    Args:\n        submodel_element_collection (model.SubmodelElementCollection): SubmodelElementCollection to patch\n    \"\"\"\n    temp_id_short_property = model.Property(\n        id_short=\"temp_id_short_attribute_\" + uuid.uuid4().hex,\n        value_type=get_value_type_of_attribute(str),\n        value=submodel_element_collection.id_short,\n    )\n    submodel_element_collection.value.add(temp_id_short_property)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util","title":"<code>convert_util</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_attribute_dict","title":"<code>get_attribute_dict(obj)</code>","text":"<p>Returns a dictionary of all attributes of an object that are not None, do not start with an underscore and are not standard attributes of the aas object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[aas_model.AAS, aas_model.Submodel, aas_model.SubmodelElementCollection]</code> <p>Object to get the attributes from</p> required <p>Returns:</p> Type Description <code>Dict[str, Union[aas_model.Submodel, aas_model.SubmodelElement]]</code> <p>Dictionary of all attributes of the object and their respective values</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_attribute_dict(\n    obj: Union[aas_model.AAS, aas_model.Submodel, aas_model.SubmodelElementCollection]\n) -&gt; Dict[str, Union[aas_model.Submodel, aas_model.SubmodelElement]]:\n    \"\"\"\n    Returns a dictionary of all attributes of an object that are not None, do not start with an underscore and are not standard attributes of the aas object.\n\n    Args:\n        obj (Union[aas_model.AAS, aas_model.Submodel, aas_model.SubmodelElementCollection]): Object to get the attributes from\n\n    Returns:\n        Dict[str, Union[aas_model.Submodel, aas_model.SubmodelElement]]: Dictionary of all attributes of the object and their respective values\n    \"\"\"\n    vars_dict = vars(obj)\n    vars_dict = {key: value for key, value in vars_dict.items() if key[0] != \"_\"}\n    vars_dict = {key: value for key, value in vars_dict.items() if value is not None}\n    vars_dict = {key: value for key, value in vars_dict.items() if key != \"id\"}\n    vars_dict = {key: value for key, value in vars_dict.items() if key != \"description\"}\n    vars_dict = {key: value for key, value in vars_dict.items() if key != \"id_short\"}\n    vars_dict = {key: value for key, value in vars_dict.items() if key != \"semantic_id\"}\n    return vars_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_attribute_name_from_basyx_model","title":"<code>get_attribute_name_from_basyx_model(item, referenced_item_id)</code>","text":"<p>Returns the attribute name of the referenced element of the item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection]</code> <p>The container of the refernced item</p> required <code>referenced_item_id</code> <code>str</code> <p>The id of the referenced item</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If not data specifications are found in the item or if no attribute name is found</p> <p>Returns:</p> Type Description <code>str</code> <p>The attribute name of the referenced item</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_attribute_name_from_basyx_model(\n    item: typing.Union[\n        model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection\n    ],\n    referenced_item_id: str,\n) -&gt; str:\n    \"\"\"\n    Returns the attribute name of the referenced element of the item.\n\n    Args:\n        item (typing.Union[model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection]): The container of the refernced item\n        referenced_item_id (str): The id of the referenced item\n\n    Raises:\n        ValueError: If not data specifications are found in the item or if no attribute name is found\n\n    Returns:\n        str: The attribute name of the referenced item\n    \"\"\"\n    if not item.embedded_data_specifications:\n        raise ValueError(\"No data specifications found in item:\", item)\n    for data_spec in item.embedded_data_specifications:\n        content = data_spec.data_specification_content\n        if not isinstance(content, model.DataSpecificationIEC61360):\n            continue\n        if not any(\n            key.value == referenced_item_id for key in data_spec.data_specification.key\n        ):\n            continue\n        if not content.preferred_name.get(\"en\") == \"attribute\":\n            continue\n        return content.value\n    raise ValueError(\n        f\"Attribute reference to {referenced_item_id} could not be found in {item.id_short} of type {type(item)}\"\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_basyx_description_from_model","title":"<code>get_basyx_description_from_model(model_object)</code>","text":"<p>Creates a LangStringSet from an aas model.</p> <p>Parameters:</p> Name Type Description Default <code>model_object</code> <code>aas_model.AAS | aas_model.Submodel | aas_model.SubmodelElementCollection</code> <p>The model to get the description from.</p> required <p>Returns:</p> Type Description <code>model.LangStringSet</code> <p>LangStringSet description representation of the model object</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the description of the model object is not a dict or a string</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_basyx_description_from_model(\n    model_object: (\n        aas_model.AAS | aas_model.Submodel | aas_model.SubmodelElementCollection\n    ),\n) -&gt; model.LangStringSet:\n    \"\"\"\n    Creates a LangStringSet from an aas model.\n    Args:\n        model_object (aas_model.AAS | aas_model.Submodel | aas_model.SubmodelElementCollection): The model to get the description from.\n    Returns:\n        model.LangStringSet: LangStringSet description representation of the model object\n    Raises:\n        ValueError: If the description of the model object is not a dict or a string\n    \"\"\"\n    if not model_object.description:\n        return None\n    try:\n        dict_description = json.loads(model_object.description)\n        if not isinstance(dict_description, dict):\n            raise ValueError\n    except ValueError:\n        dict_description = {\"en\": model_object.description}\n    return model.LangStringSet(dict_description)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_class_name_from_basyx_model","title":"<code>get_class_name_from_basyx_model(item)</code>","text":"<p>Returns the class name of an basyx model from the data specifications.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>model.HasDataSpecification</code> <p>Basyx model to get the class name from</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If no data specifications are found in the item or if no class name is found</p> <p>Returns:</p> Type Description <code>str</code> <p>Class name of the basyx model</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_class_name_from_basyx_model(\n    item: typing.Union[\n        model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection\n    ]\n) -&gt; str:\n    \"\"\"\n    Returns the class name of an basyx model from the data specifications.\n\n    Args:\n        item (model.HasDataSpecification): Basyx model to get the class name from\n\n    Raises:\n        ValueError: If no data specifications are found in the item or if no class name is found\n\n    Returns:\n        str: Class name of the basyx model\n    \"\"\"\n    if not item.embedded_data_specifications:\n        raise ValueError(\"No data specifications found in item:\", item)\n    for data_spec in item.embedded_data_specifications:\n        content = data_spec.data_specification_content\n        if not isinstance(content, model.DataSpecificationIEC61360):\n            continue\n        if not any(\n            key.value == item.id_short for key in data_spec.data_specification.key\n        ):\n            continue\n        if not content.preferred_name.get(\"en\") == \"class\":\n            continue\n        return content.value\n    raise ValueError(\n        f\"No class name found in item with id {item.id_short} and type {type(item)}\"\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_semantic_id_value_of_model","title":"<code>get_semantic_id_value_of_model(basyx_model)</code>","text":"<p>Returns the semantic id of a submodel or submodel element.</p> <p>Parameters:</p> Name Type Description Default <code>basyx_model</code> <code>model.Submodel | model.SubmodelElement</code> <p>Basyx model to get the semantic id from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Semantic id of the model.</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_semantic_id_value_of_model(\n    basyx_model: typing.Union[model.Submodel, model.SubmodelElement]\n) -&gt; str:\n    \"\"\"\n    Returns the semantic id of a submodel or submodel element.\n\n    Args:\n        basyx_model (model.Submodel | model.SubmodelElement): Basyx model to get the semantic id from.\n\n    Returns:\n        str: Semantic id of the model.\n    \"\"\"\n    if not isinstance(basyx_model, model.HasSemantics):\n        raise NotImplementedError(\"Type not implemented:\", type(basyx_model))\n    if not basyx_model.semantic_id:\n        return \"\"\n    return basyx_model.semantic_id.key[0].value\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.get_str_description","title":"<code>get_str_description(langstring_set)</code>","text":"<p>Converts a LangStringSet to a string.</p> <p>Parameters:</p> Name Type Description Default <code>langstring_set</code> <code>model.LangStringSet</code> <p>LangStringSet to convert</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representation of the LangStringSet</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def get_str_description(langstring_set: model.LangStringSet) -&gt; str:\n    \"\"\"\n    Converts a LangStringSet to a string.\n    Args:\n        langstring_set (model.LangStringSet): LangStringSet to convert\n    Returns:\n        str: String representation of the LangStringSet\n    \"\"\"\n    if not langstring_set:\n        return \"\"\n    dict_description = {}\n    for langstring in langstring_set:\n        dict_description[langstring] = langstring_set[langstring]\n    return str(dict_description)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.aas.convert_util.is_attribute_from_basyx_model_immutable","title":"<code>is_attribute_from_basyx_model_immutable(item, referenced_item_id)</code>","text":"<p>Returns if the referenced item of the item is immutable.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection]</code> <p>The container of the refernced item</p> required <code>referenced_item_id</code> <code>str</code> <p>The id of the referenced item</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If not data specifications are found in the item or if no attribute name is found</p> <p>Returns:</p> Type Description <code>bool</code> <p>If the referenced item is immutable</p> Source code in <code>aas_middleware\\model\\formatting\\aas\\convert_util.py</code> <pre><code>def is_attribute_from_basyx_model_immutable(\n    item: typing.Union[\n        model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection\n    ],\n    referenced_item_id: str,\n) -&gt; bool:\n    \"\"\"\n    Returns if the referenced item of the item is immutable.\n\n    Args:\n        item (typing.Union[model.AssetAdministrationShell, model.Submodel, model.SubmodelElementCollection]): The container of the refernced item\n        referenced_item_id (str): The id of the referenced item\n\n    Raises:\n        ValueError: If not data specifications are found in the item or if no attribute name is found\n\n    Returns:\n        bool: If the referenced item is immutable\n    \"\"\"\n    if not item.embedded_data_specifications:\n        raise ValueError(\"No data specifications found in item:\", item)\n    for data_spec in item.embedded_data_specifications:\n        content = data_spec.data_specification_content\n        if not isinstance(content, model.DataSpecificationIEC61360):\n            continue\n        if not any(\n            key.value == referenced_item_id for key in data_spec.data_specification.key\n        ):\n            continue\n        if not content.preferred_name.get(\"en\") == \"immutable\":\n            continue\n        return content.value == \"true\"\n    raise ValueError(\n        f\"Attribute reference to {referenced_item_id} could not be found in {item.id_short} of type {type(item)}\"\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.formatter","title":"<code>formatter</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.formatter.Formatter","title":"<code> Formatter            (Protocol)         </code>","text":"<p>Protocol for all formatters that are used to serialize and deserialize data models.</p> Source code in <code>aas_middleware\\model\\formatting\\formatter.py</code> <pre><code>class Formatter(Protocol):\n    \"\"\"\n    Protocol for all formatters that are used to serialize and deserialize data models.\n    \"\"\"\n\n    def serialize(self, data: DataModel) -&gt; Any:\n        \"\"\"\n        Serialize a DataModel object to the specific format of the formatter.\n\n        Args:\n            data (DataModel): A data model\n\n        Returns:\n            Any: A string in the specific format of the formatter.\n        \"\"\"\n        ...\n\n    def deserialize(self, data: Any) -&gt; DataModel:\n        \"\"\"\n        Deserialize the specific format of the formater to a DataModel object.\n\n        Args:\n            data (Any): The specific format of the formatter.\n\n        Returns:\n            DataModel: A data model that holds the objects that were deserialized\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.formatter.Formatter.deserialize","title":"<code>deserialize(self, data)</code>","text":"<p>Deserialize the specific format of the formater to a DataModel object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The specific format of the formatter.</p> required <p>Returns:</p> Type Description <code>DataModel</code> <p>A data model that holds the objects that were deserialized</p> Source code in <code>aas_middleware\\model\\formatting\\formatter.py</code> <pre><code>def deserialize(self, data: Any) -&gt; DataModel:\n    \"\"\"\n    Deserialize the specific format of the formater to a DataModel object.\n\n    Args:\n        data (Any): The specific format of the formatter.\n\n    Returns:\n        DataModel: A data model that holds the objects that were deserialized\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.formatting.formatter.Formatter.serialize","title":"<code>serialize(self, data)</code>","text":"<p>Serialize a DataModel object to the specific format of the formatter.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataModel</code> <p>A data model</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A string in the specific format of the formatter.</p> Source code in <code>aas_middleware\\model\\formatting\\formatter.py</code> <pre><code>def serialize(self, data: DataModel) -&gt; Any:\n    \"\"\"\n    Serialize a DataModel object to the specific format of the formatter.\n\n    Args:\n        data (DataModel): A data model\n\n    Returns:\n        Any: A string in the specific format of the formatter.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.mapping","title":"<code>mapping</code>  <code>special</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.mapping.mapper","title":"<code>mapper</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.mapping.mapper.Mapper","title":"<code> Mapper            (Protocol)         </code>","text":"<p>Protocol for all mappers that are used to map data models to other data models.</p> Source code in <code>aas_middleware\\model\\mapping\\mapper.py</code> <pre><code>class Mapper(Protocol):\n    \"\"\"\n    Protocol for all mappers that are used to map data models to other data models.\n    \"\"\"\n\n    def map(self, data: DataModel) -&gt; DataModel:\n        \"\"\"\n        Map a DataModel object to another DataModel object with different types and structure.\n\n        Args:\n            data (DataModel): A data model\n\n        Returns:\n            DataModel: The mapped data model.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.mapping.mapper.Mapper.map","title":"<code>map(self, data)</code>","text":"<p>Map a DataModel object to another DataModel object with different types and structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataModel</code> <p>A data model</p> required <p>Returns:</p> Type Description <code>DataModel</code> <p>The mapped data model.</p> Source code in <code>aas_middleware\\model\\mapping\\mapper.py</code> <pre><code>def map(self, data: DataModel) -&gt; DataModel:\n    \"\"\"\n    Map a DataModel object to another DataModel object with different types and structure.\n\n    Args:\n        data (DataModel): A data model\n\n    Returns:\n        DataModel: The mapped data model.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder","title":"<code>reference_finder</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceFinder","title":"<code> ReferenceFinder        </code>","text":"Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>class ReferenceFinder:\n    model: Identifiable\n    contained_models: List[Identifiable] = []\n    references: List[ReferenceInfo] = []\n\n    contained_schemas: List[Type[Identifiable]] = []\n    schema_references: List[ReferenceInfo] = []\n\n    @classmethod\n    def find(\n        cls, model: Identifiable\n    ) -&gt; Tuple[List[Identifiable], Set[ReferenceInfo]]:\n        \"\"\"\n        Method to find all contained models (inclusive the model itself) and references in a given model.\n\n        Args:\n            model (Identifiable): The model to find contained models and references in.\n\n        Returns:\n            Tuple[List[Identifiable], List[ReferenceInfo]]: A tuple containing the list of contained models and the list of references.\n        \"\"\"\n        finder = cls()\n        finder.model = model\n        finder.find_contained_identifiables_and_references()\n        return finder.contained_models, finder.references\n\n    def find_contained_identifiables_and_references(self):\n        \"\"\"\n        Method to find all contained identifiables (inclusive the model itself) and references in the model.\n        \"\"\"\n        self.contained_models = get_all_contained_identifiables(self.model)\n        self.references = get_reference_infos(self.contained_models)\n\n    @classmethod\n    def find_schema_references(\n            cls,\n            model: Identifiable,\n    ) -&gt; Tuple[List[Identifiable], Set[ReferenceInfo]]:\n        \"\"\"\n        Method to find all contained models (inclusive the model itself) and references in a given model.\n\n        Args:\n            model (Identifiable): The model to find contained models and references in.\n\n        Returns:\n            Tuple[List[Identifiable], List[ReferenceInfo]]: A tuple containing the list of contained models and the list of references.\n        \"\"\"\n        finder = cls()\n        finder.model = model\n        finder.find_contained_schemas_and_references()\n        return finder.contained_schemas, finder.schema_references\n\n    def find_contained_schemas_and_references(self):\n        \"\"\"\n        Method to find all contained identifiables (inclusive the model itself) and references in the model.\n        \"\"\"\n        self.contained_schemas = get_all_contained_schemas(self.model)\n        self.schema_references = get_schema_reference_infos(self.contained_schemas)\n        # FIXME: resolve empty referenced nodes without an associated type -&gt; either find subclasses or classes that contain the referenced name (e.g. \"acticePoleHousing\" for class \"PoleHousing\")\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceFinder.find","title":"<code>find(model)</code>  <code>classmethod</code>","text":"<p>Method to find all contained models (inclusive the model itself) and references in a given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The model to find contained models and references in.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Identifiable], List[ReferenceInfo]]</code> <p>A tuple containing the list of contained models and the list of references.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>@classmethod\ndef find(\n    cls, model: Identifiable\n) -&gt; Tuple[List[Identifiable], Set[ReferenceInfo]]:\n    \"\"\"\n    Method to find all contained models (inclusive the model itself) and references in a given model.\n\n    Args:\n        model (Identifiable): The model to find contained models and references in.\n\n    Returns:\n        Tuple[List[Identifiable], List[ReferenceInfo]]: A tuple containing the list of contained models and the list of references.\n    \"\"\"\n    finder = cls()\n    finder.model = model\n    finder.find_contained_identifiables_and_references()\n    return finder.contained_models, finder.references\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceFinder.find_contained_identifiables_and_references","title":"<code>find_contained_identifiables_and_references(self)</code>","text":"<p>Method to find all contained identifiables (inclusive the model itself) and references in the model.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def find_contained_identifiables_and_references(self):\n    \"\"\"\n    Method to find all contained identifiables (inclusive the model itself) and references in the model.\n    \"\"\"\n    self.contained_models = get_all_contained_identifiables(self.model)\n    self.references = get_reference_infos(self.contained_models)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceFinder.find_contained_schemas_and_references","title":"<code>find_contained_schemas_and_references(self)</code>","text":"<p>Method to find all contained identifiables (inclusive the model itself) and references in the model.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def find_contained_schemas_and_references(self):\n    \"\"\"\n    Method to find all contained identifiables (inclusive the model itself) and references in the model.\n    \"\"\"\n    self.contained_schemas = get_all_contained_schemas(self.model)\n    self.schema_references = get_schema_reference_infos(self.contained_schemas)\n    # FIXME: resolve empty referenced nodes without an associated type -&gt; either find subclasses or classes that contain the referenced name (e.g. \"acticePoleHousing\" for class \"PoleHousing\")\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceFinder.find_schema_references","title":"<code>find_schema_references(model)</code>  <code>classmethod</code>","text":"<p>Method to find all contained models (inclusive the model itself) and references in a given model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The model to find contained models and references in.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Identifiable], List[ReferenceInfo]]</code> <p>A tuple containing the list of contained models and the list of references.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>@classmethod\ndef find_schema_references(\n        cls,\n        model: Identifiable,\n) -&gt; Tuple[List[Identifiable], Set[ReferenceInfo]]:\n    \"\"\"\n    Method to find all contained models (inclusive the model itself) and references in a given model.\n\n    Args:\n        model (Identifiable): The model to find contained models and references in.\n\n    Returns:\n        Tuple[List[Identifiable], List[ReferenceInfo]]: A tuple containing the list of contained models and the list of references.\n    \"\"\"\n    finder = cls()\n    finder.model = model\n    finder.find_contained_schemas_and_references()\n    return finder.contained_schemas, finder.schema_references\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceInfo","title":"<code> ReferenceInfo            (BaseModel)         </code>","text":"<p>Object reference to a model in the data model.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>class ReferenceInfo(BaseModel):\n    \"\"\"\n    Object reference to a model in the data model.\n\n    Args:\n    \"\"\"\n\n    identifiable_id: str\n    reference_id: str\n    reference_type: ReferenceType\n\n    model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.ReferenceType","title":"<code> ReferenceType            (Enum)         </code>","text":"<p>Enum for the reference types. There exist three types of references: - Association: The reference is done by an association between two objects, where the model has the referenced object as an attribute. - Reference: The reference element is an object and the reference in the model is done by referencing the id of the referenced object. - Attribute: The referenced element is an primitive attribute of the model.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>class ReferenceType(Enum):\n    \"\"\"\n    Enum for the reference types. There exist three types of references:\n    - Association: The reference is done by an association between two objects, where the model has the referenced object as an attribute.\n    - Reference: The reference element is an object and the reference in the model is done by referencing the id of the referenced object.\n    - Attribute: The referenced element is an primitive attribute of the model.\n    \"\"\"\n    ASSOCIATION = \"association\"\n    REFERENCE = \"reference\"\n    ATTRIBUTE = \"attribute\"\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.get_reference_infos","title":"<code>get_reference_infos(identifiables)</code>","text":"<p>Method to get all reference infos of a list of identifiables.</p> <p>Parameters:</p> Name Type Description Default <code>identifiables</code> <code>List[Identifiable]</code> <p>The list of identifiables.</p> required <p>Returns:</p> Type Description <code>Set[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def get_reference_infos(identifiables: List[Identifiable]) -&gt; Set[ReferenceInfo]:\n    \"\"\"\n    Method to get all reference infos of a list of identifiables.\n\n    Args:\n        identifiables (List[Identifiable]): The list of identifiables.\n\n    Returns:\n        Set[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    reference_infos = set()\n    for identifiable in identifiables:\n        reference_infos = reference_infos | get_reference_infos_of_model(identifiable)\n    return reference_infos\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.get_reference_infos_of_model","title":"<code>get_reference_infos_of_model(model)</code>","text":"<p>Method to add information about referencing model ids of the input model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Referable</code> <p>The model to add the information for.</p> required <p>Returns:</p> Type Description <code>Set[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def get_reference_infos_of_model(model: Identifiable) -&gt; Set[ReferenceInfo]:\n    \"\"\"\n    Method to add information about referencing model ids of the input model.\n\n    Args:\n        model (Referable): The model to add the information for.\n\n    Returns:\n        Set[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    reference_infos = set()\n    identifiables_of_model = get_identifiable_attributes_of_model(model)\n    for identifiable in identifiables_of_model:\n        if identifiable == model:\n            continue\n        reference_info = ReferenceInfo(\n            identifiable_id=get_id_with_patch(model),\n            reference_id=get_id_with_patch(identifiable),\n            reference_type=ReferenceType.ASSOCIATION,\n        )\n        reference_infos.add(reference_info)\n    indirect_references = get_referenced_ids_of_model(model)\n    for indirect_reference in indirect_references:\n        reference_info = ReferenceInfo(\n            identifiable_id=get_id_with_patch(model),\n            reference_id=indirect_reference,\n            reference_type=ReferenceType.REFERENCE,\n        )\n        reference_infos.add(reference_info)\n\n    unidentifiable_attributes = get_unidentifiable_attributes_of_model(model)\n    for attribute_name, attribute_value in unidentifiable_attributes.items():\n        reference_info = ReferenceInfo(\n            identifiable_id=get_id_with_patch(model),\n            reference_id=f\"{attribute_name}={attribute_value}\",\n            reference_type=ReferenceType.ATTRIBUTE,\n        )\n        reference_infos.add(reference_info)\n    return reference_infos\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.get_reference_infos_of_schema","title":"<code>get_reference_infos_of_schema(schema)</code>","text":"<p>Method to add information about referencing schema ids of the input schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Identifiable]</code> <p>The schema to add the information for.</p> required <p>Returns:</p> Type Description <code>Set[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def get_reference_infos_of_schema(schema: Type[Identifiable]) -&gt; Set[ReferenceInfo]:\n    \"\"\"\n    Method to add information about referencing schema ids of the input schema.\n\n    Args:\n        schema (Type[Identifiable]): The schema to add the information for.\n\n    Returns:\n        Set[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    reference_infos = set()\n    attribute_dict_of_schema = get_attribute_dict_of_schema(schema)\n    for attribute_name, attribute_type in attribute_dict_of_schema.items():\n        attribute_types = get_identifiable_types(attribute_type)\n\n        for arg in attribute_types:\n            reference_info = get_reference_info_for_schema(schema, attribute_name, arg)\n            if not reference_info:\n                continue\n            reference_infos.add(reference_info)\n    return reference_infos\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.reference_finder.get_schema_reference_infos","title":"<code>get_schema_reference_infos(schemas)</code>","text":"<p>Method to get all reference infos of a list of schemas.</p> <p>Parameters:</p> Name Type Description Default <code>schemas</code> <code>List[Type[Identifiable]]</code> <p>The list of schemas.</p> required <p>Returns:</p> Type Description <code>List[ReferenceInfo]</code> <p>The list of reference infos.</p> Source code in <code>aas_middleware\\model\\reference_finder.py</code> <pre><code>def get_schema_reference_infos(schemas: List[Type[Identifiable]]) -&gt; Set[ReferenceInfo]:\n    \"\"\"\n    Method to get all reference infos of a list of schemas.\n\n    Args:\n        schemas (List[Type[Identifiable]]): The list of schemas.\n\n    Returns:\n        List[ReferenceInfo]: The list of reference infos.\n    \"\"\"\n    reference_infos = set()\n    for schema in schemas:\n        reference_infos = reference_infos | get_reference_infos_of_schema(schema)\n    return reference_infos\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.schema_util","title":"<code>schema_util</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.schema_util.add_non_redundant_schema","title":"<code>add_non_redundant_schema(schema, schemas)</code>","text":"<p>Method to add a schema to a list of schemas if it is not already in the list.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Identifiable]</code> <p>The schema to add.</p> required <code>schemas</code> <code>List[Type[Identifiable]]</code> <p>The list of schemas.</p> required Source code in <code>aas_middleware\\model\\schema_util.py</code> <pre><code>def add_non_redundant_schema(schema: Type[Identifiable], schemas: List[Type[Identifiable]]):\n    \"\"\"\n    Method to add a schema to a list of schemas if it is not already in the list.\n\n    Args:\n        schema (Type[Identifiable]): The schema to add.\n        schemas (List[Type[Identifiable]]): The list of schemas.\n    \"\"\"\n    if schema not in schemas:\n        schemas.append(schema)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.schema_util.get_all_contained_schemas","title":"<code>get_all_contained_schemas(schema)</code>","text":"<p>Method to iterate over an Identifiable model and get all contained Identifiables.</p> <p>Parameters:</p> Name Type Description Default <code>schema(Type(Identifiable))</code> <p>The referable data model.</p> required <p>Returns:</p> Type Description <code>List[Referable]</code> <p>The list of referables.</p> Source code in <code>aas_middleware\\model\\schema_util.py</code> <pre><code>def get_all_contained_schemas(schema: Type[Identifiable]) -&gt; List[Type[Identifiable]]:\n    \"\"\"\n    Method to iterate over an Identifiable model and get all contained Identifiables.\n\n    Args:\n        schema(Type(Identifiable)): The referable data model.\n\n    Returns:\n        List[Referable]: The list of referables.\n    \"\"\"\n    contained_schemas = []\n    identifiable_schema_attributes = get_identifiable_attributes(schema)\n    for identifiable_schema_attribute in identifiable_schema_attributes.values():\n        in_attribute_contained_identifiable_schema = get_all_contained_schemas(\n            identifiable_schema_attribute\n        )\n        for schema_attribute in in_attribute_contained_identifiable_schema:\n            add_non_redundant_schema(schema_attribute, contained_schemas)\n    if is_identifiable_type_container(schema):\n        for item in typing.get_args(schema):\n            in_attribute_contained_identifiable_schema = get_all_contained_schemas(item)\n            for schema_attribute in in_attribute_contained_identifiable_schema:\n                add_non_redundant_schema(schema_attribute, contained_schemas)\n    elif is_identifiable_type(schema):\n        add_non_redundant_schema(schema, contained_schemas)\n    return contained_schemas\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.schema_util.get_attribute_dict_of_schema","title":"<code>get_attribute_dict_of_schema(schema)</code>","text":"<p>Method to get all attributes of a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[Identifiable]</code> <p>The referable data model.</p> required <p>Returns:</p> Type Description <code>Dict[str, Type[Identifiable]]</code> <p>The dictionary of attributes.</p> Source code in <code>aas_middleware\\model\\schema_util.py</code> <pre><code>def get_attribute_dict_of_schema(schema: Type[Identifiable]) -&gt; Dict[str, Type[Identifiable]]:\n    \"\"\"\n    Method to get all attributes of a model.\n\n    Args:\n        model (Type[Identifiable]): The referable data model.\n\n    Returns:\n        Dict[str, Type[Identifiable]]: The dictionary of attributes.\n    \"\"\"\n    attribute_dict = {}\n    if not isinstance(schema, type):\n        return attribute_dict\n    if issubclass(schema, BaseModel):\n        for field_name, field in schema.model_fields.items():\n            attribute_dict[field_name] = field.annotation\n    else:\n        annotations = typing.get_type_hints(schema.__init__)\n        for parameter_name, parameter in annotations.items():\n            attribute_dict[parameter_name] = parameter\n    return attribute_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.schema_util.get_identifiable_attributes","title":"<code>get_identifiable_attributes(schema)</code>","text":"<p>Method to get all attributes of a model.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Identifiable]</code> <p>The referable data model.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of attributes.</p> Source code in <code>aas_middleware\\model\\schema_util.py</code> <pre><code>def get_identifiable_attributes(schema: Type[Identifiable]) -&gt; Dict[str, Type[Identifiable]]:\n    \"\"\"\n    Method to get all attributes of a model.\n\n    Args:\n        schema (Type[Identifiable]): The referable data model.\n\n    Returns:\n        List[str]: The list of attributes.\n    \"\"\"\n    schema_attributes = get_attribute_dict_of_schema(schema)\n    identifiable_attributes = {}\n    for attribute_name, attribute_type in schema_attributes.items():\n        if is_identifiable_type(attribute_type) or is_identifiable_type_container(attribute_type):\n            identifiable_attributes[attribute_name] = attribute_type\n\n    return identifiable_attributes\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util","title":"<code>util</code>","text":""},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.add_non_redundant_identifiable","title":"<code>add_non_redundant_identifiable(model, identifiables)</code>","text":"<p>Method to add an Identifiable to a list of Identifiables if it is not already in the list.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The Identifiable to add.</p> required <code>identifiables</code> <code>List[Identifiable]</code> <p>The list of contained Identifiables.</p> required <p>Returns:</p> Type Description <code>List[Identifiable]</code> <p>The list of Identifiables with the added model.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def add_non_redundant_identifiable(\n    model: Identifiable, identifiables: List[Identifiable]\n) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to add an Identifiable to a list of Identifiables if it is not already in the list.\n\n    Args:\n        model (Identifiable): The Identifiable to add.\n        identifiables (List[Identifiable]): The list of contained Identifiables.\n\n    Returns:\n        List[Identifiable]: The list of Identifiables with the added model.\n    \"\"\"\n    # TODO: maybe use directly a dict here to avoid iteration by using hashable ids\n    if not any(\n        get_id_with_patch(model) == get_id_with_patch(other_referable)\n        for other_referable in identifiables\n    ):\n        identifiables.append(model)\n    return identifiables\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.convert_camel_case_to_underscrore_str","title":"<code>convert_camel_case_to_underscrore_str(came_case_string)</code>","text":"<p>Convert a camel case string to an underscore seperated string.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The camel case string to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The underscore seperated string.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def convert_camel_case_to_underscrore_str(came_case_string: str) -&gt; str:\n    \"\"\"\n    Convert a camel case string to an underscore seperated string.\n\n    Args:\n        class_name (str): The camel case string to convert.\n\n    Returns:\n        str: The underscore seperated string.\n    \"\"\"\n    came_case_string = came_case_string[0].lower() + came_case_string[1:]\n    new_class_name = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", came_case_string).lower()\n    if all(len(el) == 1 for el in new_class_name.split(\"_\")):\n        new_class_name = new_class_name.replace(\"_\", \"\")\n    return new_class_name\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.convert_to_fitting_identifiable_container_type","title":"<code>convert_to_fitting_identifiable_container_type(list_container, container_type)</code>","text":"<p>Function to convert a list of identifiables to a fitting container type.</p> <p>Parameters:</p> Name Type Description Default <code>list_container</code> <code>List[Identifiable]</code> <p>The list of identifiables.</p> required <code>container_type</code> <code>Type[Any]</code> <p>The container type.</p> required <p>Returns:</p> Type Description <code>List[Identifiable] | Tuple[Identifiable] | Set[Identifiable]</code> <p>The container type.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def convert_to_fitting_identifiable_container_type(list_container: List[Identifiable], container_type: Type[Any]) -&gt; List[Identifiable] | Tuple[Identifiable] | Set[Identifiable]:\n    \"\"\"\n    Function to convert a list of identifiables to a fitting container type.\n\n    Args:\n        list_container (List[Identifiable]): The list of identifiables.\n        container_type (Type[Any]): The container type.\n\n    Returns:\n        List[Identifiable] | Tuple[Identifiable] | Set[Identifiable]: The container type.\n    \"\"\"\n    if container_type == list:\n        return list_container\n    elif container_type == tuple:\n        return tuple(list_container)\n    elif container_type == set:\n        return set(list_container)\n    else:\n        raise ValueError(\"Container type not supported.\")\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.convert_under_score_to_camel_case_str","title":"<code>convert_under_score_to_camel_case_str(underscore_str)</code>","text":"<p>Convert a underscore seperated string to a camel case string.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The underscore seperated string to convert.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The camel case string.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def convert_under_score_to_camel_case_str(underscore_str: str) -&gt; str:\n    \"\"\"\n    Convert a underscore seperated string to a camel case string.\n\n    Args:\n        class_name (str): The underscore seperated string to convert.\n\n    Returns:\n        str: The camel case string.\n    \"\"\"\n    words = underscore_str.split(\"_\")\n    camel_case_str = \"\".join(word[0].capitalize() + word[1:] for word in words)\n    return camel_case_str\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_all_contained_identifiables","title":"<code>get_all_contained_identifiables(model)</code>","text":"<p>Method to iterate over an Identifiable model and get all contained Identifiables.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>REFERABLE_DATA_MODEL</code> <p>The referable data model.</p> required <p>Returns:</p> Type Description <code>List[Referable]</code> <p>The list of referables.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_all_contained_identifiables(model: Identifiable) -&gt; List[Identifiable]:\n    \"\"\"\n    Method to iterate over an Identifiable model and get all contained Identifiables.\n\n    Args:\n        model (REFERABLE_DATA_MODEL): The referable data model.\n\n    Returns:\n        List[Referable]: The list of referables.\n    \"\"\"\n    contained_identifiables = []\n    identifiable_attributes = get_identifiable_attributes_of_model(model)\n    for identifiable_attribute in identifiable_attributes:\n        in_attribute_contained_identifiables = get_all_contained_identifiables(\n            identifiable_attribute\n        )\n        for identifiable in in_attribute_contained_identifiables:\n            add_non_redundant_identifiable(identifiable, contained_identifiables)\n    if is_identifiable_container(model):\n        for item in model:\n            in_attribute_contained_identifiables = get_all_contained_identifiables(item)\n            for identifiable in in_attribute_contained_identifiables:\n                add_non_redundant_identifiable(identifiable, contained_identifiables)\n    elif is_identifiable(model):\n        add_non_redundant_identifiable(model, contained_identifiables)\n    return contained_identifiables\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_attribute_name_encoded_references","title":"<code>get_attribute_name_encoded_references(model)</code>","text":"<p>Function to get the referenced ids of a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Referable</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The referenced ids.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_attribute_name_encoded_references(model: Identifiable) -&gt; List[str]:\n    \"\"\"\n    Function to get the referenced ids of a model.\n\n    Args:\n        model (Referable): The model.\n\n    Returns:\n        List[str]: The referenced ids.\n    \"\"\"\n    referenced_ids = []\n    for attribute_name, attribute_value in vars(model).items():\n        if (\n            attribute_name in STANDARD_AAS_FIELDS\n            or attribute_name in REFERENCE_ATTRIBUTE_NAMES_SUFFIXES\n        ):\n            continue\n        if not any(\n            attribute_name.endswith(suffix)\n            for suffix in REFERENCE_ATTRIBUTE_NAMES_SUFFIXES\n        ):\n            continue\n        if isinstance(attribute_value, str | int | UUID):\n            referenced_ids.append(str(attribute_value))\n        else:\n            referenced_ids += [str(item) for item in attribute_value if item]\n    return referenced_ids\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_id","title":"<code>get_id(model)</code>","text":"<p>Function to get the id attribute of an arbitrary model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>Optional[str | int | UUID]</code> <p>The id attribute.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if the model is not an object, BaseModel or dict or if no id attribute is available</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_id(model: Any) -&gt; str | int | UUID:\n    \"\"\"\n    Function to get the id attribute of an arbitrary model.\n\n    Args:\n        model (Any): The model.\n\n    Returns:\n        Optional[str | int | UUID]: The id attribute.\n\n    Raises:\n        ValueError: if the model is not an object, BaseModel or dict or if no id attribute is available\n    \"\"\"\n    if not is_identifiable(model):\n        raise ValueError(\"Model is a basic type and has no id attribute.\")\n\n    if isinstance(model, BaseModel):\n        identifiable_fields = get_identifier_type_fields(model.model_fields)\n        if len(identifiable_fields) &gt; 1:\n            raise ValueError(f\"Model has multiple Identifier attributes: {model}\")\n        if identifiable_fields:\n            return getattr(model, identifiable_fields[0])\n    elif hasattr(model, \"__dict__\"):\n        # TODO: use typing.get_type_hints instead of inspect.signature\n        sig = inspect.signature(type(model).__init__)\n        potential_identifier = []\n        for param in sig.parameters.values():\n            if param.annotation == Identifier or param.annotation == \"Identifier\":\n                potential_identifier.append(param.name)\n        if len(potential_identifier) &gt; 1:\n            raise ValueError(f\"Model {model} has multiple Identifier attributes.\")\n        if potential_identifier:\n            return getattr(model, potential_identifier[0])\n\n    if isinstance(model, BaseModel):\n        data = model.model_dump()\n    elif isinstance(model, dict):\n        data = model\n    else:\n        data = vars(model)\n    potential_id_attributes = [\n        \"id\",\n        \"id_short\",\n        \"Id\",\n        \"ID\",\n        \"Identifier\",\n        \"identifier\",\n        \"Identity\",\n        \"identity\",\n    ]\n    for id_attribute in potential_id_attributes:\n        if id_attribute in data and isinstance(data[id_attribute], str | int | UUID):\n            return data[id_attribute]\n\n    raise ValueError(\n        f\"Model {model} has no attribute that can be used as id attribute.\"\n    )\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_id_with_patch","title":"<code>get_id_with_patch(model)</code>","text":"<p>Function to get the id attribute of an arbitrary model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>Optional[str | int | UUID]</code> <p>The id attribute.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_id_with_patch(model: Any) -&gt; str:\n    \"\"\"\n    Function to get the id attribute of an arbitrary model.\n\n    Args:\n        model (Any): The model.\n\n    Returns:\n        Optional[str | int | UUID]: The id attribute.\n    \"\"\"\n    if not is_identifiable(model):\n        raise ValueError(\"Not identifiable object supplied.\")\n    try:\n        return str(get_id(model))\n    except ValueError:\n        return \"id_\" + str(id(model))\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_identifier_type_fields","title":"<code>get_identifier_type_fields(field_info_dict)</code>","text":"<p>Function to get the fields of a model that are of type Identifier.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>A Basemodel that is checked for identifier fields</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The field names that are Identifiers</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_identifier_type_fields(field_info_dict: Dict[str, FieldInfo]) -&gt; List[str]:\n    \"\"\"\n    Function to get the fields of a model that are of type Identifier.\n\n    Args:\n        model (BaseModel): A Basemodel that is checked for identifier fields\n\n    Returns:\n        List[str]: The field names that are Identifiers\n    \"\"\"\n    model_fields = []\n    for field_name, field_info in field_info_dict.items():\n        if field_info.annotation == Identifier:\n            model_fields.append(field_name)\n    return model_fields\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_reference_name","title":"<code>get_reference_name(attribute_name, attribute_type)</code>","text":"<p>Function to get the reference name of an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>The attribute name.</p> required <code>attribute_type</code> <code>Type[Any]</code> <p>The type of the attribute.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the referenced type.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_reference_name(attribute_name: str, attribute_type: Type[Any]) -&gt; Optional[str]:\n    \"\"\"\n    Function to get the reference name of an attribute.\n\n    Args:\n        attribute_name (str): The attribute name.\n        attribute_type (Type[Any]): The type of the attribute.\n\n    Returns:\n        str: The name of the referenced type.\n    \"\"\"\n    if attribute_name in REFERENCE_ATTRIBUTE_NAMES_SUFFIXES or attribute_name in STANDARD_AAS_FIELDS:\n        return \n\n    if attribute_type == Reference or attribute_type == \"Reference\":\n        return attribute_name\n    elif typing.get_origin(attribute_type) in [List, Set, Tuple, Union] and Reference in typing.get_args(attribute_type):\n        return attribute_name\n    elif any (attribute_name.endswith(suffix) for suffix in REFERENCE_ATTRIBUTE_NAMES_SUFFIXES):\n        suffix = next(suffix for suffix in REFERENCE_ATTRIBUTE_NAMES_SUFFIXES if attribute_name.endswith(suffix))\n        underscore_consideration = False\n        if attribute_name.endswith(f\"_{suffix}\"):\n            underscore_consideration = True\n        attribute_name_without_suffix = attribute_name[:-(len(suffix) + underscore_consideration)]\n        if attribute_name_without_suffix.endswith(\"s\") and not attribute_name_without_suffix.endswith(\"ss\"):\n            attribute_name_without_suffix = attribute_name_without_suffix[:-1]\n        return convert_under_score_to_camel_case_str(attribute_name_without_suffix)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_referenced_ids_of_model","title":"<code>get_referenced_ids_of_model(model)</code>","text":"<p>Function to get the referenced ids of a model by searching for type Reference and attribute names which suggest references.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Referable</code> <p>The model to get the references from.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The referenced ids.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_referenced_ids_of_model(model: Identifiable) -&gt; Set[str]:\n    \"\"\"\n    Function to get the referenced ids of a model by searching for type Reference and attribute names which suggest references.\n\n    Args:\n        model (Referable): The model to get the references from.\n\n    Returns:\n        List[str]: The referenced ids.\n    \"\"\"\n    referenced_ids = []\n    if isinstance(model, BaseModel):\n        referenced_ids += get_references_of_reference_type_for_basemodel(model)\n    elif hasattr(model, \"__dict__\"):\n        referenced_ids += get_references_of_reference_type_for_object(model)\n    referenced_ids += get_attribute_name_encoded_references(model)\n    return set(referenced_ids)\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_references_of_reference_type_for_basemodel","title":"<code>get_references_of_reference_type_for_basemodel(model)</code>","text":"<p>Function to get the references of a model that are of type Reference.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The reference fields.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_references_of_reference_type_for_basemodel(model: BaseModel) -&gt; List[str]:\n    \"\"\"\n    Function to get the references of a model that are of type Reference.\n\n    Args:\n        model (BaseModel): The model.\n\n    Returns:\n        List[str]: The reference fields.\n    \"\"\"\n    references = []\n    for field_name, field_info in model.model_fields.items():\n        if field_info.annotation == Reference or field_info.annotation == \"Reference\":\n            references.append(getattr(model, field_name))\n        if field_info.annotation == List[Reference]:\n            references += getattr(model, field_name)\n    return [str(ref) for ref in references if ref]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_references_of_reference_type_for_object","title":"<code>get_references_of_reference_type_for_object(model)</code>","text":"<p>Function to get the references of a model that are of type Reference.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The reference fields.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_references_of_reference_type_for_object(model: object) -&gt; List[str]:\n    \"\"\"\n    Function to get the references of a model that are of type Reference.\n\n    Args:\n        model (BaseModel): The model.\n\n    Returns:\n        List[str]: The reference fields.\n    \"\"\"\n    references = []\n    sig = inspect.signature(type(model).__init__)\n    for param in sig.parameters.values():\n        if param.annotation == Reference:\n            references.append(getattr(model, param.name))\n        if param.annotation == List[Reference]:\n            references += getattr(model, param.name)\n    return [str(ref) for ref in references if ref]\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.get_value_attributes","title":"<code>get_value_attributes(obj)</code>","text":"<p>Function to get an dict of all attributes of an object without the private attributes and standard AAS attributes.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The value attributes.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def get_value_attributes(obj: object) -&gt; Dict[str, Any]:\n    \"\"\"\n    Function to get an dict of all attributes of an object without the private attributes and standard AAS attributes.\n\n    Args:\n        obj (object): The object.\n\n    Returns:\n        dict: The value attributes.\n    \"\"\"\n    vars_dict = {}\n    object_id = get_id_with_patch(obj)\n\n    for attribute_name, attribute_value in vars(obj).items():\n        if attribute_name.startswith(\"_\"):\n            continue\n        if attribute_name in STANDARD_AAS_FIELDS:\n            continue\n        if attribute_value == object_id:\n            continue\n        if attribute_value is None:\n            continue\n        vars_dict[attribute_name] = attribute_value\n    return vars_dict\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.is_identifiable","title":"<code>is_identifiable(model)</code>","text":"<p>Function to check if a model is identifiable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the model is identifiable, False otherwise.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def is_identifiable(model: Any) -&gt; bool:\n    \"\"\"\n    Function to check if a model is identifiable.\n\n    Args:\n        model (Any): The model.\n\n    Returns:\n        bool: True if the model is identifiable, False otherwise.\n    \"\"\"\n    if isinstance(model, UnIdentifiable):\n        return False\n    return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.is_identifiable_container","title":"<code>is_identifiable_container(model)</code>","text":"<p>Function to check if a model is an identifiable container.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The model.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the model is an identifiable container, False otherwise.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def is_identifiable_container(model: Any) -&gt; bool:\n    \"\"\"\n    Function to check if a model is an identifiable container.\n\n    Args:\n        model (Any): The model.\n\n    Returns:\n        bool: True if the model is an identifiable container, False otherwise.\n    \"\"\"\n    if not isinstance(model, list | tuple | set | dict):\n        return False\n    if isinstance(model, list | tuple | set) and not all(\n        is_identifiable(element) for element in model\n    ):\n        return False\n    return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.is_identifiable_type","title":"<code>is_identifiable_type(schema)</code>","text":"<p>Function to check if a schema is identifiable.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Any]</code> <p>The schema.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the schema is identifiable, False otherwise.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def is_identifiable_type(schema: Type[Any]) -&gt; bool:\n    \"\"\"\n    Function to check if a schema is identifiable.\n\n    Args:\n        schema (Type[Any]): The schema.\n\n    Returns:\n        bool: True if the schema is identifiable, False otherwise.\n    \"\"\"\n    # TODO: refactor to combine is_identifiable and is_identifiable_type\n    # TODO: handle here also union types\n    if not isinstance(schema, type):\n        return False\n    if issubclass(schema, UnIdentifiable):\n        return False\n    return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.is_identifiable_type_container","title":"<code>is_identifiable_type_container(schema)</code>","text":"<p>Method to check if a schema is a container of identifiables.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Type[Any]</code> <p>The schema.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the schema is a container of identifiables, False otherwise.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def is_identifiable_type_container(schema: Type[Any]) -&gt; bool:\n    \"\"\"\n    Method to check if a schema is a container of identifiables.\n\n    Args:\n        schema (Type[Any]): The schema.\n\n    Returns:\n        bool: True if the schema is a container of identifiables, False otherwise.\n    \"\"\"\n    # TODO: refactor to combine is_identifiable_container and is_identifiable_type_container\n    if typing.get_origin(schema):\n        outer_type = typing.get_origin(schema)\n    else:\n        outer_type = schema\n\n    if not outer_type in [list,  tuple, set, dict, Union]:\n        return False\n    if outer_type == dict:\n        raise NotImplementedError(\"Dicts are not supported yet. Try using classes instead.\")\n    type_arguments = get_identifiable_types(schema)\n    if not type_arguments:\n        return False\n    type_arguments_with_none = [arg for arg in type_arguments if arg != NoneType]\n    if not all(is_identifiable_type(element) for element in type_arguments_with_none):\n        return False\n    return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.models_are_equal","title":"<code>models_are_equal(model1, model2)</code>","text":"<p>Function to compare two models for equality.</p> <p>Parameters:</p> Name Type Description Default <code>model1</code> <code>Identifiable</code> <p>The first model.</p> required <code>model2</code> <code>Identifiable</code> <p>The second model.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the models are equal, False otherwise.</p> Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def models_are_equal(model1: Identifiable, model2: Identifiable) -&gt; bool:\n    \"\"\"\n    Function to compare two models for equality.\n\n    Args:\n        model1 (Identifiable): The first model.\n        model2 (Identifiable): The second model.\n\n    Returns:\n        bool: True if the models are equal, False otherwise.\n    \"\"\"\n    model1_attributes = get_value_attributes(model1)\n    model2_attributes = get_value_attributes(model2)\n    if set(model1_attributes.keys()) != set(model2_attributes.keys()):\n        return False\n    for attribute_name1, attribute_value1 in model1_attributes.items():\n        if is_identifiable(attribute_value1):\n            if not models_are_equal(\n                attribute_value1, model2_attributes[attribute_name1]\n            ):\n                return False\n        elif is_identifiable_container(attribute_value1):\n            if not is_identifiable_container(model2_attributes[attribute_name1]):\n                return False\n            if not len(attribute_value1) == len(model2_attributes[attribute_name1]):\n                return False\n            if not all(\n                models_are_equal(item1, item2)\n                for item1, item2 in zip(\n                    attribute_value1, model2_attributes[attribute_name1]\n                )\n            ):\n                return False\n        elif attribute_value1 != model2_attributes[attribute_name1]:\n            return False\n    return True\n</code></pre>"},{"location":"API_reference/API_reference_1_model/#aas_middleware.model.util.replace_attribute_with_model","title":"<code>replace_attribute_with_model(model, existing_model)</code>","text":"<p>Function to replace an attribute with a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Identifiable</code> <p>The model.</p> required <code>existing_model</code> <code>Identifiable</code> <p>The existing model.</p> required Source code in <code>aas_middleware\\model\\util.py</code> <pre><code>def replace_attribute_with_model(model: Identifiable, existing_model: Identifiable):\n    \"\"\"\n    Function to replace an attribute with a model.\n\n    Args:\n        model (Identifiable): The model.\n        existing_model (Identifiable): The existing model.\n    \"\"\"\n    for attribute_name, attribute_value in vars(model).items():\n        if is_identifiable(attribute_value):\n            if attribute_value == existing_model:\n                setattr(model, attribute_name, existing_model)\n            else:\n                replace_attribute_with_model(attribute_value, existing_model)\n        elif is_identifiable_container(attribute_value):\n            list_attribute_value = list(attribute_value)\n            for i, item in enumerate(list_attribute_value):\n                if item == existing_model:\n                    list_attribute_value[i] = existing_model\n                else:\n                    replace_attribute_with_model(item, existing_model)\n            setattr(model, attribute_name, convert_to_fitting_identifiable_container_type(list_attribute_value, type(attribute_value)))\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/","title":"Middleware","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.aas_persistence_middleware","title":"<code>aas_persistence_middleware</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.aas_persistence_middleware.AasMiddleware","title":"<code> AasMiddleware            (Middleware)         </code>","text":"<p>Middleware that automatically that has aas and submodel repositories as persistence providers and consumers.</p> Source code in <code>aas_middleware\\middleware\\aas_persistence_middleware.py</code> <pre><code>class AasMiddleware(Middleware):\n    \"\"\"\n    Middleware that automatically that has aas and submodel repositories as persistence providers and consumers.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def load_aas_persistent_data_model(self, name: str, data_model: DataModel, aas_host: str, aas_port: int, submodel_host: str, submodel_port: int, initial_loading: bool = False):\n        \"\"\"\n        Function to load a data model into the middleware to be used for synchronization.\n\n        Args:\n            name (str): The name of the data model.\n            data_model (DataModel): Data model containing the types and values.\n            aas_host (str): The host of the AAS server.\n            aas_port (int): The port of the AAS server.\n            submodel_host (str): The host of the submodel server.\n            submodel_port (int): The port of the submodel server.\n        \"\"\"\n        # aas_data_model = DataModelRebuilder(data_model).rebuild_data_model_for_AAS_structure()\n        aas_data_model = data_model\n        self.load_data_model(name, aas_data_model)\n\n        aas_persistence_factory = PersistenceFactory(BasyxAASConnector, host=aas_host, port=aas_port, submodel_host=submodel_host, submodel_port=submodel_port)\n        submodel_persistence_factory = PersistenceFactory(BasyxSubmodelConnector, host=submodel_host, port=submodel_port)\n        self.add_default_persistence(aas_persistence_factory, name, None, AAS)\n        self.add_default_persistence(submodel_persistence_factory, name, None, Submodel)\n\n        if initial_loading:\n            for models_of_type in aas_data_model.get_top_level_models().values():\n                if not models_of_type:\n                    continue\n                model = models_of_type[0]\n\n                for model in models_of_type:\n                    self.add_callback(\"on_start_up\", self.persist, name, model)\n\n        self.generate_rest_api_for_data_model(name)\n\n    def scan_aas_server(self):\n        \"\"\"\n        Function to scan the AAS server for all available AAS and Submodels.\n        \"\"\"\n        # TODO: implement function\n        pass\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.aas_persistence_middleware.AasMiddleware.load_aas_persistent_data_model","title":"<code>load_aas_persistent_data_model(self, name, data_model, aas_host, aas_port, submodel_host, submodel_port, initial_loading=False)</code>","text":"<p>Function to load a data model into the middleware to be used for synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data model.</p> required <code>data_model</code> <code>DataModel</code> <p>Data model containing the types and values.</p> required <code>aas_host</code> <code>str</code> <p>The host of the AAS server.</p> required <code>aas_port</code> <code>int</code> <p>The port of the AAS server.</p> required <code>submodel_host</code> <code>str</code> <p>The host of the submodel server.</p> required <code>submodel_port</code> <code>int</code> <p>The port of the submodel server.</p> required Source code in <code>aas_middleware\\middleware\\aas_persistence_middleware.py</code> <pre><code>def load_aas_persistent_data_model(self, name: str, data_model: DataModel, aas_host: str, aas_port: int, submodel_host: str, submodel_port: int, initial_loading: bool = False):\n    \"\"\"\n    Function to load a data model into the middleware to be used for synchronization.\n\n    Args:\n        name (str): The name of the data model.\n        data_model (DataModel): Data model containing the types and values.\n        aas_host (str): The host of the AAS server.\n        aas_port (int): The port of the AAS server.\n        submodel_host (str): The host of the submodel server.\n        submodel_port (int): The port of the submodel server.\n    \"\"\"\n    # aas_data_model = DataModelRebuilder(data_model).rebuild_data_model_for_AAS_structure()\n    aas_data_model = data_model\n    self.load_data_model(name, aas_data_model)\n\n    aas_persistence_factory = PersistenceFactory(BasyxAASConnector, host=aas_host, port=aas_port, submodel_host=submodel_host, submodel_port=submodel_port)\n    submodel_persistence_factory = PersistenceFactory(BasyxSubmodelConnector, host=submodel_host, port=submodel_port)\n    self.add_default_persistence(aas_persistence_factory, name, None, AAS)\n    self.add_default_persistence(submodel_persistence_factory, name, None, Submodel)\n\n    if initial_loading:\n        for models_of_type in aas_data_model.get_top_level_models().values():\n            if not models_of_type:\n                continue\n            model = models_of_type[0]\n\n            for model in models_of_type:\n                self.add_callback(\"on_start_up\", self.persist, name, model)\n\n    self.generate_rest_api_for_data_model(name)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.aas_persistence_middleware.AasMiddleware.scan_aas_server","title":"<code>scan_aas_server(self)</code>","text":"<p>Function to scan the AAS server for all available AAS and Submodels.</p> Source code in <code>aas_middleware\\middleware\\aas_persistence_middleware.py</code> <pre><code>def scan_aas_server(self):\n    \"\"\"\n    Function to scan the AAS server for all available AAS and Submodels.\n    \"\"\"\n    # TODO: implement function\n    pass\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.connector_router","title":"<code>connector_router</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.connector_router.generate_connector_endpoint","title":"<code>generate_connector_endpoint(connector_id, connector, model_type)</code>","text":"<p>Generates endpoints for a workflow to execute the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>Workflow that contains the function to be executed by the workflow.</p> required <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with an endpoint to execute the workflow.</p> Source code in <code>aas_middleware\\middleware\\connector_router.py</code> <pre><code>def generate_connector_endpoint(connector_id: str, connector: Union[Consumer, Provider, Connector], model_type: Type[Any]) -&gt; List[APIRouter]:\n    \"\"\"\n    Generates endpoints for a workflow to execute the workflow.\n\n    Args:\n        workflow (Workflow): Workflow that contains the function to be executed by the workflow.\n\n    Returns:\n        APIRouter: FastAPI router with an endpoint to execute the workflow.\n    \"\"\"\n    router = APIRouter(\n        prefix=f\"/connectors/{connector_id}\",\n        tags=[\"connectors\"],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.get(\"/description\", response_model=ConnectorDescription)\n    async def describe_connector():\n        return ConnectorDescription(\n            connector_id=connector_id,\n            connector_type=type(connector).__name__,\n            persistence_connection=None,\n            model_type=model_type.__name__\n        )\n\n    if isinstance(connector, Consumer):\n        @router.post(\"/value\", response_model=Dict[str, str])\n        async def set_value(value: model_type):\n            try:\n                await connector.consume(value)\n            except ConnectionError as e:\n                raise HTTPException(status_code=500, detail=str(e))\n            return {\"message\": f\"Set value for {connector_id}\"}\n\n    if isinstance(connector, Provider):\n        @router.get(\"/value\", response_model=model_type)\n        async def get_value():\n            try:\n                return await connector.provide()\n            except ConnectionError as e:\n                raise HTTPException(status_code=500, detail=str(e))\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.connector_router.generate_persistence_connector_endpoint","title":"<code>generate_persistence_connector_endpoint(connector_id, connector, connection_info, model_type)</code>","text":"<p>Generates endpoints for a workflow to execute the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>Workflow that contains the function to be executed by the workflow.</p> required <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with an endpoint to execute the workflow.</p> Source code in <code>aas_middleware\\middleware\\connector_router.py</code> <pre><code>def generate_persistence_connector_endpoint(connector_id: str, connector: Union[Consumer, Provider, Connector], connection_info: ConnectionInfo, model_type: Type[Any]) -&gt; List[APIRouter]:\n    \"\"\"\n    Generates endpoints for a workflow to execute the workflow.\n\n    Args:\n        workflow (Workflow): Workflow that contains the function to be executed by the workflow.\n\n    Returns:\n        APIRouter: FastAPI router with an endpoint to execute the workflow.\n    \"\"\"\n    router = APIRouter(\n        prefix=f\"/connectors/{connector_id}\",\n        tags=[\"connectors\"],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.get(\"/description\", response_model=ConnectorDescription)\n    async def describe_connector():\n        return ConnectorDescription(\n            connector_id=connector_id,\n            connector_type=type(connector).__name__,\n            persistence_connection=connection_info,\n            model_type=model_type.__name__\n        )\n\n    if isinstance(connector, Consumer):\n        @router.post(\"/value\", response_model=Dict[str, str])\n        async def set_value(value: Optional[model_type]=None):\n            try:\n                await connector.consume(value)\n            except ConnectionError as e:\n                raise HTTPException(status_code=500, detail=str(e))\n            if not value:\n                return {\"message\": f\"Set for {connector_id} persistence value.\"}\n            return {\"message\": f\"Set for {connector_id} value {value}\"}\n\n    if isinstance(connector, Provider):\n        @router.get(\"/value\", response_model=model_type)\n        async def get_value():\n            try:\n                return await connector.provide()\n            except ConnectionError as e:\n                raise HTTPException(status_code=500, detail=str(e))\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware","title":"<code>middleware</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware","title":"<code> Middleware        </code>","text":"<p>Middleware that can be used to generate a REST or GraphQL API from aas' and submodels either in pydanctic models or in aas object store format.</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>class Middleware:\n    \"\"\"\n    Middleware that can be used to generate a REST or GraphQL API from aas' and submodels either in pydanctic models or in aas object store format.\n    \"\"\"\n\n    def __init__(self):\n        self._app: typing.Optional[FastAPI] = None\n        self.meta_data: MiddlewareMetaData = MiddlewareMetaData()\n\n        self.data_models: typing.Dict[str, DataModel] = {}\n\n        self.on_start_up_callbacks: typing.List[typing.Callable] = []\n        self.on_shutdown_callbacks: typing.List[typing.Callable] = []\n\n        self.persistence_registry: PersistenceConnectionRegistry = PersistenceConnectionRegistry()\n        self.connection_registry: ConnectionRegistry = ConnectionRegistry()\n        self.workflow_registry: WorkflowRegistry = WorkflowRegistry()\n\n    def set_meta_data(self, title: str, description: str, version: str, contact: typing.Dict[str, str]):\n        \"\"\"\n        Function to set the meta data of the middleware.\n\n        Args:\n            title (str): The title of the middleware.\n            description (str): The description of the middleware.\n            version (str): The version of the middleware.\n            contact (typing.Dict[str, str]): The contact information of the middleware.\n            license_info (typing.Dict[str, str]): The license information of the middleware.\n        \"\"\"\n        self.meta_data = MiddlewareMetaData(\n            title=title,\n            description=description,\n            version=version,\n            contact=contact\n        )\n\n    def add_callback(self, callback_type: typing.Literal[\"on_start_up\", \"on_shutdown\"], callback: typing.Callable, *args, **kwargs):\n        \"\"\"\n        Function to add a callback to the middleware.\n\n        Args:\n            callback_type (typing.Literal[\"on_start_up\", \"on_shutdown\"]): The type of the callback.\n            callback (typing.Callable): The callback function.\n        \"\"\"\n        functional_callback = partial(callback, *args, **kwargs)\n        if callback_type == \"on_start_up\":\n            self.on_start_up_callbacks.append(functional_callback)\n        elif callback_type == \"on_shutdown\":\n            self.on_shutdown_callbacks.append(functional_callback)\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        \"\"\"\n        Function to create a lifespan for the middleware for all events on startup and shutdown.\n\n        Args:\n            app (FastAPI): The FastAPI app that should be used for the lifespan.\n        \"\"\"\n        for workflow in self.workflow_registry.get_workflows():\n            if workflow.on_startup:\n                # TODO: make a case distinction for workflows that postpone start up or not...\n                asyncio.create_task(workflow.execute())\n        for callback in self.on_start_up_callbacks:\n            await callback()\n        for connector in self.connection_registry.connectors.values():\n            await connector.connect()\n        for persistence in self.persistence_registry.connectors.values():\n            await persistence.connect()\n        yield\n        for workflow in self.workflow_registry.get_workflows():\n            if workflow.on_shutdown:\n                if workflow.running:\n                    await workflow.interrupt()\n                await workflow.execute()\n\n        for callback in self.on_shutdown_callbacks:\n            await callback()\n\n        for connector in self.connection_registry.connectors.values():\n            await connector.disconnect()\n        for persistence in self.persistence_registry.connectors.values():\n            await persistence.disconnect()\n\n    @property\n    def app(self):\n        if not self._app:\n            app = FastAPI(\n                title=self.meta_data.title,\n                description=self.meta_data.description,\n                version=self.meta_data.version,\n                contact=self.meta_data.contact,\n                license_info={\n                    \"name\": \"MIT License\",\n                    \"url\": \"https://mit-license.org/\",\n                },\n                lifespan=self.lifespan\n            )\n\n            app.add_middleware(\n                # TODO: make CORS more sophisticated for individual connectors\n                CORSMiddleware,\n                allow_origins=[\"*\"],\n                allow_credentials=[\"*\"],\n                allow_methods=[\"*\"],\n                allow_headers=[\"*\"],\n            )\n            self._app = app\n\n            @app.get(\"/\", response_model=str)\n            async def root():\n                return \"Welcome to aas-middleware!\"\n\n        return self._app\n\n    def load_data_model(self, name: str, data_model: DataModel):\n        \"\"\"\n        Function to load a data model into the middleware to be used for synchronization.\n\n        Args:\n            name (str): The name of the data model.\n            data_model (DataModel): Data model containing the types and values.\n        \"\"\"\n        self.data_models[name] = data_model\n\n    def load_json_models(\n        self,\n        json_models: typing.Dict[str, typing.Any] = None,\n        all_fields_required: bool = False,\n    ):\n        \"\"\"\n        Functions that loads models from a json dict into the middleware that can be used for synchronization.\n\n        The function can either be used with a dict that contains the objects.\n\n        Args:\n            json_models (dict): Dictionary of aas' and submodels.\n            all_fields_required (bool): If all fields are required in the models.\n        \"\"\"\n        # TODO: use here the function to load a DataModel from a dict\n        # for model_name, model_values in json_models.items():\n        #     pydantic_model = get_pydantic_model_from_dict(\n        #         model_values, model_name, all_fields_required\n        #     )\n        #     self.models.append(pydantic_model)\n\n    def load_model_instances(self, name: str, instances: typing.List[BaseModel]):\n        \"\"\"\n        Functions that loads pydantic models into the middleware as a datamodel that can be used for synchronization.\n\n        Args:\n            name (str): The name of the data model.\n            instances (typing.List[BaseModel]): List of pydantic model instances.\n        \"\"\"\n        data_model = DataModel.from_models(*instances)\n        self.load_data_model(name, data_model)\n\n\n    def load_pydantic_models(self, name: str, *models: typing.Tuple[typing.Type[BaseModel]]):\n        \"\"\"\n        Functions that loads pydantic models into the middleware that can be used for synchronization.\n\n        Args:\n            models (typing.List[typing.Type[BaseModel]]): List of pydantic models.\n        \"\"\"\n        data_model = DataModel.from_model_types(models)\n        self.load_data_model(data_model)\n\n    def load_aas_objectstore(self, models: model.DictObjectStore):\n        \"\"\"\n        Functions that loads multiple aas and their submodels into the middleware that can be used for synchronization.\n\n        Args:\n            models (typing.List[model.DictObjectStore]): Object store of aas' and submodels\n        \"\"\"\n        data_model = BasyxFormatter().deserialize(models)\n        self.load_data_model(data_model)\n\n    async def update_value(self, value: typing.Any, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_name: typing.Optional[str]=None):\n        \"\"\"\n        Function to update a value in the persistence.\n\n        Args:\n            data_model_name (str): _description_\n            model_id (typing.Optional[str]): _description_\n            field_name (typing.Optional[str]): _description_\n            value (typing.Any): _description_\n        \"\"\"\n        connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_name)\n        try:\n            connector = self.persistence_registry.get_connection(connection_info)\n            await connector.consume(value)\n        except KeyError as e:\n            await self.persist(data_model_name, value)\n\n    async def get_value(self, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_name: typing.Optional[str]=None) -&gt; typing.Any:\n        \"\"\"\n        Function to get a value from the persistence.\n\n        Args:\n            data_model_name (str): _description_\n            model_id (typing.Optional[str]): _description_\n            field_name (typing.Optional[str]): _description_\n\n        Returns:\n            typing.Any: _description_\n        \"\"\"\n        connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_name)\n        try:\n            connector = self.persistence_registry.get_connection(connection_info)\n            return await connector.provide()\n        except KeyError:\n            raise KeyError(f\"No provider found for {connection_info}\")\n\n    def add_default_persistence(self, persistence_factory: PersistenceFactory, data_model_name: typing.Optional[str], model_id: typing.Optional[Identifiable], model_type: typing.Type[typing.Any] = typing.Any):\n        \"\"\"\n        Function to add a default persistence for a model.\n\n        Args:\n            data_model_name (str): The name of the data model.\n            model (Identifiable): The model that should be persisted.\n        \"\"\"\n        if not data_model_name in self.data_models:\n            raise ValueError(f\"No data model {data_model_name} found.\")\n\n        connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=None, field_id=None)\n        self.persistence_registry.add_persistence_factory(connection_info, model_type, persistence_factory)\n\n\n    async def persist(self, data_model_name: str, model: typing.Optional[Identifiable]=None, persistence_factory: typing.Optional[PersistenceFactory]=None):\n        \"\"\"\n        Function to add a model to the persistence.\n\n        Args:\n            data_model_name (str): The name of the data model.\n            model (Identifiable): The model that should be persisted.\n            persistence_factory (PersistenceFactory): The persistence factory that should be used.\n\n        Raises:\n            ValueError: If the connection already exists.\n        \"\"\"\n        connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model.id, contained_model_id=None, field_id=None)\n        if connection_info in self.persistence_registry.connections:\n            raise ValueError(f\"Connection {connection_info} already exists. Try using the existing connector or remove it first.\")\n        self.persistence_registry.add_to_persistence(connection_info, model, persistence_factory)\n        connector = self.persistence_registry.get_connection(connection_info)\n        # TODO: raise an error if consume is not possible and remove the persistence in the persistence registry\n        await connector.consume(model)\n\n\n    def add_connector(self, connector_id: str, connector: Connector, model_type: typing.Type[typing.Any], data_model_name: typing.Optional[str]=None, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_id: typing.Optional[str]=None):\n        \"\"\"\n        Function to add a connector to the middleware.\n\n        Args:\n            connector_id (str): The name of the connector.\n            connector (Connector): The connector that should be added.\n        \"\"\"\n        self.connection_registry.add_connector(connector_id, connector, model_type)\n        if data_model_name:\n            self.connect_connector_to_persistence(connector_id, data_model_name, model_id, contained_model_id, field_id)\n            self.generate_rest_endpoint_for_connector(connector_id, ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_id))\t\n        else:\n            self.generate_rest_endpoint_for_connector(connector_id)\n\n\n    def generate_rest_endpoint_for_connector(self, connector_id: str, connection_info: typing.Optional[ConnectionInfo]=None):\n        \"\"\"\n        Function to generate a REST endpoint for a connector.\n\n        Args:\n            connector_id (str): _description_\n            connection_info (typing.Optional[ConnectionInfo], optional): _description_. Defaults to None.\n\n        Raises:\n            ValueError: _description_\n        \"\"\"\n        if not connector_id in self.connection_registry.connectors:\n            raise ValueError(f\"Connector {connector_id} not found.\")\n        connector = self.connection_registry.get_connector(connector_id)\n        model_type = self.connection_registry.connection_types[connector_id]\n        if not connection_info:\n            router = generate_connector_endpoint(connector_id, connector, model_type)\n        else:\n            router = generate_persistence_connector_endpoint(connector_id, connector, connection_info, model_type)\n        self.app.include_router(router)\n\n\n    # TODO: handle also async connectors!!\n\n\n    def connect_connector_to_persistence(self, connector_id: str, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_id: typing.Optional[str]=None):\n        \"\"\"\n        Function to connect a connector to a data entity in the middleware.\n\n        Args:\n            connector_id (str): The name of the connector.\n            connector (Connector): The connector that should be connected.\n            data_model_name (str): The name of the data model used for identifying the data model in the middleware.\n            model_id (typing.Optional[str], optional): The id of the model in the data model. Defaults to None.\n            field_id (typing.Optional[str], optional): The id of the field in the model. Defaults to None.\n            model_type (typing.Type[typing.Any], optional): The type of the model. Defaults to typing.Any.\n        \"\"\"\n        connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_id)\n        connector = self.connection_registry.get_connector(connector_id)\n        type_connection_info = self.connection_registry.connection_types[connector_id]\n        self.connection_registry.add_connection(connector_id, connection_info, connector, type_connection_info)\n\n        synchronize_connector_with_persistence(connector, connection_info, self.persistence_registry)\n\n    def workflow(\n        self,\n        *args,\n        on_startup: bool = False,\n        on_shutdown: bool = False,\n        interval: typing.Optional[float] = None,\n        **kwargs\n    ):\n        def decorator(func):\n            workflow = Workflow.define(\n                func,\n                *args,\n                on_startup=on_startup,\n                on_shutdown=on_shutdown,\n                interval=interval,\n                **kwargs\n            )\n            self.workflow_registry.add_workflow(workflow)\n            workflows_app = generate_workflow_endpoint(workflow)\n            self.app.include_router(workflows_app)\n            return func\n\n        return decorator\n\n    def generate_model_registry_api(self):\n        \"\"\"\n        Adds a REST API so that new models can be registered and unregistered from the Middleware.\n        \"\"\"\n        router = generate_model_api(middleware_instance=self)\n        self.app.include_router(router)\n        NUM_REGISTRY_ROUTES = len(router.routes)\n        NUM_CONSTANT_ROUTES = 5\n        self.app.router.routes = (\n            self.app.router.routes[:NUM_CONSTANT_ROUTES]\n            + self.app.routes[-NUM_REGISTRY_ROUTES:]\n            + self.app.routes[NUM_CONSTANT_ROUTES:-NUM_REGISTRY_ROUTES]\n        )\n\n    def generate_rest_api_for_data_model(self, data_model_name: str):\n        \"\"\"\n        Generates a REST API with CRUD operations for aas' and submodels from the loaded models.\n        \"\"\"\n        data_model = self.data_models[data_model_name]\n        rest_router = RestRouter(data_model, data_model_name, self)\n        routers = rest_router.generate_endpoints()\n        for router in routers:\n            self.app.include_router(router)\n\n    # def generate_graphql_api(self):\n    #     \"\"\"\n    #     Generates a GraphQL API with query operations for aas' and submodels from the loaded models.\n    #     \"\"\"\n    #     graphql_app = generate_graphql_endpoint(self.models)\n    #     self.app.mount(\"/graphql\", graphql_app)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.add_callback","title":"<code>add_callback(self, callback_type, callback, *args, **kwargs)</code>","text":"<p>Function to add a callback to the middleware.</p> <p>Parameters:</p> Name Type Description Default <code>callback_type</code> <code>Literal[\"on_start_up\", \"on_shutdown\"]</code> <p>The type of the callback.</p> required <code>callback</code> <code>Callable</code> <p>The callback function.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def add_callback(self, callback_type: typing.Literal[\"on_start_up\", \"on_shutdown\"], callback: typing.Callable, *args, **kwargs):\n    \"\"\"\n    Function to add a callback to the middleware.\n\n    Args:\n        callback_type (typing.Literal[\"on_start_up\", \"on_shutdown\"]): The type of the callback.\n        callback (typing.Callable): The callback function.\n    \"\"\"\n    functional_callback = partial(callback, *args, **kwargs)\n    if callback_type == \"on_start_up\":\n        self.on_start_up_callbacks.append(functional_callback)\n    elif callback_type == \"on_shutdown\":\n        self.on_shutdown_callbacks.append(functional_callback)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.add_connector","title":"<code>add_connector(self, connector_id, connector, model_type, data_model_name=None, model_id=None, contained_model_id=None, field_id=None)</code>","text":"<p>Function to add a connector to the middleware.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>The name of the connector.</p> required <code>connector</code> <code>Connector</code> <p>The connector that should be added.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def add_connector(self, connector_id: str, connector: Connector, model_type: typing.Type[typing.Any], data_model_name: typing.Optional[str]=None, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_id: typing.Optional[str]=None):\n    \"\"\"\n    Function to add a connector to the middleware.\n\n    Args:\n        connector_id (str): The name of the connector.\n        connector (Connector): The connector that should be added.\n    \"\"\"\n    self.connection_registry.add_connector(connector_id, connector, model_type)\n    if data_model_name:\n        self.connect_connector_to_persistence(connector_id, data_model_name, model_id, contained_model_id, field_id)\n        self.generate_rest_endpoint_for_connector(connector_id, ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_id))\t\n    else:\n        self.generate_rest_endpoint_for_connector(connector_id)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.add_default_persistence","title":"<code>add_default_persistence(self, persistence_factory, data_model_name, model_id, model_type=typing.Any)</code>","text":"<p>Function to add a default persistence for a model.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>The name of the data model.</p> required <code>model</code> <code>Identifiable</code> <p>The model that should be persisted.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def add_default_persistence(self, persistence_factory: PersistenceFactory, data_model_name: typing.Optional[str], model_id: typing.Optional[Identifiable], model_type: typing.Type[typing.Any] = typing.Any):\n    \"\"\"\n    Function to add a default persistence for a model.\n\n    Args:\n        data_model_name (str): The name of the data model.\n        model (Identifiable): The model that should be persisted.\n    \"\"\"\n    if not data_model_name in self.data_models:\n        raise ValueError(f\"No data model {data_model_name} found.\")\n\n    connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=None, field_id=None)\n    self.persistence_registry.add_persistence_factory(connection_info, model_type, persistence_factory)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.connect_connector_to_persistence","title":"<code>connect_connector_to_persistence(self, connector_id, data_model_name, model_id=None, contained_model_id=None, field_id=None)</code>","text":"<p>Function to connect a connector to a data entity in the middleware.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>The name of the connector.</p> required <code>connector</code> <code>Connector</code> <p>The connector that should be connected.</p> required <code>data_model_name</code> <code>str</code> <p>The name of the data model used for identifying the data model in the middleware.</p> required <code>model_id</code> <code>Optional[str]</code> <p>The id of the model in the data model. Defaults to None.</p> <code>None</code> <code>field_id</code> <code>Optional[str]</code> <p>The id of the field in the model. Defaults to None.</p> <code>None</code> <code>model_type</code> <code>Type[Any]</code> <p>The type of the model. Defaults to typing.Any.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def connect_connector_to_persistence(self, connector_id: str, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_id: typing.Optional[str]=None):\n    \"\"\"\n    Function to connect a connector to a data entity in the middleware.\n\n    Args:\n        connector_id (str): The name of the connector.\n        connector (Connector): The connector that should be connected.\n        data_model_name (str): The name of the data model used for identifying the data model in the middleware.\n        model_id (typing.Optional[str], optional): The id of the model in the data model. Defaults to None.\n        field_id (typing.Optional[str], optional): The id of the field in the model. Defaults to None.\n        model_type (typing.Type[typing.Any], optional): The type of the model. Defaults to typing.Any.\n    \"\"\"\n    connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_id)\n    connector = self.connection_registry.get_connector(connector_id)\n    type_connection_info = self.connection_registry.connection_types[connector_id]\n    self.connection_registry.add_connection(connector_id, connection_info, connector, type_connection_info)\n\n    synchronize_connector_with_persistence(connector, connection_info, self.persistence_registry)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.generate_model_registry_api","title":"<code>generate_model_registry_api(self)</code>","text":"<p>Adds a REST API so that new models can be registered and unregistered from the Middleware.</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def generate_model_registry_api(self):\n    \"\"\"\n    Adds a REST API so that new models can be registered and unregistered from the Middleware.\n    \"\"\"\n    router = generate_model_api(middleware_instance=self)\n    self.app.include_router(router)\n    NUM_REGISTRY_ROUTES = len(router.routes)\n    NUM_CONSTANT_ROUTES = 5\n    self.app.router.routes = (\n        self.app.router.routes[:NUM_CONSTANT_ROUTES]\n        + self.app.routes[-NUM_REGISTRY_ROUTES:]\n        + self.app.routes[NUM_CONSTANT_ROUTES:-NUM_REGISTRY_ROUTES]\n    )\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.generate_rest_api_for_data_model","title":"<code>generate_rest_api_for_data_model(self, data_model_name)</code>","text":"<p>Generates a REST API with CRUD operations for aas' and submodels from the loaded models.</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def generate_rest_api_for_data_model(self, data_model_name: str):\n    \"\"\"\n    Generates a REST API with CRUD operations for aas' and submodels from the loaded models.\n    \"\"\"\n    data_model = self.data_models[data_model_name]\n    rest_router = RestRouter(data_model, data_model_name, self)\n    routers = rest_router.generate_endpoints()\n    for router in routers:\n        self.app.include_router(router)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.generate_rest_endpoint_for_connector","title":"<code>generate_rest_endpoint_for_connector(self, connector_id, connection_info=None)</code>","text":"<p>Function to generate a REST endpoint for a connector.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>description</p> required <code>connection_info</code> <code>Optional[ConnectionInfo]</code> <p>description. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def generate_rest_endpoint_for_connector(self, connector_id: str, connection_info: typing.Optional[ConnectionInfo]=None):\n    \"\"\"\n    Function to generate a REST endpoint for a connector.\n\n    Args:\n        connector_id (str): _description_\n        connection_info (typing.Optional[ConnectionInfo], optional): _description_. Defaults to None.\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n    if not connector_id in self.connection_registry.connectors:\n        raise ValueError(f\"Connector {connector_id} not found.\")\n    connector = self.connection_registry.get_connector(connector_id)\n    model_type = self.connection_registry.connection_types[connector_id]\n    if not connection_info:\n        router = generate_connector_endpoint(connector_id, connector, model_type)\n    else:\n        router = generate_persistence_connector_endpoint(connector_id, connector, connection_info, model_type)\n    self.app.include_router(router)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.get_value","title":"<code>get_value(self, data_model_name, model_id=None, contained_model_id=None, field_name=None)</code>  <code>async</code>","text":"<p>Function to get a value from the persistence.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>description</p> required <code>model_id</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <code>field_name</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>description</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>async def get_value(self, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_name: typing.Optional[str]=None) -&gt; typing.Any:\n    \"\"\"\n    Function to get a value from the persistence.\n\n    Args:\n        data_model_name (str): _description_\n        model_id (typing.Optional[str]): _description_\n        field_name (typing.Optional[str]): _description_\n\n    Returns:\n        typing.Any: _description_\n    \"\"\"\n    connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_name)\n    try:\n        connector = self.persistence_registry.get_connection(connection_info)\n        return await connector.provide()\n    except KeyError:\n        raise KeyError(f\"No provider found for {connection_info}\")\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.lifespan","title":"<code>lifespan(self, app)</code>","text":"<p>Function to create a lifespan for the middleware for all events on startup and shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI app that should be used for the lifespan.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: FastAPI):\n    \"\"\"\n    Function to create a lifespan for the middleware for all events on startup and shutdown.\n\n    Args:\n        app (FastAPI): The FastAPI app that should be used for the lifespan.\n    \"\"\"\n    for workflow in self.workflow_registry.get_workflows():\n        if workflow.on_startup:\n            # TODO: make a case distinction for workflows that postpone start up or not...\n            asyncio.create_task(workflow.execute())\n    for callback in self.on_start_up_callbacks:\n        await callback()\n    for connector in self.connection_registry.connectors.values():\n        await connector.connect()\n    for persistence in self.persistence_registry.connectors.values():\n        await persistence.connect()\n    yield\n    for workflow in self.workflow_registry.get_workflows():\n        if workflow.on_shutdown:\n            if workflow.running:\n                await workflow.interrupt()\n            await workflow.execute()\n\n    for callback in self.on_shutdown_callbacks:\n        await callback()\n\n    for connector in self.connection_registry.connectors.values():\n        await connector.disconnect()\n    for persistence in self.persistence_registry.connectors.values():\n        await persistence.disconnect()\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.load_aas_objectstore","title":"<code>load_aas_objectstore(self, models)</code>","text":"<p>Functions that loads multiple aas and their submodels into the middleware that can be used for synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>List[model.DictObjectStore]</code> <p>Object store of aas' and submodels</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def load_aas_objectstore(self, models: model.DictObjectStore):\n    \"\"\"\n    Functions that loads multiple aas and their submodels into the middleware that can be used for synchronization.\n\n    Args:\n        models (typing.List[model.DictObjectStore]): Object store of aas' and submodels\n    \"\"\"\n    data_model = BasyxFormatter().deserialize(models)\n    self.load_data_model(data_model)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.load_data_model","title":"<code>load_data_model(self, name, data_model)</code>","text":"<p>Function to load a data model into the middleware to be used for synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data model.</p> required <code>data_model</code> <code>DataModel</code> <p>Data model containing the types and values.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def load_data_model(self, name: str, data_model: DataModel):\n    \"\"\"\n    Function to load a data model into the middleware to be used for synchronization.\n\n    Args:\n        name (str): The name of the data model.\n        data_model (DataModel): Data model containing the types and values.\n    \"\"\"\n    self.data_models[name] = data_model\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.load_json_models","title":"<code>load_json_models(self, json_models=None, all_fields_required=False)</code>","text":"<p>Functions that loads models from a json dict into the middleware that can be used for synchronization.</p> <p>The function can either be used with a dict that contains the objects.</p> <p>Parameters:</p> Name Type Description Default <code>json_models</code> <code>dict</code> <p>Dictionary of aas' and submodels.</p> <code>None</code> <code>all_fields_required</code> <code>bool</code> <p>If all fields are required in the models.</p> <code>False</code> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def load_json_models(\n    self,\n    json_models: typing.Dict[str, typing.Any] = None,\n    all_fields_required: bool = False,\n):\n    \"\"\"\n    Functions that loads models from a json dict into the middleware that can be used for synchronization.\n\n    The function can either be used with a dict that contains the objects.\n\n    Args:\n        json_models (dict): Dictionary of aas' and submodels.\n        all_fields_required (bool): If all fields are required in the models.\n    \"\"\"\n    # TODO: use here the function to load a DataModel from a dict\n    # for model_name, model_values in json_models.items():\n    #     pydantic_model = get_pydantic_model_from_dict(\n    #         model_values, model_name, all_fields_required\n    #     )\n    #     self.models.append(pydantic_model)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.load_model_instances","title":"<code>load_model_instances(self, name, instances)</code>","text":"<p>Functions that loads pydantic models into the middleware as a datamodel that can be used for synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data model.</p> required <code>instances</code> <code>List[BaseModel]</code> <p>List of pydantic model instances.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def load_model_instances(self, name: str, instances: typing.List[BaseModel]):\n    \"\"\"\n    Functions that loads pydantic models into the middleware as a datamodel that can be used for synchronization.\n\n    Args:\n        name (str): The name of the data model.\n        instances (typing.List[BaseModel]): List of pydantic model instances.\n    \"\"\"\n    data_model = DataModel.from_models(*instances)\n    self.load_data_model(name, data_model)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.load_pydantic_models","title":"<code>load_pydantic_models(self, name, *models)</code>","text":"<p>Functions that loads pydantic models into the middleware that can be used for synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>List[Type[BaseModel]]</code> <p>List of pydantic models.</p> <code>()</code> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def load_pydantic_models(self, name: str, *models: typing.Tuple[typing.Type[BaseModel]]):\n    \"\"\"\n    Functions that loads pydantic models into the middleware that can be used for synchronization.\n\n    Args:\n        models (typing.List[typing.Type[BaseModel]]): List of pydantic models.\n    \"\"\"\n    data_model = DataModel.from_model_types(models)\n    self.load_data_model(data_model)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.persist","title":"<code>persist(self, data_model_name, model=None, persistence_factory=None)</code>  <code>async</code>","text":"<p>Function to add a model to the persistence.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>The name of the data model.</p> required <code>model</code> <code>Identifiable</code> <p>The model that should be persisted.</p> <code>None</code> <code>persistence_factory</code> <code>PersistenceFactory</code> <p>The persistence factory that should be used.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the connection already exists.</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>async def persist(self, data_model_name: str, model: typing.Optional[Identifiable]=None, persistence_factory: typing.Optional[PersistenceFactory]=None):\n    \"\"\"\n    Function to add a model to the persistence.\n\n    Args:\n        data_model_name (str): The name of the data model.\n        model (Identifiable): The model that should be persisted.\n        persistence_factory (PersistenceFactory): The persistence factory that should be used.\n\n    Raises:\n        ValueError: If the connection already exists.\n    \"\"\"\n    connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model.id, contained_model_id=None, field_id=None)\n    if connection_info in self.persistence_registry.connections:\n        raise ValueError(f\"Connection {connection_info} already exists. Try using the existing connector or remove it first.\")\n    self.persistence_registry.add_to_persistence(connection_info, model, persistence_factory)\n    connector = self.persistence_registry.get_connection(connection_info)\n    # TODO: raise an error if consume is not possible and remove the persistence in the persistence registry\n    await connector.consume(model)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.set_meta_data","title":"<code>set_meta_data(self, title, description, version, contact)</code>","text":"<p>Function to set the meta data of the middleware.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the middleware.</p> required <code>description</code> <code>str</code> <p>The description of the middleware.</p> required <code>version</code> <code>str</code> <p>The version of the middleware.</p> required <code>contact</code> <code>Dict[str, str]</code> <p>The contact information of the middleware.</p> required <code>license_info</code> <code>Dict[str, str]</code> <p>The license information of the middleware.</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>def set_meta_data(self, title: str, description: str, version: str, contact: typing.Dict[str, str]):\n    \"\"\"\n    Function to set the meta data of the middleware.\n\n    Args:\n        title (str): The title of the middleware.\n        description (str): The description of the middleware.\n        version (str): The version of the middleware.\n        contact (typing.Dict[str, str]): The contact information of the middleware.\n        license_info (typing.Dict[str, str]): The license information of the middleware.\n    \"\"\"\n    self.meta_data = MiddlewareMetaData(\n        title=title,\n        description=description,\n        version=version,\n        contact=contact\n    )\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.Middleware.update_value","title":"<code>update_value(self, value, data_model_name, model_id=None, contained_model_id=None, field_name=None)</code>  <code>async</code>","text":"<p>Function to update a value in the persistence.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>description</p> required <code>model_id</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <code>field_name</code> <code>Optional[str]</code> <p>description</p> <code>None</code> <code>value</code> <code>Any</code> <p>description</p> required Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>async def update_value(self, value: typing.Any, data_model_name: str, model_id: typing.Optional[str]=None, contained_model_id: typing.Optional[str]=None, field_name: typing.Optional[str]=None):\n    \"\"\"\n    Function to update a value in the persistence.\n\n    Args:\n        data_model_name (str): _description_\n        model_id (typing.Optional[str]): _description_\n        field_name (typing.Optional[str]): _description_\n        value (typing.Any): _description_\n    \"\"\"\n    connection_info = ConnectionInfo(data_model_name=data_model_name, model_id=model_id, contained_model_id=contained_model_id, field_id=field_name)\n    try:\n        connector = self.persistence_registry.get_connection(connection_info)\n        await connector.consume(value)\n    except KeyError as e:\n        await self.persist(data_model_name, value)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.middleware.MiddlewareMetaData","title":"<code> MiddlewareMetaData            (BaseModel)         </code>","text":"<p>Meta data for the middleware.</p> Source code in <code>aas_middleware\\middleware\\middleware.py</code> <pre><code>class MiddlewareMetaData(BaseModel):\n    \"\"\"\n    Meta data for the middleware.\n    \"\"\"\n    title: str = \"aas-middleware\"\n    description: str = \"\"\"\n    The aas-middleware allows to convert aas models to pydantic models and generate a REST or GraphQL API from them.\n    \"\"\"\n    version: str = Field(default=aas_middleware.VERSION)\n    contact: typing.Dict[str, str] = {\n        \"name\": \"Sebastian Behrendt\",\n        \"email\": \"sebastian.behrendt@kit.edu\",\n    }\n    license_info: typing.Dict[str, str] = Field(init=False, default_factory=get_license_info)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.model_registry_api","title":"<code>model_registry_api</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.model_registry_api.generate_model_api","title":"<code>generate_model_api(middleware_instance)</code>","text":"<p>Generates endpoints to register und unregister models from the middleware.</p> <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with endpoints to register and register models.</p> Source code in <code>aas_middleware\\middleware\\model_registry_api.py</code> <pre><code>def generate_model_api(middleware_instance: Middleware) -&gt; APIRouter:\n    \"\"\"\n    Generates endpoints to register und unregister models from the middleware.\n\n    Returns:\n        APIRouter: FastAPI router with endpoints to register and register models.\n    \"\"\"\n    # TODO: Also allow to retrieve and post models as JSONSchema -&gt; with required / non-required fields.\n    router = APIRouter(\n        prefix=f\"\",\n        tags=[\"Model registry\"],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.get(\"/get_models\", response_model=list)\n    async def get_models() -&gt; List[Dict[str, str]]:\n        schemas = [\n            recursive_model_example_string_reformatter(model.schema())\n            for model in middleware_instance.models\n        ]\n        return schemas\n\n    @router.post(\n        \"/register_model\",\n        response_model=dict,\n    )\n    async def post_model(model_name: str, model: dict) -&gt; Dict[str, str]:\n        if any(\n            model_name == model_instance.__name__\n            for model_instance in middleware_instance.models\n        ):\n            raise HTTPException(\n                403,\n                f\"A model with the name {model_name} exists already! Please update the existing model.\",\n            )\n        if not \"id\" in model.keys():\n            raise HTTPException(\n                403, f\"Mandatory field id is missing for the model &lt;{model_name}&gt;.\"\n            )\n        for key, value in model.items():\n            if isinstance(value, dict) and not \"id\" in value.keys():\n                raise HTTPException(\n                    403,\n                    f\"Mandatory field id is missing in submodel &lt;{key}&gt; for model &lt;{model_name}&gt;.\",\n                )\n        register_model_from_middleware(model_name, model, middleware_instance)\n        return {\"message\": f\"Succesfully created API for model {model_name}.\"}\n\n    @router.put(\"/update_model\", response_model=dict)\n    async def update_model(model_name: str, model: dict) -&gt; Dict[str, str]:\n        if not any(\n            model_name == model_instance.__name__\n            for model_instance in middleware_instance.models\n        ):\n            raise HTTPException(\n                403,\n                f\"A model with the name {model_name} does not exist yet! Please post a new model.\",\n            )\n        if not \"id\" in model.keys():\n            raise HTTPException(\n                403, f\"Mandatory field id is missing for the model &lt;{model_name}&gt;.\"\n            )\n        for key, value in model.items():\n            if isinstance(value, dict) and not \"id\" in value.keys():\n                raise HTTPException(\n                    403,\n                    f\"Mandatory field id is missing in submodel &lt;{key}&gt; for model &lt;{model_name}&gt;.\",\n                )\n        delete_model_from_middleware(model_name, middleware_instance)\n        register_model_from_middleware(model_name, model, middleware_instance)\n        return {\"message\": f\"Succesfully updated API for model {model_name}.\"}\n\n    @router.delete(\"/delete_model\", response_model=dict)\n    async def delete_model(model_name: str):\n        if not any(\n            model.__name__ == model_name for model in middleware_instance.models\n        ):\n            raise HTTPException(\n                404, f\"No model registered in middleware with name &lt;{model_name}&gt;\"\n            )\n        delete_model_from_middleware(model_name, middleware_instance)\n        return {\"message\": f\"Succesfully deleted API for model {model_name}.\"}\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.model_registry_api.remove_model_routes_from_app","title":"<code>remove_model_routes_from_app(app, model_name)</code>","text":"<p>Function removes routes from app that contain the model_name as first route seperator.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>FastAPI app to remove routes from</p> required <code>model_name</code> <code>str</code> <p>model_name of model to remove from API of app</p> required Source code in <code>aas_middleware\\middleware\\model_registry_api.py</code> <pre><code>def remove_model_routes_from_app(app: FastAPI, model_name: str):\n    \"\"\"\n    Function removes routes from app that contain the model_name as first route seperator.\n\n    Args:\n        app (FastAPI): FastAPI app to remove routes from\n        model_name (str): model_name of model to remove from API of app\n    \"\"\"\n    indices_to_delete = []\n    for i, r in enumerate(app.routes):\n        if route_belongs_to_model(r, model_name):\n            indices_to_delete.append(i)\n    for index in sorted(indices_to_delete, reverse=True):\n        del app.routes[index]\n    update_openapi(app)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.model_registry_api.update_openapi","title":"<code>update_openapi(app)</code>","text":"<p>Updates the openAPI schema of a fastAPI app during runtime to register updates.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>app where the openapi schema should be updated.</p> required Source code in <code>aas_middleware\\middleware\\model_registry_api.py</code> <pre><code>def update_openapi(app: FastAPI):\n    \"\"\"\n    Updates the openAPI schema of a fastAPI app during runtime to register updates.\n\n    Args:\n        app (FastAPI): app where the openapi schema should be updated.\n    \"\"\"\n    app.openapi_schema = get_openapi(\n        title=app.title,\n        version=app.version,\n        openapi_version=app.openapi_version,\n        description=app.description,\n        terms_of_service=app.terms_of_service,\n        contact=app.contact,\n        license_info=app.license_info,\n        routes=app.routes,\n        tags=app.openapi_tags,\n        servers=app.servers,\n    )\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries","title":"<code>registries</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionInfo","title":"<code> ConnectionInfo            (BaseModel)         </code>","text":"<p>Class that contains the information of a connection of a provider and a consumer to the persistence layer.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>class ConnectionInfo(BaseModel):\n    \"\"\"\n    Class that contains the information of a connection of a provider and a consumer to the persistence layer.\n    \"\"\"\n    data_model_name: str\n    model_id: typing.Optional[str] = None\n    contained_model_id: typing.Optional[str] = None\n    field_id: typing.Optional[str] = None\n\n    model_config = ConfigDict(frozen=True, protected_namespaces=())\n\n    @property\n    def connection_type(self) -&gt; typing.Literal[\"data_model\", \"model\", \"contained_model\", \"field\"]:\n        if self.model_id:\n            if self.contained_model_id:\n                if self.field_id:\n                    return \"field\"\n                return \"contained_model\"\n            return \"model\"\n        return \"data_model\"\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry","title":"<code> ConnectionRegistry        </code>","text":"<p>Class that manages the connections of the middleware.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>class ConnectionRegistry:\n    \"\"\"\n    Class that manages the connections of the middleware.\n    \"\"\"\n\n    def __init__(self):\n        self.connectors: typing.Dict[str, Connector] = {}\n        self.connection_types: typing.Dict[str, typing.Type[Connector]] = {}\n        self.connections: typing.Dict[ConnectionInfo, typing.List[str]] = {}\n\n\n    def get_connector_id(self, connector: Connector) -&gt; str:\n        \"\"\"\n        Function to get a connector id from the connection manager.\n\n        Args:\n            connector (Connector): The connector of the connection.\n\n        Returns:\n            str: The id of the connector.\n\n        Raises:\n            KeyError: If the connector is not in the connection manager.\n        \"\"\"\n        for connector_id, connector_ in self.connectors.items():\n            if connector == connector_:\n                return connector_id\n        raise KeyError(f\"Connector {connector} is not in the connection manager.\")\n\n\n    def get_connector(self, connector_id: str) -&gt; Connector:\n        \"\"\"\n        Function to get a connector from the connection manager.\n\n        Args:\n            connector_id (str): The id of the connector.\n\n        Returns:\n            Connector: The connector of the connection.\n\n        Raises:\n            KeyError: If the connector id is not in the connection manager.\n        \"\"\"\n        return self.connectors[connector_id]\n\n\n    def add_connector(self, connector_id: str, connector: Connector, connection_type: typing.Type[Connector]):\n        \"\"\"\n        Function to add a connector to the connection manager.\n\n        Args:\n            connector_id (str): The name of the connector.\n            connector (Connector): The connector to be added.\n            connection_type (typing.Type[Connector]): The type of the connector.\n        \"\"\"\n        self.connectors[connector_id] = connector\n        self.connection_types[connector_id] = connection_type\n\n    def add_connection(self, connector_id: str, connection_info: ConnectionInfo, connector: Connector, type_connection_info: typing.Type[typing.Any]):\n        \"\"\"\n        Function to add a connection to the connection manager.\n\n        Args:\n            connector_id (str): The id of the connector.\n            connection_info (ConnectionInfo): The connection info of the connection.\n            connector (Connector): The connector of the connection.\n            type_connection_info (typing.Type[typing.Any]): The type of the connection info of the connection.\n        \"\"\"\n        if not connection_info in self.connections:\n            self.connections[connection_info] = []\n        self.connections[connection_info].append(connector_id)\n        self.add_connector(connector_id, connector, type_connection_info)\n\n    def get_connections(self, connection_info: ConnectionInfo) -&gt; typing.List[typing.Tuple[Connector, typing.Type[typing.Any]]]:\n        \"\"\"\n        Function to get a connection from the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n\n        Returns:\n            Connector: The connector of the connection.\n        \"\"\"\n        connector_ids = self.connections[connection_info]\n        connections = []\n        for connector_id in connector_ids:\n            connections.append((self.get_connector(connector_id), self.connection_types[connector_id]))\n        return connections\n\n    def get_data_model_connection_info(self, data_model_name: str) -&gt; typing.List[ConnectionInfo]:\n        \"\"\"\n        Function to get the connection info of a data model.\n\n        Args:\n            data_model_name (str): The name of the data model.\n\n        Returns:\n            typing.Set[ConnectionInfo]: The connection info of the data model.\n        \"\"\"\n        connection_infos = []\n        for connection_info in self.connections:\n            if not connection_info.data_model_name == data_model_name:\n                continue\n            connection_infos.append(connection_info)\n        return connection_infos\n\n    def get_model_connection_info(self, model_id: str) -&gt; typing.List[ConnectionInfo]:\n        \"\"\"\n        Function to get the connection info of a model.\n\n        Args:\n            model_id (str): The id of the model.\n\n        Returns:\n            typing.Set[ConnectionInfo]: The connection info of the model.\n        \"\"\"\n        connection_infos = []\n        for connection_info in self.connections:\n            if not connection_info.model_id == model_id:\n                continue\n            connection_infos.append(connection_info)\n        return connection_infos\n\n    def get_field_connection_info(self, field_id: str) -&gt; typing.List[ConnectionInfo]:\n        \"\"\"\n        Function to get the connection info of a field.\n\n        Args:\n            field_id (str): The id of the field.\n\n        Returns:\n            typing.Set[ConnectionInfo]: The connection info of the field.\n        \"\"\"\n        connection_infos = []\n        for connection_info in self.connections:\n            if not connection_info.field_id == field_id:\n                continue\n            connection_infos.append(connection_info)\n        return connection_infos\n\n    def get_type_connection_info(self, type_name: str) -&gt; typing.List[ConnectionInfo]:\n        \"\"\"\n        Function to get the connection info of a type.\n\n        Args:\n            type_name (str): The name of the type.\n\n        Returns:\n            typing.Set[ConnectionInfo]: The connection info of the type.\n        \"\"\"\n        connection_infos = []\n        for connection_info, connections in self.connections.items():\n            for connection in connections:\n                if not connection[1].__name__ == type_name:\n                    continue\n                connection_infos.append(connection_info)\n        return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.add_connection","title":"<code>add_connection(self, connector_id, connection_info, connector, type_connection_info)</code>","text":"<p>Function to add a connection to the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>The id of the connector.</p> required <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <code>connector</code> <code>Connector</code> <p>The connector of the connection.</p> required <code>type_connection_info</code> <code>Type[Any]</code> <p>The type of the connection info of the connection.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_connection(self, connector_id: str, connection_info: ConnectionInfo, connector: Connector, type_connection_info: typing.Type[typing.Any]):\n    \"\"\"\n    Function to add a connection to the connection manager.\n\n    Args:\n        connector_id (str): The id of the connector.\n        connection_info (ConnectionInfo): The connection info of the connection.\n        connector (Connector): The connector of the connection.\n        type_connection_info (typing.Type[typing.Any]): The type of the connection info of the connection.\n    \"\"\"\n    if not connection_info in self.connections:\n        self.connections[connection_info] = []\n    self.connections[connection_info].append(connector_id)\n    self.add_connector(connector_id, connector, type_connection_info)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.add_connector","title":"<code>add_connector(self, connector_id, connector, connection_type)</code>","text":"<p>Function to add a connector to the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>The name of the connector.</p> required <code>connector</code> <code>Connector</code> <p>The connector to be added.</p> required <code>connection_type</code> <code>Type[Connector]</code> <p>The type of the connector.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_connector(self, connector_id: str, connector: Connector, connection_type: typing.Type[Connector]):\n    \"\"\"\n    Function to add a connector to the connection manager.\n\n    Args:\n        connector_id (str): The name of the connector.\n        connector (Connector): The connector to be added.\n        connection_type (typing.Type[Connector]): The type of the connector.\n    \"\"\"\n    self.connectors[connector_id] = connector\n    self.connection_types[connector_id] = connection_type\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_connections","title":"<code>get_connections(self, connection_info)</code>","text":"<p>Function to get a connection from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <p>Returns:</p> Type Description <code>Connector</code> <p>The connector of the connection.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_connections(self, connection_info: ConnectionInfo) -&gt; typing.List[typing.Tuple[Connector, typing.Type[typing.Any]]]:\n    \"\"\"\n    Function to get a connection from the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n\n    Returns:\n        Connector: The connector of the connection.\n    \"\"\"\n    connector_ids = self.connections[connection_info]\n    connections = []\n    for connector_id in connector_ids:\n        connections.append((self.get_connector(connector_id), self.connection_types[connector_id]))\n    return connections\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_connector","title":"<code>get_connector(self, connector_id)</code>","text":"<p>Function to get a connector from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connector_id</code> <code>str</code> <p>The id of the connector.</p> required <p>Returns:</p> Type Description <code>Connector</code> <p>The connector of the connection.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>If the connector id is not in the connection manager.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_connector(self, connector_id: str) -&gt; Connector:\n    \"\"\"\n    Function to get a connector from the connection manager.\n\n    Args:\n        connector_id (str): The id of the connector.\n\n    Returns:\n        Connector: The connector of the connection.\n\n    Raises:\n        KeyError: If the connector id is not in the connection manager.\n    \"\"\"\n    return self.connectors[connector_id]\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_connector_id","title":"<code>get_connector_id(self, connector)</code>","text":"<p>Function to get a connector id from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connector</code> <code>Connector</code> <p>The connector of the connection.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The id of the connector.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>If the connector is not in the connection manager.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_connector_id(self, connector: Connector) -&gt; str:\n    \"\"\"\n    Function to get a connector id from the connection manager.\n\n    Args:\n        connector (Connector): The connector of the connection.\n\n    Returns:\n        str: The id of the connector.\n\n    Raises:\n        KeyError: If the connector is not in the connection manager.\n    \"\"\"\n    for connector_id, connector_ in self.connectors.items():\n        if connector == connector_:\n            return connector_id\n    raise KeyError(f\"Connector {connector} is not in the connection manager.\")\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_data_model_connection_info","title":"<code>get_data_model_connection_info(self, data_model_name)</code>","text":"<p>Function to get the connection info of a data model.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>The name of the data model.</p> required <p>Returns:</p> Type Description <code>Set[ConnectionInfo]</code> <p>The connection info of the data model.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_data_model_connection_info(self, data_model_name: str) -&gt; typing.List[ConnectionInfo]:\n    \"\"\"\n    Function to get the connection info of a data model.\n\n    Args:\n        data_model_name (str): The name of the data model.\n\n    Returns:\n        typing.Set[ConnectionInfo]: The connection info of the data model.\n    \"\"\"\n    connection_infos = []\n    for connection_info in self.connections:\n        if not connection_info.data_model_name == data_model_name:\n            continue\n        connection_infos.append(connection_info)\n    return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_field_connection_info","title":"<code>get_field_connection_info(self, field_id)</code>","text":"<p>Function to get the connection info of a field.</p> <p>Parameters:</p> Name Type Description Default <code>field_id</code> <code>str</code> <p>The id of the field.</p> required <p>Returns:</p> Type Description <code>Set[ConnectionInfo]</code> <p>The connection info of the field.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_field_connection_info(self, field_id: str) -&gt; typing.List[ConnectionInfo]:\n    \"\"\"\n    Function to get the connection info of a field.\n\n    Args:\n        field_id (str): The id of the field.\n\n    Returns:\n        typing.Set[ConnectionInfo]: The connection info of the field.\n    \"\"\"\n    connection_infos = []\n    for connection_info in self.connections:\n        if not connection_info.field_id == field_id:\n            continue\n        connection_infos.append(connection_info)\n    return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_model_connection_info","title":"<code>get_model_connection_info(self, model_id)</code>","text":"<p>Function to get the connection info of a model.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>The id of the model.</p> required <p>Returns:</p> Type Description <code>Set[ConnectionInfo]</code> <p>The connection info of the model.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_model_connection_info(self, model_id: str) -&gt; typing.List[ConnectionInfo]:\n    \"\"\"\n    Function to get the connection info of a model.\n\n    Args:\n        model_id (str): The id of the model.\n\n    Returns:\n        typing.Set[ConnectionInfo]: The connection info of the model.\n    \"\"\"\n    connection_infos = []\n    for connection_info in self.connections:\n        if not connection_info.model_id == model_id:\n            continue\n        connection_infos.append(connection_info)\n    return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.ConnectionRegistry.get_type_connection_info","title":"<code>get_type_connection_info(self, type_name)</code>","text":"<p>Function to get the connection info of a type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the type.</p> required <p>Returns:</p> Type Description <code>Set[ConnectionInfo]</code> <p>The connection info of the type.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_type_connection_info(self, type_name: str) -&gt; typing.List[ConnectionInfo]:\n    \"\"\"\n    Function to get the connection info of a type.\n\n    Args:\n        type_name (str): The name of the type.\n\n    Returns:\n        typing.Set[ConnectionInfo]: The connection info of the type.\n    \"\"\"\n    connection_infos = []\n    for connection_info, connections in self.connections.items():\n        for connection in connections:\n            if not connection[1].__name__ == type_name:\n                continue\n            connection_infos.append(connection_info)\n    return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry","title":"<code> PersistenceConnectionRegistry            (ConnectionRegistry)         </code>","text":"<p>Class that manages the connections of the middleware.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>class PersistenceConnectionRegistry(ConnectionRegistry):\n    \"\"\"\n    Class that manages the connections of the middleware.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.connectors: typing.Dict[str, Connector] = {}\n        self.connection_types: typing.Dict[str, typing.Type[Connector]] = {}\n        self.connections: typing.Dict[ConnectionInfo, str] = {}\n        self.persistence_factories: typing.Dict[ConnectionInfo, typing.List[typing.Tuple[PersistenceFactory, typing.Type[typing.Any]]]] = {}\n\n\n    def get_connector_by_data_model_and_model_id(self, data_model_name: str, model_id: str) -&gt; Connector:\n        \"\"\"\n        Function to get a connector from the connection manager.\n\n        Args:\n            data_model_name (str): The name of the data model.\n            model_id (str): The id of the model.\n\n        Returns:\n            Connector: The connector of the connection.\n\n        Raises:\n            KeyError: If the model id is not in the connection manager.\n        \"\"\"\n        connector_id = data_model_name + model_id + \"_persistence\"\n        return self.get_connector(connector_id)\n\n    def add_persistence_factory(self, connection_info: ConnectionInfo, model_type: typing.Type[typing.Any], persistence_factory: PersistenceFactory):\n        \"\"\"\n        Function to add a persistence factory to the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n            persistence_factory (PersistenceFactory): The persistence factory of the connection.\n        \"\"\"\n        if not connection_info in self.persistence_factories:\n            self.persistence_factories[connection_info] = []\n        self.persistence_factories[connection_info].append((model_type, persistence_factory))\n\n    def get_default_persistence_factory(self, connection_info: ConnectionInfo, persisted_model_type: typing.Type[typing.Any]) -&gt; PersistenceFactory:\n        \"\"\"\n        Function to get the default persistence factory of a connection.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n\n        Returns:\n            PersistenceFactory: The default persistence factory of the connection.\n        \"\"\"\n        data_model_connection_info = ConnectionInfo(data_model_name=connection_info.data_model_name)\n        if not data_model_connection_info in self.persistence_factories:\n            logger.warning(f\"No persistence factory found for {data_model_connection_info}. Using default persistence factory.\")\n            return PersistenceFactory(ModelConnector)\n        for model_type, persistence_factory in self.persistence_factories[data_model_connection_info]:\n            if issubclass(persisted_model_type, model_type):\n                return persistence_factory\n        logger.warning(f\"No persistence factory found for {data_model_connection_info} and model type {persisted_model_type.__name__}. Using default persistence factory.\")\n        return PersistenceFactory(ModelConnector)\n\n    def add_to_persistence(self, connection_info: ConnectionInfo, model: Identifiable, persistence_factory: typing.Optional[PersistenceFactory]):\n        \"\"\"\n        Function to add a persistent connection to the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n        \"\"\"\n        if not persistence_factory:\n            persistence_factory = self.get_default_persistence_factory(connection_info, type(model))\n        connector = persistence_factory.create(model)\n        self.add_connection(connection_info, connector, type(model))\n\n    def add_connection(self, connection_info: ConnectionInfo, connector: Connector, type_connection_info: typing.Type[typing.Any]):\n        \"\"\"\n        Function to add a connection to the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n            connector (Connector): The connector of the connection.\n        \"\"\"\n        connector_id = connection_info.data_model_name + connection_info.model_id + \"_persistence\"\n        self.add_connector(connector_id, connector, type_connection_info)\n        self.connections[connection_info] = connector_id\n\n\n    def remove_connection(self, connection_info: ConnectionInfo):\n        \"\"\"\n        Function to remove a connection from the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n        \"\"\"\n        del self.connections[connection_info]\n        # TODO: also delete connector and connection type\n\n    def get_connection(self, connection_info: ConnectionInfo) -&gt; Connector:\n        \"\"\"\n        Function to get a connection from the connection manager.\n\n        Args:\n            connection_info (ConnectionInfo): The connection info of the connection.\n\n        Returns:\n            Connector: The connector of the connection.\n\n        Raises:\n            KeyError: If the connection info is not in the connection manager.\n        \"\"\"\n        if connection_info in self.connections:\n            return self.get_connector(self.connections[connection_info])\n        raise KeyError(f\"Data model Connection info {connection_info} is not in the connection manager.\")\n\n    def get_type_connection_info(self, type_name: str) -&gt; typing.List[ConnectionInfo]:\n        \"\"\"\n        Function to get the connection info of a type.\n\n        Args:\n            type_name (str): The name of the type.\n\n        Returns:\n            typing.Set[ConnectionInfo]: The connection info of the type.\n        \"\"\"\n        connection_infos = []\n        for connection_info, connector_id in self.connections.items():\n            model_type = self.connection_types[connector_id]\n            if not model_type.__name__ == type_name:\n                continue\n            connection_infos.append(connection_info)\n        return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.add_connection","title":"<code>add_connection(self, connection_info, connector, type_connection_info)</code>","text":"<p>Function to add a connection to the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <code>connector</code> <code>Connector</code> <p>The connector of the connection.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_connection(self, connection_info: ConnectionInfo, connector: Connector, type_connection_info: typing.Type[typing.Any]):\n    \"\"\"\n    Function to add a connection to the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n        connector (Connector): The connector of the connection.\n    \"\"\"\n    connector_id = connection_info.data_model_name + connection_info.model_id + \"_persistence\"\n    self.add_connector(connector_id, connector, type_connection_info)\n    self.connections[connection_info] = connector_id\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.add_persistence_factory","title":"<code>add_persistence_factory(self, connection_info, model_type, persistence_factory)</code>","text":"<p>Function to add a persistence factory to the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <code>persistence_factory</code> <code>PersistenceFactory</code> <p>The persistence factory of the connection.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_persistence_factory(self, connection_info: ConnectionInfo, model_type: typing.Type[typing.Any], persistence_factory: PersistenceFactory):\n    \"\"\"\n    Function to add a persistence factory to the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n        persistence_factory (PersistenceFactory): The persistence factory of the connection.\n    \"\"\"\n    if not connection_info in self.persistence_factories:\n        self.persistence_factories[connection_info] = []\n    self.persistence_factories[connection_info].append((model_type, persistence_factory))\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.add_to_persistence","title":"<code>add_to_persistence(self, connection_info, model, persistence_factory)</code>","text":"<p>Function to add a persistent connection to the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_to_persistence(self, connection_info: ConnectionInfo, model: Identifiable, persistence_factory: typing.Optional[PersistenceFactory]):\n    \"\"\"\n    Function to add a persistent connection to the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n    \"\"\"\n    if not persistence_factory:\n        persistence_factory = self.get_default_persistence_factory(connection_info, type(model))\n    connector = persistence_factory.create(model)\n    self.add_connection(connection_info, connector, type(model))\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.get_connection","title":"<code>get_connection(self, connection_info)</code>","text":"<p>Function to get a connection from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <p>Returns:</p> Type Description <code>Connector</code> <p>The connector of the connection.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>If the connection info is not in the connection manager.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_connection(self, connection_info: ConnectionInfo) -&gt; Connector:\n    \"\"\"\n    Function to get a connection from the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n\n    Returns:\n        Connector: The connector of the connection.\n\n    Raises:\n        KeyError: If the connection info is not in the connection manager.\n    \"\"\"\n    if connection_info in self.connections:\n        return self.get_connector(self.connections[connection_info])\n    raise KeyError(f\"Data model Connection info {connection_info} is not in the connection manager.\")\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.get_connector_by_data_model_and_model_id","title":"<code>get_connector_by_data_model_and_model_id(self, data_model_name, model_id)</code>","text":"<p>Function to get a connector from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>data_model_name</code> <code>str</code> <p>The name of the data model.</p> required <code>model_id</code> <code>str</code> <p>The id of the model.</p> required <p>Returns:</p> Type Description <code>Connector</code> <p>The connector of the connection.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>If the model id is not in the connection manager.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_connector_by_data_model_and_model_id(self, data_model_name: str, model_id: str) -&gt; Connector:\n    \"\"\"\n    Function to get a connector from the connection manager.\n\n    Args:\n        data_model_name (str): The name of the data model.\n        model_id (str): The id of the model.\n\n    Returns:\n        Connector: The connector of the connection.\n\n    Raises:\n        KeyError: If the model id is not in the connection manager.\n    \"\"\"\n    connector_id = data_model_name + model_id + \"_persistence\"\n    return self.get_connector(connector_id)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.get_default_persistence_factory","title":"<code>get_default_persistence_factory(self, connection_info, persisted_model_type)</code>","text":"<p>Function to get the default persistence factory of a connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required <p>Returns:</p> Type Description <code>PersistenceFactory</code> <p>The default persistence factory of the connection.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_default_persistence_factory(self, connection_info: ConnectionInfo, persisted_model_type: typing.Type[typing.Any]) -&gt; PersistenceFactory:\n    \"\"\"\n    Function to get the default persistence factory of a connection.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n\n    Returns:\n        PersistenceFactory: The default persistence factory of the connection.\n    \"\"\"\n    data_model_connection_info = ConnectionInfo(data_model_name=connection_info.data_model_name)\n    if not data_model_connection_info in self.persistence_factories:\n        logger.warning(f\"No persistence factory found for {data_model_connection_info}. Using default persistence factory.\")\n        return PersistenceFactory(ModelConnector)\n    for model_type, persistence_factory in self.persistence_factories[data_model_connection_info]:\n        if issubclass(persisted_model_type, model_type):\n            return persistence_factory\n    logger.warning(f\"No persistence factory found for {data_model_connection_info} and model type {persisted_model_type.__name__}. Using default persistence factory.\")\n    return PersistenceFactory(ModelConnector)\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.get_type_connection_info","title":"<code>get_type_connection_info(self, type_name)</code>","text":"<p>Function to get the connection info of a type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the type.</p> required <p>Returns:</p> Type Description <code>Set[ConnectionInfo]</code> <p>The connection info of the type.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_type_connection_info(self, type_name: str) -&gt; typing.List[ConnectionInfo]:\n    \"\"\"\n    Function to get the connection info of a type.\n\n    Args:\n        type_name (str): The name of the type.\n\n    Returns:\n        typing.Set[ConnectionInfo]: The connection info of the type.\n    \"\"\"\n    connection_infos = []\n    for connection_info, connector_id in self.connections.items():\n        model_type = self.connection_types[connector_id]\n        if not model_type.__name__ == type_name:\n            continue\n        connection_infos.append(connection_info)\n    return connection_infos\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.PersistenceConnectionRegistry.remove_connection","title":"<code>remove_connection(self, connection_info)</code>","text":"<p>Function to remove a connection from the connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info of the connection.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def remove_connection(self, connection_info: ConnectionInfo):\n    \"\"\"\n    Function to remove a connection from the connection manager.\n\n    Args:\n        connection_info (ConnectionInfo): The connection info of the connection.\n    \"\"\"\n    del self.connections[connection_info]\n    # TODO: also delete connector and connection type\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry","title":"<code> WorkflowRegistry        </code>","text":"<p>Class that manages the workflows of the registry.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>class WorkflowRegistry:\n    \"\"\"\n    Class that manages the workflows of the registry.\n    \"\"\"\n\n    def __init__(self):\n        self.workflows: typing.Dict[str, Workflow] = {}\n\n        self.workflow_providers: typing.Dict[str, typing.List[typing.Tuple[ConnectionInfo, Provider]]] = {}\n        self.workflow_consumers: typing.Dict[str, typing.List[typing.Tuple[ConnectionInfo, Consumer]]] = {}\n\n    def add_workflow(self, workflow: Workflow):\n        \"\"\"\n        Function to add a workflow to the registry.\n\n        Args:\n            workflow (Workflow): The workflow to be added.\n        \"\"\"\n        self.workflows[workflow.get_name()] = workflow\n\n    # def add_provider_to_workflow(self, workflow_name: str, connection_info: ConnectionInfo, provider: Provider):\n    #     \"\"\"\n    #     Function to add a provider to a workflow.\n\n    #     Args:\n    #         workflow_name (str): The name of the workflow.\n    #         connection_info (ConnectionInfo): The connection info of the provider.\n    #         provider (Provider): The provider to be added.\n    #     \"\"\"\n    #     if not workflow_name in self.workflow_providers:\n    #         self.workflow_providers[workflow_name] = []\n    #     self.workflow_providers[workflow_name].append((connection_info, provider))\n\n    # def add_consumer_to_workflow(self, workflow_name: str, connection_info: ConnectionInfo, connector: Connector):\n    #     \"\"\"\n    #     Function to add a consumer to a workflow.\n\n    #     Args:\n    #         workflow_name (str): The name of the workflow.\n    #         connection_info (ConnectionInfo): The connection info of the consumer.\n    #         connector (Connector): The connector to be added.\n    #     \"\"\"\n    #     if not workflow_name in self.workflow_consumers:\n    #         self.workflow_consumers[workflow_name] = []\n    #     self.workflow_consumers[workflow_name].append((connection_info, connector))\n\n    def get_workflows(self) -&gt; typing.List[Workflow]:\n        \"\"\"\n        Function to get the workflows in the registry.\n\n        Returns:\n            typing.List[Workflow]: The workflows in the registry.\n        \"\"\"\n        return list(self.workflows.values())\n\n    def get_workflow(self, workflow_name: str) -&gt; Workflow:\n        \"\"\"\n        Function to get a workflow from the registry.\n\n        Args:\n            workflow_name (str): The name of the workflow.\n\n        Returns:\n            Workflow: The workflow from the registry.\n\n        Raises:\n            KeyError: If the workflow is not in the registry.\n        \"\"\"\n        return self.workflows[workflow_name]\n\n    # def get_providers(self, workflow_name: str) -&gt; typing.List[typing.Tuple[ConnectionInfo, Provider]]:\n    #     \"\"\"\n    #     Function to get the providers of a workflow.\n\n    #     Args:\n    #         workflow_name (str): The name of the workflow.\n\n    #     Returns:\n    #         typing.List[typing.Tuple[ConnectionInfo, Provider]]: The providers of the workflow.\n    #     \"\"\"\n    #     return self.workflow_providers[workflow_name]\n\n    # def get_consumers(self, workflow_name: str) -&gt; typing.List[typing.Tuple[ConnectionInfo, Connector]]:\n    #     \"\"\"\n    #     Function to get the consumers of a workflow.\n\n    #     Args:\n    #         workflow_name (str): The name of the workflow.\n\n    #     Returns:\n    #         typing.List[typing.Tuple[ConnectionInfo, Connector]]: The consumers of the workflow.\n    #     \"\"\"\n    #     return self.workflow_consumers[workflow_name]\n\n    def get_workflow_names(self) -&gt; typing.List[str]:\n        \"\"\"\n        Function to get the names of the workflows in the registry.\n\n        Returns:\n            typing.List[str]: The names of the workflows in the registry.\n        \"\"\"\n        return list(self.workflows.keys())\n\n    def get_workflow_descriptions(self) -&gt; typing.List[WorkflowDescription]:\n        \"\"\"\n        Function to get the descriptions of the workflows in the registry.\n\n        Returns:\n            typing.List[WorkflowDescription]: The descriptions of the workflows in the registry.\n        \"\"\"\n        return [workflow.get_description() for workflow in self.workflows.values()]\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry.add_workflow","title":"<code>add_workflow(self, workflow)</code>","text":"<p>Function to add a workflow to the registry.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The workflow to be added.</p> required Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def add_workflow(self, workflow: Workflow):\n    \"\"\"\n    Function to add a workflow to the registry.\n\n    Args:\n        workflow (Workflow): The workflow to be added.\n    \"\"\"\n    self.workflows[workflow.get_name()] = workflow\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry.get_workflow","title":"<code>get_workflow(self, workflow_name)</code>","text":"<p>Function to get a workflow from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_name</code> <code>str</code> <p>The name of the workflow.</p> required <p>Returns:</p> Type Description <code>Workflow</code> <p>The workflow from the registry.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>If the workflow is not in the registry.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_workflow(self, workflow_name: str) -&gt; Workflow:\n    \"\"\"\n    Function to get a workflow from the registry.\n\n    Args:\n        workflow_name (str): The name of the workflow.\n\n    Returns:\n        Workflow: The workflow from the registry.\n\n    Raises:\n        KeyError: If the workflow is not in the registry.\n    \"\"\"\n    return self.workflows[workflow_name]\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry.get_workflow_descriptions","title":"<code>get_workflow_descriptions(self)</code>","text":"<p>Function to get the descriptions of the workflows in the registry.</p> <p>Returns:</p> Type Description <code>List[WorkflowDescription]</code> <p>The descriptions of the workflows in the registry.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_workflow_descriptions(self) -&gt; typing.List[WorkflowDescription]:\n    \"\"\"\n    Function to get the descriptions of the workflows in the registry.\n\n    Returns:\n        typing.List[WorkflowDescription]: The descriptions of the workflows in the registry.\n    \"\"\"\n    return [workflow.get_description() for workflow in self.workflows.values()]\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry.get_workflow_names","title":"<code>get_workflow_names(self)</code>","text":"<p>Function to get the names of the workflows in the registry.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The names of the workflows in the registry.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_workflow_names(self) -&gt; typing.List[str]:\n    \"\"\"\n    Function to get the names of the workflows in the registry.\n\n    Returns:\n        typing.List[str]: The names of the workflows in the registry.\n    \"\"\"\n    return list(self.workflows.keys())\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.registries.WorkflowRegistry.get_workflows","title":"<code>get_workflows(self)</code>","text":"<p>Function to get the workflows in the registry.</p> <p>Returns:</p> Type Description <code>List[Workflow]</code> <p>The workflows in the registry.</p> Source code in <code>aas_middleware\\middleware\\registries.py</code> <pre><code>def get_workflows(self) -&gt; typing.List[Workflow]:\n    \"\"\"\n    Function to get the workflows in the registry.\n\n    Returns:\n        typing.List[Workflow]: The workflows in the registry.\n    \"\"\"\n    return list(self.workflows.values())\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers","title":"<code>rest_routers</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.RestRouter","title":"<code> RestRouter        </code>","text":"Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>class RestRouter:\n    def __init__(self, data_model: DataModel, data_model_name: str, middleware: \"Middleware\"):\n        self.data_model = data_model\n        self.data_model_name = data_model_name\n        self.aas_data_model = data_model\n\n        self.middleware = middleware\n\n    def get_connector(self, item_id: str) -&gt; Connector:\n        return self.middleware.persistence_registry.get_connection(ConnectionInfo(data_model_name=self.data_model_name, model_id=item_id))\n\n    def generate_endpoints_from_contained_model(\n            self,\n        aas_model_type: Type[AAS], \n        attribute_name: str,\n        submodel_model_type: Type[Submodel],\n    ) -&gt; APIRouter:\n        \"\"\"\n        Generates CRUD endpoints for a submodel of a pydantic model representing an aas.\n\n        Args:\n            aas_model_type (Type[BaseModel]): Pydantic model representing the aas of the submodel.\n            submodel_model_type (Type[base.Submodel]): Pydantic model representing the submodel.\n\n        Returns:\n            APIRouter: FastAPI router with CRUD endpoints for the given submodel that performs Middleware syxnchronization.\n        \"\"\"\n        model_name = aas_model_type.__name__\n        optional_submodel = check_if_attribute_is_optional_in_aas(aas_model_type, attribute_name)\n        # TODO: the data model name should be used for creating the endpoint\n        # TODO: adjust that no aas or submodel reference appears in the router -&gt; should work for all models.\n        router = APIRouter(\n            prefix=f\"/{model_name}/{{item_id}}/{attribute_name}\",\n            tags=[model_name],\n            responses={404: {\"description\": \"Not found\"}},\n        )\n\n        @router.get(\n            \"/\",\n            response_model=submodel_model_type,\n        )\n        async def get_item(item_id: str):\n            try:\n                model = await self.get_connector(item_id).provide()\n                return getattr(model, attribute_name)\n            except Exception as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"Submodel with id {item_id} could not be retrieved. Error: {e}\"\n                )\n\n        if optional_submodel:\n            @router.post(\"/\")\n            async def post_item(item_id: str, item: submodel_model_type) -&gt; Dict[str, str]:\n                connector = self.get_connector(item_id)\n                try: \n                    provided_data = await connector.provide()\n                    # TODO: update that the correct type is immediately returned -&gt; using model validate inside the connector\n                    provided_data_dict = provided_data.model_dump()\n                    model = aas_model_type.model_validate(provided_data_dict)\n                    setattr(model, attribute_name, item)\n                    await connector.consume(model)\n                    return {\n                        \"message\": f\"Succesfully created attribute {attribute_name} of aas with id {item_id}\"\n                    }\n                except Exception as e:\n                    raise HTTPException(\n                        status_code=400, detail=f\"Attribute {attribute_name} for model with id {item_id} could not be set. Error: {e}\"\n                    )\n\n        @router.put(\"/\")\n        async def put_item(item_id: str, item: submodel_model_type) -&gt; Dict[str, str]:\n            connector = self.get_connector(item_id)\n            try:\n                model = await connector.provide()\n                if getattr(model, attribute_name) == item:\n                    return {\n                        \"message\": f\"Attribute {attribute_name} of model with id {item_id} is already up to date\"\n                    }\n                setattr(model, attribute_name, item)\n                await connector.consume(model)\n                return {\n                    \"message\": f\"Succesfully updated attribute {attribute_name} of model with id {item_id}\"\n                }\n            except Exception as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"Attribute {attribute_name} of model with id {item_id} could not be updated. Error: {e}\"\n                )\n\n        if optional_submodel:\n\n            @router.delete(\"/\")\n            async def delete_item(item_id: str):\n                connector = self.get_connector(item_id)\n                try:\n                    model = await connector.provide()\n                    setattr(model, attribute_name, None)\n                    await connector.consume(model)\n                    return {\n                        \"message\": f\"Succesfully deleted attribute {attribute_name} of model with id {item_id}\"\n                    }\n                except Exception as e:\n                    raise HTTPException(\n                        status_code=400, detail=f\"attribute {attribute_name} of model with id {item_id} could not be deleted. Error: {e}\"\n                    )\n\n        return router\n\n\n    def generate_aas_endpoints_from_model(self, aas_model_type: Type[AAS]) -&gt; APIRouter:\n        \"\"\"\n        Generates CRUD endpoints for a pydantic model representing an aas.\n\n        Args:\n            aas_model_type (Type[AAS]): Pydantic model representing an aas\n\n        Returns:\n            APIRouter: FastAPI router with CRUD endpoints for the given pydantic model that performs Middleware syxnchronization.\n        \"\"\"\n        router = APIRouter(\n            prefix=f\"/{aas_model_type.__name__}\",\n            tags=[aas_model_type.__name__],\n            responses={404: {\"description\": \"Not found\"}},\n        )\n\n        @router.get(\"/\", response_model=List[aas_model_type])\n        async def get_items():\n            aas_list = []\n            connection_infos = self.middleware.persistence_registry.get_type_connection_info(aas_model_type.__name__)\n            for connection_info in connection_infos:\n                connector = self.middleware.persistence_registry.get_connection(connection_info)\n                retrieved_aas = await connector.provide()\n                aas_list.append(retrieved_aas)\n            return aas_list\n\n        @router.post(f\"/\", response_model=Dict[str, str])\n        async def post_item(item: aas_model_type) -&gt; Dict[str, str]:\n            try:\n                await self.middleware.persist(data_model_name=self.data_model_name, model=item)\n                return {\n                    \"message\": f\"Succesfully created aas {aas_model_type.__name__} with id {item.id}\"\n                }\n            except ValueError:\n                raise HTTPException(\n                    status_code=400, detail=f\"AAS with id {item.id} already exists\"\n                )\n\n        @router.get(\"/{item_id}\", response_model=aas_model_type)\n        async def get_item(item_id: str):\n            try:\n                connector = self.get_connector(item_id)\n                provided_data = await connector.provide()\n                # TODO: update that the correct type is immediately returned -&gt; using model validate inside the connector\n                provided_data_dict = provided_data.model_dump()\n                return aas_model_type.model_validate(provided_data_dict)\n            except Exception as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"AAS with id {item_id} could not be retrieved. Error: {e}\"\n                )\n\n        @router.put(\"/{item_id}\")\n        async def put_item(item_id: str, item: aas_model_type) -&gt; Dict[str, str]:\n            try:\n                consumer = self.get_connector(item_id)\n            except KeyError as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"AAS with id {item_id} could not be retrieved. Try posting it at first.\"\n                )\n\n            # TODO: add some exception handling below\n            if item_id == item.id:\n                await consumer.consume(item)\n            else:\n                await self.middleware.persist(data_model_name=self.data_model_name, model=item)     \n                await delete_item(item_id)\n\n            return {\"message\": f\"Succesfully updated aas with id {item.id}\"}\n\n        @router.delete(\"/{item_id}\")\n        async def delete_item(item_id: str):\n            await self.get_connector(item_id).consume(None)\n            self.middleware.persistence_registry.remove_connection(ConnectionInfo(data_model_name=self.data_model_name, model_id=item_id))\n            return {\"message\": f\"Succesfully deleted aas with id {item_id}\"}\n\n        return router\n\n\n\n    def generate_endpoints_from_model(self, pydantic_model: Type[BaseModel]) -&gt; List[APIRouter]:\n        \"\"\"\n        Generates CRUD endpoints for a pydantic model representing an aas and its submodels.\n\n        Args:\n            pydantic_model (Type[BaseModel]): Pydantic model representing an aas with submodels.\n\n        Returns:\n            List[APIRouter]: List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.\n        \"\"\"\n        routers = []\n        routers.append(self.generate_aas_endpoints_from_model(pydantic_model))\n        attribute_infos = get_contained_models_attribute_info(pydantic_model)\n        for attribute_name, contained_model in attribute_infos:\n            routers.append(self.generate_endpoints_from_contained_model(pydantic_model, attribute_name, contained_model))\n        return routers\n\n\n    def generate_endpoints(self) -&gt; List[APIRouter]:\n        \"\"\"\n        Generates CRUD endpoints for a pydantic model representing an aas and its submodels.\n\n        Returns:\n            List[APIRouter]: List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.\n        \"\"\"\n        routers = []\n\n        for top_level_model_type in self.aas_data_model.get_top_level_types():\n            routers += self.generate_endpoints_from_model(top_level_model_type)\n        return routers\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.RestRouter.generate_aas_endpoints_from_model","title":"<code>generate_aas_endpoints_from_model(self, aas_model_type)</code>","text":"<p>Generates CRUD endpoints for a pydantic model representing an aas.</p> <p>Parameters:</p> Name Type Description Default <code>aas_model_type</code> <code>Type[AAS]</code> <p>Pydantic model representing an aas</p> required <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with CRUD endpoints for the given pydantic model that performs Middleware syxnchronization.</p> Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>def generate_aas_endpoints_from_model(self, aas_model_type: Type[AAS]) -&gt; APIRouter:\n    \"\"\"\n    Generates CRUD endpoints for a pydantic model representing an aas.\n\n    Args:\n        aas_model_type (Type[AAS]): Pydantic model representing an aas\n\n    Returns:\n        APIRouter: FastAPI router with CRUD endpoints for the given pydantic model that performs Middleware syxnchronization.\n    \"\"\"\n    router = APIRouter(\n        prefix=f\"/{aas_model_type.__name__}\",\n        tags=[aas_model_type.__name__],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.get(\"/\", response_model=List[aas_model_type])\n    async def get_items():\n        aas_list = []\n        connection_infos = self.middleware.persistence_registry.get_type_connection_info(aas_model_type.__name__)\n        for connection_info in connection_infos:\n            connector = self.middleware.persistence_registry.get_connection(connection_info)\n            retrieved_aas = await connector.provide()\n            aas_list.append(retrieved_aas)\n        return aas_list\n\n    @router.post(f\"/\", response_model=Dict[str, str])\n    async def post_item(item: aas_model_type) -&gt; Dict[str, str]:\n        try:\n            await self.middleware.persist(data_model_name=self.data_model_name, model=item)\n            return {\n                \"message\": f\"Succesfully created aas {aas_model_type.__name__} with id {item.id}\"\n            }\n        except ValueError:\n            raise HTTPException(\n                status_code=400, detail=f\"AAS with id {item.id} already exists\"\n            )\n\n    @router.get(\"/{item_id}\", response_model=aas_model_type)\n    async def get_item(item_id: str):\n        try:\n            connector = self.get_connector(item_id)\n            provided_data = await connector.provide()\n            # TODO: update that the correct type is immediately returned -&gt; using model validate inside the connector\n            provided_data_dict = provided_data.model_dump()\n            return aas_model_type.model_validate(provided_data_dict)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=f\"AAS with id {item_id} could not be retrieved. Error: {e}\"\n            )\n\n    @router.put(\"/{item_id}\")\n    async def put_item(item_id: str, item: aas_model_type) -&gt; Dict[str, str]:\n        try:\n            consumer = self.get_connector(item_id)\n        except KeyError as e:\n            raise HTTPException(\n                status_code=400, detail=f\"AAS with id {item_id} could not be retrieved. Try posting it at first.\"\n            )\n\n        # TODO: add some exception handling below\n        if item_id == item.id:\n            await consumer.consume(item)\n        else:\n            await self.middleware.persist(data_model_name=self.data_model_name, model=item)     \n            await delete_item(item_id)\n\n        return {\"message\": f\"Succesfully updated aas with id {item.id}\"}\n\n    @router.delete(\"/{item_id}\")\n    async def delete_item(item_id: str):\n        await self.get_connector(item_id).consume(None)\n        self.middleware.persistence_registry.remove_connection(ConnectionInfo(data_model_name=self.data_model_name, model_id=item_id))\n        return {\"message\": f\"Succesfully deleted aas with id {item_id}\"}\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.RestRouter.generate_endpoints","title":"<code>generate_endpoints(self)</code>","text":"<p>Generates CRUD endpoints for a pydantic model representing an aas and its submodels.</p> <p>Returns:</p> Type Description <code>List[APIRouter]</code> <p>List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.</p> Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>def generate_endpoints(self) -&gt; List[APIRouter]:\n    \"\"\"\n    Generates CRUD endpoints for a pydantic model representing an aas and its submodels.\n\n    Returns:\n        List[APIRouter]: List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.\n    \"\"\"\n    routers = []\n\n    for top_level_model_type in self.aas_data_model.get_top_level_types():\n        routers += self.generate_endpoints_from_model(top_level_model_type)\n    return routers\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.RestRouter.generate_endpoints_from_contained_model","title":"<code>generate_endpoints_from_contained_model(self, aas_model_type, attribute_name, submodel_model_type)</code>","text":"<p>Generates CRUD endpoints for a submodel of a pydantic model representing an aas.</p> <p>Parameters:</p> Name Type Description Default <code>aas_model_type</code> <code>Type[BaseModel]</code> <p>Pydantic model representing the aas of the submodel.</p> required <code>submodel_model_type</code> <code>Type[base.Submodel]</code> <p>Pydantic model representing the submodel.</p> required <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with CRUD endpoints for the given submodel that performs Middleware syxnchronization.</p> Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>def generate_endpoints_from_contained_model(\n        self,\n    aas_model_type: Type[AAS], \n    attribute_name: str,\n    submodel_model_type: Type[Submodel],\n) -&gt; APIRouter:\n    \"\"\"\n    Generates CRUD endpoints for a submodel of a pydantic model representing an aas.\n\n    Args:\n        aas_model_type (Type[BaseModel]): Pydantic model representing the aas of the submodel.\n        submodel_model_type (Type[base.Submodel]): Pydantic model representing the submodel.\n\n    Returns:\n        APIRouter: FastAPI router with CRUD endpoints for the given submodel that performs Middleware syxnchronization.\n    \"\"\"\n    model_name = aas_model_type.__name__\n    optional_submodel = check_if_attribute_is_optional_in_aas(aas_model_type, attribute_name)\n    # TODO: the data model name should be used for creating the endpoint\n    # TODO: adjust that no aas or submodel reference appears in the router -&gt; should work for all models.\n    router = APIRouter(\n        prefix=f\"/{model_name}/{{item_id}}/{attribute_name}\",\n        tags=[model_name],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.get(\n        \"/\",\n        response_model=submodel_model_type,\n    )\n    async def get_item(item_id: str):\n        try:\n            model = await self.get_connector(item_id).provide()\n            return getattr(model, attribute_name)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=f\"Submodel with id {item_id} could not be retrieved. Error: {e}\"\n            )\n\n    if optional_submodel:\n        @router.post(\"/\")\n        async def post_item(item_id: str, item: submodel_model_type) -&gt; Dict[str, str]:\n            connector = self.get_connector(item_id)\n            try: \n                provided_data = await connector.provide()\n                # TODO: update that the correct type is immediately returned -&gt; using model validate inside the connector\n                provided_data_dict = provided_data.model_dump()\n                model = aas_model_type.model_validate(provided_data_dict)\n                setattr(model, attribute_name, item)\n                await connector.consume(model)\n                return {\n                    \"message\": f\"Succesfully created attribute {attribute_name} of aas with id {item_id}\"\n                }\n            except Exception as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"Attribute {attribute_name} for model with id {item_id} could not be set. Error: {e}\"\n                )\n\n    @router.put(\"/\")\n    async def put_item(item_id: str, item: submodel_model_type) -&gt; Dict[str, str]:\n        connector = self.get_connector(item_id)\n        try:\n            model = await connector.provide()\n            if getattr(model, attribute_name) == item:\n                return {\n                    \"message\": f\"Attribute {attribute_name} of model with id {item_id} is already up to date\"\n                }\n            setattr(model, attribute_name, item)\n            await connector.consume(model)\n            return {\n                \"message\": f\"Succesfully updated attribute {attribute_name} of model with id {item_id}\"\n            }\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=f\"Attribute {attribute_name} of model with id {item_id} could not be updated. Error: {e}\"\n            )\n\n    if optional_submodel:\n\n        @router.delete(\"/\")\n        async def delete_item(item_id: str):\n            connector = self.get_connector(item_id)\n            try:\n                model = await connector.provide()\n                setattr(model, attribute_name, None)\n                await connector.consume(model)\n                return {\n                    \"message\": f\"Succesfully deleted attribute {attribute_name} of model with id {item_id}\"\n                }\n            except Exception as e:\n                raise HTTPException(\n                    status_code=400, detail=f\"attribute {attribute_name} of model with id {item_id} could not be deleted. Error: {e}\"\n                )\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.RestRouter.generate_endpoints_from_model","title":"<code>generate_endpoints_from_model(self, pydantic_model)</code>","text":"<p>Generates CRUD endpoints for a pydantic model representing an aas and its submodels.</p> <p>Parameters:</p> Name Type Description Default <code>pydantic_model</code> <code>Type[BaseModel]</code> <p>Pydantic model representing an aas with submodels.</p> required <p>Returns:</p> Type Description <code>List[APIRouter]</code> <p>List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.</p> Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>def generate_endpoints_from_model(self, pydantic_model: Type[BaseModel]) -&gt; List[APIRouter]:\n    \"\"\"\n    Generates CRUD endpoints for a pydantic model representing an aas and its submodels.\n\n    Args:\n        pydantic_model (Type[BaseModel]): Pydantic model representing an aas with submodels.\n\n    Returns:\n        List[APIRouter]: List of FastAPI routers with CRUD endpoints for the given pydantic model and its submodels that perform Middleware syxnchronization.\n    \"\"\"\n    routers = []\n    routers.append(self.generate_aas_endpoints_from_model(pydantic_model))\n    attribute_infos = get_contained_models_attribute_info(pydantic_model)\n    for attribute_name, contained_model in attribute_infos:\n        routers.append(self.generate_endpoints_from_contained_model(pydantic_model, attribute_name, contained_model))\n    return routers\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.rest_routers.check_if_attribute_is_optional_in_aas","title":"<code>check_if_attribute_is_optional_in_aas(aas, attribute_name)</code>","text":"<p>Checks if a submodel is an optional attribute in an aas.</p> <p>Parameters:</p> Name Type Description Default <code>aas</code> <code>Type[base.AAS]</code> <p>AAS model.</p> required <code>submodel</code> <code>Type[base.Submodel]</code> <p>Submodel to be checked.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the submodel is not a submodel of the aas.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the submodel is an optional attribute in the aas, False otherwise.</p> Source code in <code>aas_middleware\\middleware\\rest_routers.py</code> <pre><code>def check_if_attribute_is_optional_in_aas(\n    aas: Type[AAS], attribute_name: str\n    ) -&gt; bool:\n    \"\"\"\n    Checks if a submodel is an optional attribute in an aas.\n\n    Args:\n        aas (Type[base.AAS]): AAS model.\n        submodel (Type[base.Submodel]): Submodel to be checked.\n\n    Raises:\n        ValueError: If the submodel is not a submodel of the aas.\n\n    Returns:\n        bool: True if the submodel is an optional attribute in the aas, False otherwise.\n    \"\"\"\n    if attribute_name not in aas.model_fields:\n        raise ValueError(\n            f\"Submodel {attribute_name} is not a submodel attribute of {aas.__name__}.\"\n        )\n    field_info = aas.model_fields[attribute_name]\n    if not field_info.is_required():\n        return True\n    elif typing.get_origin(field_info.annotation) == Union and type(None) in typing.get_args(field_info.annotation):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.synchronization","title":"<code>synchronization</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.synchronization.synchronize_connector_with_persistence","title":"<code>synchronize_connector_with_persistence(connector, connection_info, persistence_registry)</code>","text":"<p>Synchronizes a connector with the persistence layer.</p> <p>Parameters:</p> Name Type Description Default <code>connector</code> <code>Union[Consumer, Provider]</code> <p>The connector to synchronize.</p> required <code>connection_info</code> <code>ConnectionInfo</code> <p>The connection info for the persistence layer.</p> required <code>persistence_registry</code> <code>PersistenceConnectionRegistry</code> <p>The registry for the persistence connectors.    </p> required Source code in <code>aas_middleware\\middleware\\synchronization.py</code> <pre><code>def synchronize_connector_with_persistence(connector: Union[Consumer, Provider], connection_info: ConnectionInfo, persistence_registry: PersistenceConnectionRegistry):\n    \"\"\"\n    Synchronizes a connector with the persistence layer.\n\n    Args:\n        connector (Union[Consumer, Provider]): The connector to synchronize.\n        connection_info (ConnectionInfo): The connection info for the persistence layer.\n        persistence_registry (PersistenceConnectionRegistry): The registry for the persistence connectors.    \n    \"\"\"\n    if isinstance(connector, Consumer):\n        original_consume = connector.consume\n\n        @wraps(connector.consume)\n        async def wrapped_consume(body: Any):\n            persistence_connector = persistence_registry.get_connector_by_data_model_and_model_id(data_model_name=connection_info.data_model_name, model_id=connection_info.model_id)\n            if body is None:\n                # TODO: data model connection info is not yet possible\n                body = await get_persistence_value(persistence_connector, connection_info)\n            else:\n                await update_persistence_with_value(persistence_connector, connection_info, body)\n            await original_consume(body)\n\n        connector.consume = wrapped_consume\n\n    if isinstance(connector, Provider):\n        original_provide = connector.provide\n\n        @wraps(connector.provide)\n        async def wrapped_provide() -&gt; Any:\n            persistence_connector = persistence_registry.get_connector_by_data_model_and_model_id(data_model_name=connection_info.data_model_name, model_id=connection_info.model_id)\n            body = await original_provide()\n            await update_persistence_with_value(persistence_connector, connection_info, body)\n            return body\n\n        connector.provide = wrapped_provide\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.workflow_router","title":"<code>workflow_router</code>","text":""},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.workflow_router.generate_workflow_endpoint","title":"<code>generate_workflow_endpoint(workflow)</code>","text":"<p>Generates endpoints for a workflow to execute the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>Workflow that contains the function to be executed by the workflow.</p> required <p>Returns:</p> Type Description <code>APIRouter</code> <p>FastAPI router with an endpoint to execute the workflow.</p> Source code in <code>aas_middleware\\middleware\\workflow_router.py</code> <pre><code>def generate_workflow_endpoint(workflow: Workflow) -&gt; List[APIRouter]:\n    \"\"\"\n    Generates endpoints for a workflow to execute the workflow.\n\n    Args:\n        workflow (Workflow): Workflow that contains the function to be executed by the workflow.\n\n    Returns:\n        APIRouter: FastAPI router with an endpoint to execute the workflow.\n    \"\"\"\n    router = APIRouter(\n        prefix=f\"/workflows/{workflow.get_name()}\",\n        tags=[\"workflows\"],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    if isinstance(workflow.workflow_function, functools.partial):\n        type_hints = get_partial_type_hints(workflow.workflow_function)\n    else:\n        type_hints = typing.get_type_hints(workflow.workflow_function)\n\n    return_type = type_hints.pop(\"return\") if \"return\" in type_hints else None\n    if len(type_hints) == 0:\n        input_type_hints = None\n    elif len(type_hints) == 1:\n        input_type_hints = list(type_hints.values())[0]\n    else:\n        input_type_hints = get_base_model_from_type_hints(workflow.get_name(), type_hints)\n\n\n    if input_type_hints is None:\n        if workflow.get_description().interval is None:\n            @router.post(\"/execute\", response_model=return_type)\n            async def execute():\n                if workflow.running:\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Workflow {workflow.get_name()} is already running. Wait for it to finish or interrupt it first.\",\n                    )\n                return await workflow.execute()\n\n        @router.post(\"/execute_background\", response_model=Dict[str, str])\n        async def execute_background(background_tasks: BackgroundTasks):\n            if workflow.running:\n                raise HTTPException(\n                    status_code=400,\n                    detail=f\"Workflow {workflow.get_name()} is already running. Wait for it to finish or interrupt it first.\",\n                )\n            background_tasks.add_task(workflow.execute)\n            return {\"message\": f\"Started exeuction of workflow {workflow.get_name()}\"}\n    else:\n        if workflow.get_description().interval is None:\n            @router.post(\"/execute\", response_model=return_type)\n            async def execute(arg: input_type_hints): # type: ignore\n                if workflow.running:\n                    raise HTTPException(\n                        status_code=400,\n                        detail=f\"Workflow {workflow.get_name()} is already running. Wait for it to finish or interrupt it first.\",\n                    )\n                if isinstance(arg, BaseModel) and len(type_hints) &gt; 1:\n                    input_value = dict(arg)\n                    return await workflow.execute(**input_value)\n                else:\n                    return await workflow.execute(arg)\n\n        @router.post(\"/execute_background\", response_model=Dict[str, str])\n        async def execute_background(background_tasks: BackgroundTasks, arg: input_type_hints): # type: ignore\n            if workflow.running:\n                raise HTTPException(\n                    status_code=400,\n                    detail=f\"Workflow {workflow.get_name()} is already running. Wait for it to finish or interrupt it first.\",\n                )\n            if isinstance(arg, BaseModel) and len(type_hints) &gt; 1:\n                input_value = dict(arg)\n                background_tasks.add_task(workflow.execute, **input_value)\n            else:\n                background_tasks.add_task(workflow.execute, arg.model_dump())\n            return {\"message\": f\"Started exeuction of workflow {workflow.get_name()}\"}\n\n\n    @router.get(\"/description\", response_model=WorkflowDescription)\n    async def describe_workflow():\n        return workflow.get_description()\n\n    @router.get(\"/interrupt\", response_model=Dict[str, str])\n    async def interrupt_workflow():\n        try:\n            await workflow.interrupt()\n        except ValueError as e:\n            raise HTTPException(status_code=400, detail=str(e))\n        return {\"message\": f\"Stopped execution of workflow {workflow.get_name()}\"}\n\n    return router\n</code></pre>"},{"location":"API_reference/API_reference_2_middleware/#aas_middleware.middleware.workflow_router.get_base_model_from_type_hints","title":"<code>get_base_model_from_type_hints(name, type_hints)</code>","text":"<p>Get the base model from the type hints of a function.</p> <p>Parameters:</p> Name Type Description Default <code>type_hints</code> <code>Dict[str, Any]</code> <p>Type hints of a function.</p> required <p>Returns:</p> Type Description <code>Type[Any]</code> <p>Base model of the type hints.</p> Source code in <code>aas_middleware\\middleware\\workflow_router.py</code> <pre><code>def get_base_model_from_type_hints(name: str, type_hints: Dict[str, typing.Any]) -&gt; typing.Type[BaseModel]:\n    \"\"\"\n    Get the base model from the type hints of a function.\n\n    Args:\n        type_hints (Dict[str, typing.Any]): Type hints of a function.\n\n    Returns:\n        typing.Type[typing.Any]: Base model of the type hints.\n    \"\"\"\n    if \"return\" in type_hints:\n        type_hints.pop(\"return\")\n    dynamical_model_creation_dict = {}\n    for argument, argument_type in type_hints.items():\n        entry = {\n            argument: typing.Annotated[\n                argument_type, Field()\n            ]\n        }\n        dynamical_model_creation_dict.update(entry)\n    base_model = create_model(f\"body_for_{name}\", **dynamical_model_creation_dict)\n    return base_model\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/","title":"Connect API","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors","title":"<code>connectors</code>  <code>special</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector","title":"<code>aas_client_connector</code>  <code>special</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client","title":"<code>aas_client</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.aas_is_on_server","title":"<code>aas_is_on_server(aas_id, aas_client)</code>  <code>async</code>","text":"<p>Function to check if an AAS with the given id is on the server</p> <p>Parameters:</p> Name Type Description Default <code>aas_id</code> <code>str</code> <p>id of the AAS</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if AAS is on server, False if not</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def aas_is_on_server(aas_id: str, aas_client: AASClient) -&gt; bool:\n    \"\"\"\n    Function to check if an AAS with the given id is on the server\n    Args:\n        aas_id (str): id of the AAS\n    Returns:\n        bool: True if AAS is on server, False if not\n    \"\"\"\n    try:\n        await get_basyx_aas_from_server(aas_id, aas_client)\n        return True\n    except Exception as e:\n        return False\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.delete_aas_from_server","title":"<code>delete_aas_from_server(aas_id, aas_client)</code>  <code>async</code>","text":"<p>Function to delete an AAS from the server</p> <p>Parameters:</p> Name Type Description Default <code>aas_id</code> <code>str</code> <p>id of the AAS</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If AAS with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def delete_aas_from_server(aas_id: str, aas_client: AASClient):\n    \"\"\"\n    Function to delete an AAS from the server\n    Args:\n        aas_id (str): id of the AAS\n\n    Raises:\n        HTTPException: If AAS with the given id does not exist\n    \"\"\"\n    if not await aas_is_on_server(aas_id, aas_client):\n        raise HTTPException(\n            status_code=400, detail=f\"AAS with id {aas_id} does not exist. Cannot delete it.\"\n        )\n    base_64_id = client_utils.get_base64_from_string(aas_id)\n    response = await delete_asset_administration_shell_by_id.asyncio(\n        client=aas_client, aas_identifier=base_64_id\n    )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.get_aas_from_server","title":"<code>get_aas_from_server(aas_id, aas_client, submodel_client)</code>  <code>async</code>","text":"<p>Function to get an AAS from the server</p> <p>Parameters:</p> Name Type Description Default <code>aas_id</code> <code>str</code> <p>id of the AAS</p> required <p>Returns:</p> Type Description <code>aas_model.AAS</code> <p>AAS retrieved from the server</p> <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If AAS with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def get_aas_from_server(aas_id: str, aas_client: AASClient, submodel_client: SubmodelClient) -&gt; aas_model.AAS:\n    \"\"\"\n    Function to get an AAS from the server\n    Args:\n        aas_id (str): id of the AAS\n    Returns:\n        aas_model.AAS: AAS retrieved from the server\n\n    Raises:\n        HTTPException: If AAS with the given id does not exist\n    \"\"\"\n    try: \n        aas = await get_basyx_aas_from_server(aas_id, aas_client)\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"AAS with id {aas_id} could not be retrieved. Error: {e}\"\n        )\n    try:\n        aas_submodels = await get_all_basyx_submodels_from_server(aas, submodel_client)\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Submodels of AAS with id {aas_id} could not be retrieved. Error: {e}\"\n        )\n\n    obj_store = model.DictObjectStore()\n    obj_store.add(aas)\n    [obj_store.add(submodel) for submodel in aas_submodels]\n\n    data_model = BasyxFormatter().deserialize(obj_store)\n    model_data = data_model.get_model(aas_id)\n\n    return model_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.get_all_aas_from_server","title":"<code>get_all_aas_from_server(pydantic_model, aas_client, submodel_client)</code>  <code>async</code>","text":"<p>Function to get all AAS from the server</p> <p>Returns:</p> Type Description <code>List[aas_model.AAS]</code> <p>List of AAS retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def get_all_aas_from_server(pydantic_model: BaseModel, aas_client: AASClient, submodel_client: SubmodelClient) -&gt; List[aas_model.AAS]:\n    \"\"\"\n    Function to get all AAS from the server\n    Returns:\n        List[aas_model.AAS]: List of AAS retrieved from the server\n    \"\"\"\n    result_string = await get_all_asset_administration_shells.asyncio(client=aas_client)\n    aas_data = result_string[\"result\"]\n    aas_list = [client_utils.transform_client_to_basyx_model(aas) for aas in aas_data]\n\n    submodels = []\n    for aas in aas_list:\n        aas_submodels = await get_all_basyx_submodels_from_server(aas, submodel_client)\n        submodels.extend(aas_submodels)\n    obj_store = model.DictObjectStore()\n    [obj_store.add(aas) for aas in aas_list]\n    [obj_store.add(submodel) for submodel in submodels if not any(submodel.id == other_sm.id for other_sm in obj_store)]\n\n    data_model = BasyxFormatter().deserialize(model_data)\n    model_data = data_model.get_models_of_type(aas_model.AAS)\n    model_data = [model for model in model_data if model.__class__.__name__ == pydantic_model.__name__]\n    return model_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.get_basyx_aas_from_server","title":"<code>get_basyx_aas_from_server(aas_id, aas_client)</code>  <code>async</code>","text":"<p>Function to get an AAS from the server</p> <p>Parameters:</p> Name Type Description Default <code>aas_id</code> <code>str</code> <p>id of the AAS</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If AAS with the given id does not exist</p> <p>Returns:</p> Type Description <code>model.AssetAdministrationShell</code> <p>AAS retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def get_basyx_aas_from_server(aas_id: str, aas_client: AASClient) -&gt; model.AssetAdministrationShell:\n    \"\"\"\n    Function to get an AAS from the server\n    Args:\n        aas_id (str): id of the AAS\n    Raises:\n        HTTPException: If AAS with the given id does not exist\n    Returns:\n        model.AssetAdministrationShell: AAS retrieved from the server\n    \"\"\"\n    base_64_id = client_utils.get_base64_from_string(aas_id)\n    try:\n        aas_data = await get_asset_administration_shell_by_id.asyncio(\n            client=aas_client, aas_identifier=base_64_id\n        )\n        return client_utils.transform_client_to_basyx_model(aas_data.to_dict())\n    except Exception as e:\n        raise ConnectionError(\n            e\n        )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.get_submodel_from_aas_id_and_class_name","title":"<code>get_submodel_from_aas_id_and_class_name(aas_id, class_name, aas_client, submodel_client)</code>  <code>async</code>","text":"<p>Function to get a submodel from the server based on the AAS id and the class name of the submodel</p> <p>Parameters:</p> Name Type Description Default <code>aas_id</code> <code>str</code> <p>id of the AAS</p> required <code>class_name</code> <code>str</code> <p>class name of the submodel</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given class name does not exist for the given AAS</p> <p>Returns:</p> Type Description <code>aas_model.Submodel</code> <p>submodel retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def get_submodel_from_aas_id_and_class_name(aas_id: str, class_name: str, aas_client: AASClient, submodel_client: SubmodelClient) -&gt; aas_model.Submodel:\n    \"\"\"\n    Function to get a submodel from the server based on the AAS id and the class name of the submodel\n    Args:\n        aas_id (str): id of the AAS\n        class_name (str): class name of the submodel\n    Raises:\n        HTTPException: If submodel with the given class name does not exist for the given AAS\n    Returns:\n        aas_model.Submodel: submodel retrieved from the server\n    \"\"\"\n    basyx_aas = await get_basyx_aas_from_server(aas_id, aas_client)\n    for basyx_submodel in basyx_aas.submodel:\n        submodel_id = basyx_submodel.key[0].value\n        submodel = await get_submodel_from_server(submodel_id, submodel_client)\n        if submodel.__class__.__name__ == class_name:\n            return submodel\n    raise HTTPException(\n        status_code=411,\n        detail=f\"Submodel with name {class_name} does not exist for AAS with id {aas_id}\",\n    )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.post_aas_to_server","title":"<code>post_aas_to_server(aas, aas_client, submodel_client)</code>  <code>async</code>","text":"<p>Function to post an AAS to the server. Also posts all submodels of the AAS to the server, if they do not exist yet.</p> <p>Parameters:</p> Name Type Description Default <code>aas</code> <code>aas_model.AAS</code> <p>AAS to post</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If AAS with the given id already exists</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def post_aas_to_server(aas: aas_model.AAS, aas_client: AASClient, submodel_client: SubmodelClient):\n    \"\"\"\n    Function to post an AAS to the server. Also posts all submodels of the AAS to the server, if they do not exist yet.\n    Args:\n        aas (aas_model.AAS): AAS to post\n    Raises:\n        HTTPException: If AAS with the given id already exists\n    \"\"\"\n    if await aas_is_on_server(aas.id, aas_client):\n        raise HTTPException(\n            status_code=400, detail=f\"AAS with id {aas.id} already exists\"\n        )\n    check_aas_for_duplicate_ids(aas)\n    obj_store = convert_model_to_aas(aas)\n    basyx_aas = obj_store.get(aas.id)\n    aas_for_client = ClientModel(basyx_object=basyx_aas)\n    response = await post_asset_administration_shell.asyncio(\n        client=aas_client, body=aas_for_client\n    )\n\n    aas_attributes = get_value_attributes(aas)\n    for submodel in aas_attributes.values():\n        if not await submodel_is_on_server(submodel.id, submodel_client):\n            await post_submodel_to_server(submodel, submodel_client)\n        else:\n            logger.info(f\"Submodel with id {submodel.id} already exists on the server. Updating the value.\")\n            await put_submodel_to_server(submodel, submodel_client)\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.aas_client.put_aas_to_server","title":"<code>put_aas_to_server(aas, aas_client, submodel_client)</code>  <code>async</code>","text":"<p>Function to put an AAS to the server</p> <p>Parameters:</p> Name Type Description Default <code>aas</code> <code>aas_model.AAS</code> <p>AAS to put</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If AAS with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\aas_client.py</code> <pre><code>async def put_aas_to_server(aas: aas_model.AAS, aas_client: AASClient, submodel_client: SubmodelClient):\n    \"\"\"\n    Function to put an AAS to the server\n    Args:\n        aas (aas_model.AAS): AAS to put\n    Raises:\n        HTTPException: If AAS with the given id does not exist\n    \"\"\"\n    if not await aas_is_on_server(aas.id, aas_client):\n        raise HTTPException(\n            status_code=400, detail=f\"AAS with id {aas.id} does not exist\"\n        )\n    obj_store = convert_model_to_aas(aas)\n    basyx_aas = obj_store.get(aas.id)\n    aas_for_client = ClientModel(basyx_object=basyx_aas)\n    base_64_id = client_utils.get_base64_from_string(aas.id)\n    await put_asset_administration_shell_by_id.asyncio(\n        aas_identifier=base_64_id, client=aas_client, body=aas_for_client\n    )\n\n    for submodel in get_value_attributes(aas).values():\n        if await submodel_is_on_server(submodel.id, submodel_client):\n            await put_submodel_to_server(submodel, submodel_client)\n        else:\n            await post_submodel_to_server(submodel, submodel_client)\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.client_utils","title":"<code>client_utils</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.client_utils.transform_client_to_basyx_model","title":"<code>transform_client_to_basyx_model(client_model)</code>","text":"<p>Function to transform a client model to a basyx model</p> <p>Parameters:</p> Name Type Description Default <code>response_model</code> <code>dict</code> <p>dictionary from server client that needs to be transformed</p> required <p>Returns:</p> Type Description <code>Union[model.AssetAdministrationShell, model.Submodel]</code> <p>basyx model from the given client model</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\client_utils.py</code> <pre><code>def transform_client_to_basyx_model(\n    client_model: dict | Any,\n) -&gt; Union[model.AssetAdministrationShell, model.Submodel]:\n    \"\"\"\n    Function to transform a client model to a basyx model\n    Args:\n        response_model (dict): dictionary from server client that needs to be transformed\n    Returns:\n        Union[model.AssetAdministrationShell, model.Submodel]: basyx model from the given client model\n    \"\"\"\n    if not isinstance(client_model, dict):\n        client_model = client_model.to_dict()\n    remove_empty_lists(client_model)\n    json_model = json.dumps(client_model, indent=4)\n    basyx_model = json.loads(json_model, cls=basyx.aas.adapter.json.AASFromJsonDecoder)\n    return basyx_model\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client","title":"<code>submodel_client</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.delete_submodel_from_server","title":"<code>delete_submodel_from_server(submodel_id, submodel_client)</code>  <code>async</code>","text":"<p>Function to delete a submodel from the server</p> <p>Parameters:</p> Name Type Description Default <code>submodel_id</code> <code>str</code> <p>id of the submodel</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def delete_submodel_from_server(submodel_id: str, submodel_client: SubmodelClient):\n    \"\"\"\n    Function to delete a submodel from the server\n    Args:\n        submodel_id (str): id of the submodel\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Raises:\n        HTTPException: If submodel with the given id does not exist\n    \"\"\"\n    if not await submodel_is_on_server(submodel_id, submodel_client):\n        raise HTTPException(\n            status_code=400, detail=f\"Submodel with id {submodel_id} does not exist. Cannot delete it.\"\n        )\n    base_64_id = client_utils.get_base64_from_string(submodel_id)\n    await delete_submodel_by_id.asyncio(client=submodel_client, submodel_identifier=base_64_id)\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.get_all_basyx_submodels_from_server","title":"<code>get_all_basyx_submodels_from_server(aas, submodel_client)</code>  <code>async</code>","text":"<p>Function to get all submodels from an AAS in basyx format</p> <p>Parameters:</p> Name Type Description Default <code>aas</code> <code>model.AssetAdministrationShell</code> <p>AAS to get submodels from</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Returns:</p> Type Description <code>List[model.Submodel]</code> <p>List of basyx submodels retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def get_all_basyx_submodels_from_server(aas: model.AssetAdministrationShell, submodel_client: SubmodelClient) -&gt; List[ClientSubmodel]:\n    \"\"\"\n    Function to get all submodels from an AAS in basyx format\n    Args:\n        aas (model.AssetAdministrationShell): AAS to get submodels from\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Returns:\n        List[model.Submodel]: List of basyx submodels retrieved from the server\n    \"\"\"\n    submodels = []\n    for submodel_reference in aas.submodel:\n        basyx_submodel = await get_basyx_submodel_from_server(submodel_reference.key[0].value, submodel_client)\n        submodels.append(basyx_submodel)\n    return submodels\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.get_all_submodel_data_from_server","title":"<code>get_all_submodel_data_from_server(submodel_client)</code>  <code>async</code>","text":"<p>Function to get all submodels from the server</p> <p>Returns:</p> Type Description <code>List[aas_model.Submodel]</code> <p>List of submodels retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def get_all_submodel_data_from_server(submodel_client: SubmodelClient) -&gt; List[ClientSubmodel]:\n    \"\"\"\n    Function to get all submodels from the server\n    Returns:\n        List[aas_model.Submodel]: List of submodels retrieved from the server\n    \"\"\"\n    submodel_data = await get_all_submodels.asyncio(client=submodel_client)\n    submodel_data = submodel_data.result\n    return submodel_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.get_all_submodels_of_type","title":"<code>get_all_submodels_of_type(model, submodel_client)</code>  <code>async</code>","text":"<p>Function to get all submodels of a certain type from the server</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel</code> <p>Pydantic model of the submodel</p> required <p>Returns:</p> Type Description <code>List[aas_model.Submodel]</code> <p>List of submodels retrieved from the server</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def get_all_submodels_of_type(model: BaseModel, submodel_client: SubmodelClient) -&gt; List[aas_model.Submodel]:\n    \"\"\"\n    Function to get all submodels of a certain type from the server\n    Args:\n        model (BaseModel): Pydantic model of the submodel\n    Returns:\n        List[aas_model.Submodel]: List of submodels retrieved from the server\n    \"\"\"\n    submodels_data = await get_all_submodel_data_from_server(submodel_client)\n    submodels_of_type = []\n    for submodel_data in submodels_data:\n        basyx_submodel = client_utils.transform_client_to_basyx_model(submodel_data)\n        submodel = convert_submodel_to_model(basyx_submodel)\n        if submodel.__class__.__name__ == model.__name__:\n            submodels_of_type.append(submodel)\n    return submodels_of_type\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.get_basyx_submodel_from_server","title":"<code>get_basyx_submodel_from_server(submodel_id, submodel_client)</code>  <code>async</code>","text":"<p>Function to get a submodel from the server</p> <p>Parameters:</p> Name Type Description Default <code>submodel_id</code> <code>str</code> <p>id of the submodel</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Returns:</p> Type Description <code>model.Submodel</code> <p>submodel retrieved from the server</p> <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def get_basyx_submodel_from_server(submodel_id: str, submodel_client: SubmodelClient) -&gt; model.Submodel:\n    \"\"\"\n    Function to get a submodel from the server\n    Args:\n        submodel_id (str): id of the submodel\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Returns:\n        model.Submodel: submodel retrieved from the server\n\n    Raises:\n        HTTPException: If submodel with the given id does not exist\n    \"\"\"\n    base_64_id = client_utils.get_base64_from_string(submodel_id)\n    try:\n        submodel_data = await get_submodel_by_id.asyncio(\n            client=submodel_client, submodel_identifier=base_64_id\n        )\n        return client_utils.transform_client_to_basyx_model(submodel_data.to_dict())\n    except Exception as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Submodel with id {submodel_id} could not be retrieved. Error: {e}\"\n        )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.get_submodel_from_server","title":"<code>get_submodel_from_server(submodel_id, submodel_client)</code>  <code>async</code>","text":"<p>Function to get a submodel from the server</p> <p>Parameters:</p> Name Type Description Default <code>submodel_id</code> <code>str</code> <p>id of the submodel</p> required <p>Returns:</p> Type Description <code>aas_model.Submodel</code> <p>submodel retrieved from the server</p> <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def get_submodel_from_server(submodel_id: str, submodel_client: SubmodelClient) -&gt; aas_model.Submodel:\n    \"\"\"\n    Function to get a submodel from the server\n    Args:\n        submodel_id (str): id of the submodel\n    Returns:\n        aas_model.Submodel: submodel retrieved from the server\n\n    Raises:\n        HTTPException: If submodel with the given id does not exist\n    \"\"\"\n    try:\n        basyx_submodel = await get_basyx_submodel_from_server(submodel_id, submodel_client)\n        return convert_submodel_to_model(basyx_submodel)\n    except HTTPException as e:\n        raise HTTPException(\n            status_code=400, detail=f\"Submodel with id {submodel_id} could not be retrieved. Error: {e}\"\n        )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.post_submodel_to_server","title":"<code>post_submodel_to_server(pydantic_submodel, submodel_client)</code>  <code>async</code>","text":"<p>Function to post a submodel to the server</p> <p>Parameters:</p> Name Type Description Default <code>pydantic_submodel</code> <code>aas_model.Submodel</code> <p>submodel to post</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given id already exists</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def post_submodel_to_server(pydantic_submodel: aas_model.Submodel, submodel_client: SubmodelClient):\n    \"\"\"\n    Function to post a submodel to the server\n    Args:\n        pydantic_submodel (aas_model.Submodel): submodel to post\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Raises:\n        HTTPException: If submodel with the given id already exists\n    \"\"\"\n    if await submodel_is_on_server(pydantic_submodel.id, submodel_client):\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Submodel with id {pydantic_submodel.id} already exists. Try putting it instead.\",\n        )\n    basyx_submodel = convert_model_to_submodel(pydantic_submodel)\n    submodel_for_client = client_utils.ClientModel(basyx_object=basyx_submodel)\n    # TODO: make a try except with json.decoder.JSONDecodeError to avoid error when posting a submodel that already exists, same goes for aas\n    response = await post_submodel.asyncio(client=submodel_client, body=submodel_for_client)\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.put_submodel_to_server","title":"<code>put_submodel_to_server(submodel, submodel_client)</code>  <code>async</code>","text":"<p>Function to put a submodel to the server</p> <p>Parameters:</p> Name Type Description Default <code>submodel</code> <code>aas_model.Submodel</code> <p>submodel to put</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Exceptions:</p> Type Description <code>HTTPException</code> <p>If submodel with the given id does not exist</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def put_submodel_to_server(submodel: aas_model.Submodel, submodel_client: SubmodelClient):\n    \"\"\"\n    Function to put a submodel to the server\n    Args:\n        submodel (aas_model.Submodel): submodel to put\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Raises:\n        HTTPException: If submodel with the given id does not exist\n    \"\"\"\n    if not await submodel_is_on_server(submodel.id, submodel_client):\n        raise HTTPException(\n            status_code=400, detail=f\"Submodel with id {submodel.id} does not exist. Try posting it first.\"\n        )\n    basyx_submodel = convert_model_to_submodel(submodel)\n    submodel_for_client = client_utils.ClientModel(basyx_object=basyx_submodel)\n    base_64_id = client_utils.get_base64_from_string(submodel.id)\n    response = await put_submodel_by_id.asyncio(\n        submodel_identifier=base_64_id, client=submodel_client, body=submodel_for_client\n    )\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.aas_client_connector.submodel_client.submodel_is_on_server","title":"<code>submodel_is_on_server(submodel_id, submodel_client)</code>  <code>async</code>","text":"<p>Function to check if a submodel with the given id is on the server</p> <p>Parameters:</p> Name Type Description Default <code>submodel_id</code> <code>str</code> <p>id of the submodel</p> required <code>submodel_client</code> <code>SubmodelClient</code> <p>client to connect to the server</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if submodel is on server, False if not</p> Source code in <code>aas_middleware\\connect\\connectors\\aas_client_connector\\submodel_client.py</code> <pre><code>async def submodel_is_on_server(submodel_id: str, submodel_client: SubmodelClient) -&gt; bool:\n    \"\"\"\n    Function to check if a submodel with the given id is on the server\n    Args:\n        submodel_id (str): id of the submodel\n        submodel_client (SubmodelClient): client to connect to the server\n\n    Returns:\n        bool: True if submodel is on server, False if not\n    \"\"\"\n    try:\n        await get_submodel_from_server(submodel_id, submodel_client)\n        return True\n    except HTTPException as e:\n        return False\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector","title":"<code>async_connector</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Publisher","title":"<code> Publisher            (Protocol)         </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>@runtime_checkable\nclass Publisher(Protocol):\n    async def connect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def disconnect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def publish(self, topic: str, message: Any) -&gt; None:\n        \"\"\"\n        Interfaces for a publisher to publish messages to a topic.\n\n        Args:\n            topic (str): The topic to publish the message to.\n            message (Any): The message to be published.\n\n        Raises:\n            ConnectionError: If the publishing of the message failed.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Publisher.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Publisher.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Publisher.publish","title":"<code>publish(self, topic, message)</code>  <code>async</code>","text":"<p>Interfaces for a publisher to publish messages to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to publish the message to.</p> required <code>message</code> <code>Any</code> <p>The message to be published.</p> required <p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the publishing of the message failed.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def publish(self, topic: str, message: Any) -&gt; None:\n    \"\"\"\n    Interfaces for a publisher to publish messages to a topic.\n\n    Args:\n        topic (str): The topic to publish the message to.\n        message (Any): The message to be published.\n\n    Raises:\n        ConnectionError: If the publishing of the message failed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Subsciber","title":"<code> Subsciber            (Protocol)         </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>@runtime_checkable\nclass Subsciber(Protocol):\n    async def connect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def disconnect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def subscribe(self, topic: str, callback: Callable[[Any], Awaitable[None] | Any]) -&gt; None:\n        \"\"\"\n        Interfaces for a subscriber to subscribe to a topic and receive messages.\n\n        Args:\n            topic (str): The topic to subscribe to.\n            callback (Callable[[str, str], Awaitable[None]]): The callback to be executed when a message is received.\n\n        Raises:\n            ConnectionError: If the subscribing to the topic failed.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Subsciber.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Subsciber.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.async_connector.Subsciber.subscribe","title":"<code>subscribe(self, topic, callback)</code>  <code>async</code>","text":"<p>Interfaces for a subscriber to subscribe to a topic and receive messages.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to subscribe to.</p> required <code>callback</code> <code>Callable[[str, str], Awaitable[None]]</code> <p>The callback to be executed when a message is received.</p> required <p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the subscribing to the topic failed.</p> Source code in <code>aas_middleware\\connect\\connectors\\async_connector.py</code> <pre><code>async def subscribe(self, topic: str, callback: Callable[[Any], Awaitable[None] | Any]) -&gt; None:\n    \"\"\"\n    Interfaces for a subscriber to subscribe to a topic and receive messages.\n\n    Args:\n        topic (str): The topic to subscribe to.\n        callback (Callable[[str, str], Awaitable[None]]): The callback to be executed when a message is received.\n\n    Raises:\n        ConnectionError: If the subscribing to the topic failed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector","title":"<code>connector</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Consumer","title":"<code> Consumer            (Protocol)         </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>@runtime_checkable\nclass Consumer(Protocol):\n    async def connect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def disconnect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def consume(self, body: Any) -&gt; None:\n        \"\"\"\n        Interfaces for a consumer to consume data and send in with the connection to the consumer.\n\n        Args:\n            body (Any): The data to be consumed.\n\n        Raises:\n            ConnectionError: If the consuming of the data failed.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Consumer.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Consumer.consume","title":"<code>consume(self, body)</code>  <code>async</code>","text":"<p>Interfaces for a consumer to consume data and send in with the connection to the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Any</code> <p>The data to be consumed.</p> required <p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the consuming of the data failed.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def consume(self, body: Any) -&gt; None:\n    \"\"\"\n    Interfaces for a consumer to consume data and send in with the connection to the consumer.\n\n    Args:\n        body (Any): The data to be consumed.\n\n    Raises:\n        ConnectionError: If the consuming of the data failed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Consumer.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Provider","title":"<code> Provider            (Protocol)         </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>@runtime_checkable\nclass Provider(Protocol):\n    async def connect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def disconnect(self):\n        \"\"\"\n        Raises:\n            ConnectionError: If the connection to the server could not be established.\n        \"\"\"\n        ...\n\n    async def provide(self) -&gt; Any:\n        \"\"\"\n        Interfaces for a provider to provide data.\n\n        Returns:\n            Any: The data to be provided.\n\n        Raises:\n            ConnectionError: If the providing of the data failed.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Provider.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Provider.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the connection to the server could not be established.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Raises:\n        ConnectionError: If the connection to the server could not be established.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.connector.Provider.provide","title":"<code>provide(self)</code>  <code>async</code>","text":"<p>Interfaces for a provider to provide data.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The data to be provided.</p> <p>Exceptions:</p> Type Description <code>ConnectionError</code> <p>If the providing of the data failed.</p> Source code in <code>aas_middleware\\connect\\connectors\\connector.py</code> <pre><code>async def provide(self) -&gt; Any:\n    \"\"\"\n    Interfaces for a provider to provide data.\n\n    Returns:\n        Any: The data to be provided.\n\n    Raises:\n        ConnectionError: If the providing of the data failed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector","title":"<code>web_hook_client_connector</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector","title":"<code> WebHookClientConnector        </code>","text":"<p>Class for a WebHookClientConnector that can be used to connect to a webhook and receive data from it.</p> <p>Parameters:</p> Name Type Description Default <code>web_hook_url</code> <code>str</code> <p>adress of the webhook</p> required <p>Attributes:</p> Name Type Description <code>web_hook_url</code> <code>str</code> <p>adress of the webhook server</p> <code>own_url</code> <code>Optional[str]</code> <p>own url where the webhook sends data to</p> <code>hook</code> <code>Optional[anyio.Event]</code> <p>hook event for posts of the webhook</p> <code>connected_subscriber</code> <code>Optional[str]</code> <p>adress of the subscriber that is connected to the webhook</p> <code>received_data</code> <code>str</code> <p>data received from the webhook</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>class WebHookClientConnector:\n    \"\"\"\n    Class for a WebHookClientConnector that can be used to connect to a webhook and receive data from it.\n\n    Args:\n        web_hook_url (str): adress of the webhook\n\n    Attributes:\n        web_hook_url (str): adress of the webhook server\n        own_url (Optional[str]): own url where the webhook sends data to\n        hook (Optional[anyio.Event]): hook event for posts of the webhook\n        connected_subscriber (Optional[str]): adress of the subscriber that is connected to the webhook\n        received_data (str): data received from the webhook\n    \"\"\"\n\n    def __init__(self, web_hook_url: str):\n        \"\"\"\n        Args:\n            web_hook_url (str): adress of the webhook\n        \"\"\"\n        self.web_hook_url = web_hook_url\n        self.own_url: Optional[str] = None\n        self.hook: Optional[anyio.Event] = None\n        self.connected_subscriber: Optional[str] = None\n        self.received_data: str = \"\"\n\n    async def set_hook(self, hook: anyio.Event, url: str):\n        \"\"\"\n        Function sets the hook event for posts of the webhook and the url where the webhook should post to.\n        \"\"\"\n        # TODO: set this hook when adding the hook to a provider so that it is linked to fastAPI post route of the datamodel\n        # either to this with a callback or these events.\n        self.hook = hook\n        self.own_url = url\n\n    async def trigger_hook(self, body: str):\n        \"\"\"\n        Function triggers the hook for the webhook.\n        \"\"\"\n        if not self.hook:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Webhook does not have a hook set. Please use the set_hook function to set the hook.\",\n            )\n        self.received_data = body\n        self.hook.set()\n\n    async def connect(self):\n        \"\"\"\n        Function connects to the webhook with a post request that sends the middleware url to the webhook.\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                self.web_hook_url, json={\"url\": self.own_url}\n            ) as response:\n                status = response.status\n                if status != 200:\n                    raise HTTPException(\n                        status_code=400,\n                        detail=\"Webhook could not connect to the webhook server.\",\n                    )\n                # TODO: add logging for somethink like this!\n                await response.text()\n\n    async def disconnect(self):\n        \"\"\"\n        Function disconnects from the webhook.\n        \"\"\"\n        # TODO: either remove the hookevent from the provider or set it to false or\n        # remove the callback from the endpoint of the provider\n\n    async def consume(self, body: str) -&gt; str:\n        raise NotImplementedError(\n            \"WebHookClientConnector does not support sending data but only receiving data. Try to use the WebHookServerConnector instead.\"\n        )\n\n    async def provide(self) -&gt; str:\n        \"\"\"\n        Function receives data from the webhook.\n\n        \"\"\"\n        if not self.hook:\n            raise Exception(\n                \"WebHookClientConnector does not have a hook set. Please use the set_hook function to set the hook.\"\n            )\n        await self.hook.wait()\n        self.hook = anyio.Event()\n        return self.received_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.__init__","title":"<code>__init__(self, web_hook_url)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>web_hook_url</code> <code>str</code> <p>adress of the webhook</p> required Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>def __init__(self, web_hook_url: str):\n    \"\"\"\n    Args:\n        web_hook_url (str): adress of the webhook\n    \"\"\"\n    self.web_hook_url = web_hook_url\n    self.own_url: Optional[str] = None\n    self.hook: Optional[anyio.Event] = None\n    self.connected_subscriber: Optional[str] = None\n    self.received_data: str = \"\"\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Function connects to the webhook with a post request that sends the middleware url to the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Function connects to the webhook with a post request that sends the middleware url to the webhook.\n    \"\"\"\n    async with aiohttp.ClientSession() as session:\n        async with session.post(\n            self.web_hook_url, json={\"url\": self.own_url}\n        ) as response:\n            status = response.status\n            if status != 200:\n                raise HTTPException(\n                    status_code=400,\n                    detail=\"Webhook could not connect to the webhook server.\",\n                )\n            # TODO: add logging for somethink like this!\n            await response.text()\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Function disconnects from the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Function disconnects from the webhook.\n    \"\"\"\n    # TODO: either remove the hookevent from the provider or set it to false or\n    # remove the callback from the endpoint of the provider\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.provide","title":"<code>provide(self)</code>  <code>async</code>","text":"<p>Function receives data from the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>async def provide(self) -&gt; str:\n    \"\"\"\n    Function receives data from the webhook.\n\n    \"\"\"\n    if not self.hook:\n        raise Exception(\n            \"WebHookClientConnector does not have a hook set. Please use the set_hook function to set the hook.\"\n        )\n    await self.hook.wait()\n    self.hook = anyio.Event()\n    return self.received_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.set_hook","title":"<code>set_hook(self, hook, url)</code>  <code>async</code>","text":"<p>Function sets the hook event for posts of the webhook and the url where the webhook should post to.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>async def set_hook(self, hook: anyio.Event, url: str):\n    \"\"\"\n    Function sets the hook event for posts of the webhook and the url where the webhook should post to.\n    \"\"\"\n    # TODO: set this hook when adding the hook to a provider so that it is linked to fastAPI post route of the datamodel\n    # either to this with a callback or these events.\n    self.hook = hook\n    self.own_url = url\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_client_connector.WebHookClientConnector.trigger_hook","title":"<code>trigger_hook(self, body)</code>  <code>async</code>","text":"<p>Function triggers the hook for the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_client_connector.py</code> <pre><code>async def trigger_hook(self, body: str):\n    \"\"\"\n    Function triggers the hook for the webhook.\n    \"\"\"\n    if not self.hook:\n        raise HTTPException(\n            status_code=400,\n            detail=\"Webhook does not have a hook set. Please use the set_hook function to set the hook.\",\n        )\n    self.received_data = body\n    self.hook.set()\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector","title":"<code>web_hook_server_connector</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector","title":"<code> WebHookServerConnector        </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>class WebHookServerConnector:\n    def __init__(self):\n        self.hook: anyio.Event = anyio.Event()\n        self.connected_subscribers: List[str] = []\n        self.received_data: str = \"\"\n        self.connectable: bool = False\n\n    async def start_server(self) -&gt; None:\n        \"\"\"\n        Acticates an endpoint where clients can connect to with a post request that sends the url to post the webhook data to.\n        \"\"\"\n        # TODO: add functionality that when added to a consumer, an endpoint is created for webhook clients to connect to.\n        # and one endpoint to remove client subsciptions. THe register and unregister functions should then be used.\n        pass\n\n    async def register_subscriber(self, url: str) -&gt; None:\n        \"\"\"\n        Function registers a subscriber to the webhook.\n\n        Args:\n            url (str): _description_\n        \"\"\"\n        if not self.connectable:\n            raise HTTPException(status_code=400, detail=\"Webhook not connectable.\")\n        self.connected_subscribers.append(url)\n\n    async def unregister_subscriber(self, url: str) -&gt; None:\n        \"\"\"\n        Function unregisters a subscriber from the webhook.\n\n        Args:\n            url (str): _description_\n        \"\"\"\n        try:\n            self.connected_subscribers.remove(url)\n        except ValueError:\n            raise HTTPException(status_code=400, detail=\"Subscriber not registered.\")\n\n    async def connect(self):\n        \"\"\"\n        Function allows clients to connect to the webhook.\n        \"\"\"\n        self.connectable = True\n\n    async def disconnect(self):\n        \"\"\"\n        Function disconnects all subscribed clients from the webhook.\n        \"\"\"\n        self.connectable = False\n        self.connected_subscribers = []\n\n    async def consume(self) -&gt; str:\n        \"\"\"\n        Function sends data to all subscribed clients of the webhook.\n\n        Args:\n            body (str): _description_\n\n        Returns:\n            str: _description_\n        \"\"\"\n        await self.hook.wait()\n        if not self.connectable:\n            raise HTTPException(status_code=400, detail=\"Webhook not connectable.\")\n        self.hook.set()\n        for subscriber in self.connected_subscribers:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    subscriber, data=self.received_data\n                ) as response:\n                    await response.text()\n        return \"Webhook message sent\"\n\n    async def provide(self) -&gt; str:\n        raise NotImplementedError\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Function allows clients to connect to the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Function allows clients to connect to the webhook.\n    \"\"\"\n    self.connectable = True\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.consume","title":"<code>consume(self)</code>  <code>async</code>","text":"<p>Function sends data to all subscribed clients of the webhook.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def consume(self) -&gt; str:\n    \"\"\"\n    Function sends data to all subscribed clients of the webhook.\n\n    Args:\n        body (str): _description_\n\n    Returns:\n        str: _description_\n    \"\"\"\n    await self.hook.wait()\n    if not self.connectable:\n        raise HTTPException(status_code=400, detail=\"Webhook not connectable.\")\n    self.hook.set()\n    for subscriber in self.connected_subscribers:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                subscriber, data=self.received_data\n            ) as response:\n                await response.text()\n    return \"Webhook message sent\"\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.disconnect","title":"<code>disconnect(self)</code>  <code>async</code>","text":"<p>Function disconnects all subscribed clients from the webhook.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def disconnect(self):\n    \"\"\"\n    Function disconnects all subscribed clients from the webhook.\n    \"\"\"\n    self.connectable = False\n    self.connected_subscribers = []\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.register_subscriber","title":"<code>register_subscriber(self, url)</code>  <code>async</code>","text":"<p>Function registers a subscriber to the webhook.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>description</p> required Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def register_subscriber(self, url: str) -&gt; None:\n    \"\"\"\n    Function registers a subscriber to the webhook.\n\n    Args:\n        url (str): _description_\n    \"\"\"\n    if not self.connectable:\n        raise HTTPException(status_code=400, detail=\"Webhook not connectable.\")\n    self.connected_subscribers.append(url)\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.start_server","title":"<code>start_server(self)</code>  <code>async</code>","text":"<p>Acticates an endpoint where clients can connect to with a post request that sends the url to post the webhook data to.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def start_server(self) -&gt; None:\n    \"\"\"\n    Acticates an endpoint where clients can connect to with a post request that sends the url to post the webhook data to.\n    \"\"\"\n    # TODO: add functionality that when added to a consumer, an endpoint is created for webhook clients to connect to.\n    # and one endpoint to remove client subsciptions. THe register and unregister functions should then be used.\n    pass\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_hook_server_connector.WebHookServerConnector.unregister_subscriber","title":"<code>unregister_subscriber(self, url)</code>  <code>async</code>","text":"<p>Function unregisters a subscriber from the webhook.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>description</p> required Source code in <code>aas_middleware\\connect\\connectors\\web_hook_server_connector.py</code> <pre><code>async def unregister_subscriber(self, url: str) -&gt; None:\n    \"\"\"\n    Function unregisters a subscriber from the webhook.\n\n    Args:\n        url (str): _description_\n    \"\"\"\n    try:\n        self.connected_subscribers.remove(url)\n    except ValueError:\n        raise HTTPException(status_code=400, detail=\"Subscriber not registered.\")\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_socket_server_connector","title":"<code>web_socket_server_connector</code>","text":""},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_socket_server_connector.WebSocketServerConnector","title":"<code> WebSocketServerConnector        </code>","text":"Source code in <code>aas_middleware\\connect\\connectors\\web_socket_server_connector.py</code> <pre><code>class WebSocketServerConnector:\n    def __init__(\n        self, host: str, port: int, reply_function: Optional[Callable[[], str]] = None\n    ):\n        self.host = host\n        self.port = port\n        self.server: Optional[websockets.WebSocketServer] = None\n        self.websocket: Optional[websockets.WebSocketServerProtocol] = None\n        self.received_data_event = anyio.Event()\n        self.received_data: str = \"\"\n        self.reply_function = reply_function\n        self.connectable = False\n\n    async def start_server(self) -&gt; None:\n        self.server = await websockets.serve(\n            self.handle_websocket, self.host, self.port\n        )\n\n    async def handle_websocket(\n        self, websocket: websockets.WebSocketServerProtocol, path: str\n    ) -&gt; None:\n        if not self.connectable:\n            await websocket.close()\n            return\n        self.websocket = websocket\n\n        try:\n            async for message in websocket:\n                print(f\"Received message: {message}\")\n                if isinstance(message, bytes):\n                    message = message.decode()\n                self.received_data = message\n                self.received_data_event.set()\n                if self.reply_function:\n                    await websocket.send(self.reply_function())\n                else:\n                    await websocket.send(\"Message received\")\n\n        except websockets.exceptions.ConnectionClosed:\n            raise HTTPException(status_code=400, detail=\"Websocket connection closed.\")\n\n    async def connect(self) -&gt; None:\n        \"\"\"\n        Function activates that connection to the server are allowed and accepted.\n        \"\"\"\n        if not self.server:\n            raise HTTPException(\n                status_code=400, detail=\"Websocket server is not started.\"\n            )\n        self.connectable = True\n        if not self.server:\n            await self.start_server()\n\n    async def disconnect(self) -&gt; None:\n        self.connectable = False\n        if self.websocket:\n            await self.websocket.close()\n            self.websocket = None\n        if self.server:\n            self.server.close()\n            await self.server.wait_closed()\n            self.server = None\n\n    async def consume(self, body: str) -&gt; Optional[str]:\n        if not self.server:\n            raise HTTPException(\n                status_code=400, detail=\"Websocket server is not started.\"\n            )\n        if not self.websocket:\n            raise HTTPException(\n                status_code=400, detail=\"Websocket not connected to websocket server.\"\n            )\n        await self.websocket.send(body)\n\n    async def provide(self) -&gt; str:\n        await self.received_data_event.wait()\n        self.received_data_event = anyio.Event()\n        return self.received_data\n</code></pre>"},{"location":"API_reference/API_reference_3_connect/#aas_middleware.connect.connectors.web_socket_server_connector.WebSocketServerConnector.connect","title":"<code>connect(self)</code>  <code>async</code>","text":"<p>Function activates that connection to the server are allowed and accepted.</p> Source code in <code>aas_middleware\\connect\\connectors\\web_socket_server_connector.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Function activates that connection to the server are allowed and accepted.\n    \"\"\"\n    if not self.server:\n        raise HTTPException(\n            status_code=400, detail=\"Websocket server is not started.\"\n        )\n    self.connectable = True\n    if not self.server:\n        await self.start_server()\n</code></pre>"},{"location":"Guides/Tutorials_overview/","title":"Tutorial Overview","text":""},{"location":"Guides/aas_guide/","title":"TODO: write a guide that explains how an aas persistence can be created","text":""},{"location":"Guides/connection_guide/","title":"TODO: write a guide that demonstrates how a connection to mqtt, opc ua or so is done","text":""},{"location":"Guides/connection_guide/#todo-also-show-how-custom-connectors-can-be-created","title":"TODO: also show how custom connectors can be created","text":""},{"location":"Guides/deployment_guide/","title":"Deployment Guide","text":""}]}